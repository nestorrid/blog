{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/hexo-theme-Claudia/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/js/common.js","path":"js/common.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/js/img_zoom.js","path":"js/img_zoom.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/js/highlight.pack.js","path":"js/highlight.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/js/jquery-3.6.1.min.js","path":"js/jquery-3.6.1.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/js/post.js","path":"js/post.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/js/jquery-fancybox.min.js","path":"js/jquery-fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/archive.scss","path":"style/archive.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/base.scss","path":"style/base.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/about.scss","path":"style/about.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/post.scss","path":"style/post.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/widget-header.scss","path":"style/widget-header.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/widget-post-list.scss","path":"style/widget-post-list.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/common/helper.scss","path":"style/common/helper.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/common/bulma.css","path":"style/common/bulma.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/common/jquery.fancybox.min.css","path":"style/common/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/common/variable.scss","path":"style/common/variable.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/themes/default-dark.scss","path":"style/themes/default-dark.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/themes/highlight-theme-light.css","path":"style/themes/highlight-theme-light.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/themes/theme.scss","path":"style/themes/theme.scss","modified":0,"renderable":1},{"_id":"themes/hexo-theme-Claudia/source/style/themes/default-light.scss","path":"style/themes/default-light.scss","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/presentations/index.html","path":"presentations/index.html","modified":0,"renderable":0},{"_id":"source/assets/img/48223734b31de65181a4a38de6d8ac54.png","path":"assets/img/48223734b31de65181a4a38de6d8ac54.png","modified":0,"renderable":0},{"_id":"source/assets/img/image-20231108212229095.png","path":"assets/img/image-20231108212229095.png","modified":0,"renderable":0},{"_id":"source/assets/img/image-20231109160342949.png","path":"assets/img/image-20231109160342949.png","modified":0,"renderable":0},{"_id":"source/assets/img/image-20231109181130563.png","path":"assets/img/image-20231109181130563.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311112225443281.png","path":"assets/img/img_202311112225443281.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311112240579548.png","path":"assets/img/img_202311112240579548.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311112248208661.png","path":"assets/img/img_202311112248208661.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311112310499438.png","path":"assets/img/img_202311112310499438.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311111749462365.png","path":"assets/img/img_202311111749462365.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311120105246528.png","path":"assets/img/img_202311120105246528.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311120215571964.png","path":"assets/img/img_202311120215571964.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311121735237199.png","path":"assets/img/img_202311121735237199.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311122320571347.png","path":"assets/img/img_202311122320571347.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311130227323161.png","path":"assets/img/img_202311130227323161.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311130250548202.png","path":"assets/img/img_202311130250548202.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311131814429529.png","path":"assets/img/img_202311131814429529.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311131817332685.png","path":"assets/img/img_202311131817332685.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311131941497659.png","path":"assets/img/img_202311131941497659.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311141520211655.png","path":"assets/img/img_202311141520211655.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311141802036688.png","path":"assets/img/img_202311141802036688.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311151738162426.png","path":"assets/img/img_202311151738162426.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311152245318150.png","path":"assets/img/img_202311152245318150.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311162146456205.png","path":"assets/img/img_202311162146456205.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311180006318654.png","path":"assets/img/img_202311180006318654.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311180103427767.png","path":"assets/img/img_202311180103427767.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311180514299621.png","path":"assets/img/img_202311180514299621.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311170358241255.png","path":"assets/img/img_202311170358241255.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311180516007386.png","path":"assets/img/img_202311180516007386.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311211957171241.png","path":"assets/img/img_202311211957171241.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311182234203649.png","path":"assets/img/img_202311182234203649.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311212007505770.png","path":"assets/img/img_202311212007505770.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311230930147088.png","path":"assets/img/img_202311230930147088.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311241307079570.png","path":"assets/img/img_202311241307079570.png","modified":0,"renderable":0},{"_id":"source/assets/img/img_202311241434531606.png","path":"assets/img/img_202311241434531606.png","modified":0,"renderable":0},{"_id":"source/assets/img/lucy.png","path":"assets/img/lucy.png","modified":0,"renderable":0},{"_id":"source/assets/img/separator_1.png","path":"assets/img/separator_1.png","modified":0,"renderable":0},{"_id":"source/assets/img/separator_3.png","path":"assets/img/separator_3.png","modified":0,"renderable":0},{"_id":"source/assets/img/separator_5.png","path":"assets/img/separator_5.png","modified":0,"renderable":0},{"_id":"source/assets/img/favicons/android-chrome-192x192.png","path":"assets/img/favicons/android-chrome-192x192.png","modified":0,"renderable":0},{"_id":"source/assets/img/favicons/android-chrome-512x512.png","path":"assets/img/favicons/android-chrome-512x512.png","modified":0,"renderable":0},{"_id":"source/assets/img/favicons/browserconfig.xml","path":"assets/img/favicons/browserconfig.xml","modified":0,"renderable":0},{"_id":"source/assets/img/favicons/favicon-16x16.png","path":"assets/img/favicons/favicon-16x16.png","modified":0,"renderable":0},{"_id":"source/assets/img/favicons/favicon-32x32.png","path":"assets/img/favicons/favicon-32x32.png","modified":0,"renderable":0},{"_id":"source/assets/img/favicons/mstile-150x150.png","path":"assets/img/favicons/mstile-150x150.png","modified":0,"renderable":0},{"_id":"source/assets/img/favicons/safari-pinned-tab.svg","path":"assets/img/favicons/safari-pinned-tab.svg","modified":0,"renderable":0},{"_id":"source/assets/img/favicons/site.webmanifest","path":"assets/img/favicons/site.webmanifest","modified":0,"renderable":0},{"_id":"source/assets/img/favicons/apple-touch-icon.png","path":"assets/img/favicons/apple-touch-icon.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/presentations/index.html","hash":"f87884e9d729c62a334a3c5260d358942067172b","modified":1702456868466},{"_id":"source/CNAME","hash":"d10bc9c6b0779d3be61bb762db25fc53a9939d37","modified":1702457737344},{"_id":"source/_data/menu.yml","hash":"ba455e016905f5e498114de76259921d16a40ab9","modified":1702456868339},{"_id":"source/_posts/others/custom-oh-my-zsh-theme.md","hash":"e3b3713ecd504bfa716762db654f7e54f84e868a","modified":1702457038102},{"_id":"source/_posts/others/jekyll-chirpy-gitee.md","hash":"d4cf286add2265a319ed1e54a82c18c14faef026","modified":1702456868350},{"_id":"source/_posts/others/docker-notes.md","hash":"1091dae9a72625d896be73a32384a0df4ad5c8b4","modified":1702456868350},{"_id":"source/_posts/others/jekyll-quickstart.md","hash":"ab10d94d815cfa2be6a065b5d8fa287b72129445","modified":1702456868350},{"_id":"source/_posts/others/pylint-config-in-vscode.md","hash":"ddfbf8d7adcc40b8d38e9177380bc3647f476ad1","modified":1702456868351},{"_id":"source/_posts/others/linux-basic-commands.md","hash":"3bd82198baf7c3a6f6604b0e083c63db8df1a18a","modified":1702456868351},{"_id":"source/_posts/others/note-for-learn-mysql.md","hash":"c8fa384914fe68ae6bee704ccd02515cd746ef29","modified":1702456868351},{"_id":"source/_posts/others/git-note.md","hash":"ad227b61b3b1ef897e8a3243d1b9e5e0637ff0db","modified":1702456868350},{"_id":"source/_posts/others/pylint-django-vscode-no-member-in-models.md","hash":"e332ba5d421a44fb2940ffbe3b7b00d82ec5d4fd","modified":1702456868351},{"_id":"source/_posts/django/1-first-django-project.md","hash":"8593aaff7044e35c8a3bc410a08d8547ebe363a8","modified":1702456868345},{"_id":"source/_posts/others/python-valuable-opensource-libraries-collection.md","hash":"7a4136ddd0960cf3891c2afcba7dcc3a4ca3b7e6","modified":1702456868351},{"_id":"source/_posts/others/set-gem-sources.md","hash":"dda3fb206e6f9e8ea3edc8be47a56173ffa350f2","modified":1702456868352},{"_id":"source/_posts/django/2-creating-models.md","hash":"153bb4ee9fcd716a1bb83de09a84bfadbe24b3c3","modified":1702456868345},{"_id":"source/_posts/django/3-using-mysql.md","hash":"e728c8be1729ca8f62afe146149412c4ea924e6f","modified":1702456868346},{"_id":"source/_posts/others/runtime-error-failed-to-lock-pipfile.md","hash":"08dad4271a84ae2ce6d244507368ed828afc533f","modified":1702456868352},{"_id":"source/_posts/django/10-using-restful-api-in-django.md","hash":"8ff28d6972217b133f43d86d5fc4885c0a56c849","modified":1702456868345},{"_id":"source/_posts/django/4-use-django-orm.md","hash":"dc1bb3ee719b63837a54db9e7f5f3b09d51ec184","modified":1702456868346},{"_id":"source/_posts/django/8-basic-data-validation.md","hash":"1b7b13bc4aa84d4ad1de74bbaac04c1d73cc178b","modified":1702456868347},{"_id":"source/_posts/django/admin-cli.md","hash":"c1d0567dc19d0265b4dcc68910ee1415fcc2d5f1","modified":1702456868347},{"_id":"source/_posts/django/basic-config.md","hash":"7e2a93d473acbd3f3dec00e775746abeaa178e7e","modified":1702456868347},{"_id":"source/_posts/django/9-extending-pluggable-apps.md","hash":"74d518d2dd9f81d6e26cc3a11e600855f3a7a118","modified":1702456868347},{"_id":"source/_posts/django/5-use-django-admin.md","hash":"96f2982d3e3dfc4938f0378d12ea6763a11e6586","modified":1702456868346},{"_id":"source/_posts/django/rest-deserializing.md","hash":"bb0e158c6c9ea4fa8bacb406ac3b1d24990abf66","modified":1702456868348},{"_id":"source/_posts/django/rest-custom-generic-view.md","hash":"234519c8aa9d1a74759030006dec62e080fa1848","modified":1702456868348},{"_id":"source/_posts/django/6-generic-relationships.md","hash":"4286f01adad904d688dce1b4f45d0fa7de86520b","modified":1702456868346},{"_id":"source/_posts/django/rest-apiview.md","hash":"3a70186104c8323c7a9c183f57f1a8d197379d0a","modified":1702456868347},{"_id":"source/_posts/django/rest-drf-nested-router.md","hash":"c9edea89f15d27bc83a03dd567d2aab4704ebd6f","modified":1702456868348},{"_id":"source/_posts/django/7-custom-model-manager.md","hash":"83eb33c40d7346c438cc35818ed4bf5af7eeb9ef","modified":1702456868346},{"_id":"source/_posts/django/rest-model-serializer.md","hash":"a417b2be14b773bced51298bd693688f640d8650","modified":1702456868349},{"_id":"source/_posts/django/rest-filters-search-ordering-pagination.md","hash":"e00279a6993081d78710e8971f5d7c896fca2959","modified":1702456868348},{"_id":"source/_posts/django/rest-save-update-delete.md","hash":"8aeedd460c9c069ba8c36dcd8c88405899382aa1","modified":1702456868349},{"_id":"source/_posts/django/rest-view-set-and-router.md","hash":"8ebeaad45690f9156755dd5cdfc737863aa279e8","modified":1702456868349},{"_id":"source/_posts/django/rest-generic-view.md","hash":"bc7472d1b39fdcf4b40386648a3ef25aca8207aa","modified":1702456868348},{"_id":"source/_posts/django/rest-serializer-basics.md","hash":"0fdca3972abb49137ddcf15dca6bac2e18dde656","modified":1702456868349},{"_id":"source/assets/img/48223734b31de65181a4a38de6d8ac54.png","hash":"2d4787c10a650ac22b41e44db0bb06c9185adeeb","modified":1702456868352},{"_id":"source/assets/img/image-20231108212229095.png","hash":"f8420f6fa89d4d4b7d6dc12994a18dcf5e7510e0","modified":1702456868360},{"_id":"source/assets/img/image-20231109181130563.png","hash":"5e0f477d446ea6c218e89c66823bfae93d6e5f41","modified":1702456868362},{"_id":"source/assets/img/img_202311112240579548.png","hash":"98d0895621179d874121bb794d96dd707118d9f7","modified":1702456868364},{"_id":"source/assets/img/img_202311112248208661.png","hash":"edac1c34e4e1f32d66d1f8cb2aa80a4011a8a70e","modified":1702456868365},{"_id":"source/assets/img/img_202311112310499438.png","hash":"5fd3990798282ee76b2fa812f359d479a622e682","modified":1702456868367},{"_id":"source/assets/img/img_202311111749462365.png","hash":"95ee4208fefa787541178dcbe417b6b5dd3eb606","modified":1702456868362},{"_id":"source/assets/img/image-20231109160342949.png","hash":"771d764ba7195e3b94a3a7e16e9cfaaf3721abc7","modified":1702456868361},{"_id":"source/assets/img/img_202311131814429529.png","hash":"84a380dfa9f295cb48c4f49c8b7b683122ecd03c","modified":1702456868373},{"_id":"source/assets/img/img_202311120215571964.png","hash":"a63e75140db92f56512d78db4dbd210627773b80","modified":1702456868369},{"_id":"source/assets/img/img_202311130250548202.png","hash":"4920e3edc35df18e422db48914ea8b420d4338d5","modified":1702456868373},{"_id":"source/assets/img/img_202311131817332685.png","hash":"e8ba9d7b6a186afb295f2c03a71025e4f4959668","modified":1702456868374},{"_id":"source/assets/img/img_202311122320571347.png","hash":"4dce2d4d4a2d2e253af2c72706118836b29ff634","modified":1702456868371},{"_id":"source/assets/img/separator_1.png","hash":"c1d8909c7e7842d55d4adeb90b8da38a5b0c2b4c","modified":1702456868464},{"_id":"source/assets/img/separator_3.png","hash":"0a5aa0d16fb118c8752068b8c0ed3a1c25279827","modified":1702456868464},{"_id":"source/assets/img/separator_5.png","hash":"3cbc04b75b9ae05d04e8cfd973cdb6dd64db96ef","modified":1702456868464},{"_id":"source/_posts/design-pattern/abstract-factory-design-pattern.md","hash":"2f163c32210a2e885521b508d3ec3f8b93349748","modified":1702457038095},{"_id":"source/_posts/design-pattern/builder-design-pattern-demo.md","hash":"97db3705c2703bed06e5d15688493ef254fa1266","modified":1702457038096},{"_id":"source/_posts/design-pattern/adapter-design-pattern-demo.md","hash":"272a35872ec1eb771d031904e2908974e7236071","modified":1702457038096},{"_id":"source/_posts/design-pattern/composite-design-pattern.md","hash":"704da16dd214b2af08007626f51478c4bb6eff52","modified":1702457038097},{"_id":"source/_posts/design-pattern/design-pattern-memento.md","hash":"d9b03c1190b04732fe32e5ba5daf3aa4532987f1","modified":1702457038098},{"_id":"source/_posts/design-pattern/factory-method-design-pattern-demo.md","hash":"7f5424c08ab0e9d96ad9218945d5837f64d68714","modified":1702457038098},{"_id":"source/_posts/design-pattern/facade-design-pattern-demo.md","hash":"f5ec9386e59b077c9a94c655c6d5949054a59f8d","modified":1702457038098},{"_id":"source/_posts/design-pattern/bridge-design-pattern-demo.md","hash":"556bbddbe5e430cd62c602ff271996919a45b0cc","modified":1702457038096},{"_id":"source/_posts/design-pattern/command-design-pattern-demo.md","hash":"7e36559e848496b766acd377efb21cbcf48e65ff","modified":1702457038097},{"_id":"source/_posts/design-pattern/flyweight-design-pattern-demo.md","hash":"8ebe13cf6882e26811fdf31a4a66ed982b400b92","modified":1702457038099},{"_id":"source/_posts/design-pattern/chain-of-responsibility-design-pattern.md","hash":"b6f1afa6a2e225a5f8cd3216b6f27ebe85a1ad17","modified":1702457038097},{"_id":"source/_posts/design-pattern/iterator-design-pattern-demo.md","hash":"e320d514f24efb654d2d0498bf0293b85ea90d85","modified":1702457038099},{"_id":"source/_posts/design-pattern/prototype-design-pattern-demo.md","hash":"b9f08bbefa4e3df828b897c087bf81f1b2aaaad9","modified":1702457038100},{"_id":"source/_posts/design-pattern/singleton-design-pattern-demo.md","hash":"ff74b57451e4a47aef52b2febf446b68f7f5b4b1","modified":1702457038101},{"_id":"source/_posts/design-pattern/state-design-pattern.md","hash":"e6d18e606a1b9eeea6c853d1c92cf59518b22592","modified":1702457038101},{"_id":"source/_posts/design-pattern/decorator-design-pattern-demo.md","hash":"96ed13f549abd123aba2ebfa33a876a5e7ea4116","modified":1702457038097},{"_id":"source/_posts/design-pattern/visitor-design-pattern.md","hash":"88b7d600152c40ffd045e3e4cebe8740fd7423c4","modified":1702457038102},{"_id":"source/_posts/design-pattern/mediator-design-pattern-demo.md","hash":"e127ed2669efc59ba05a0aa6de8bbc07f987bae8","modified":1702457038099},{"_id":"source/_posts/design-pattern/proxy-design-pattern-demo.md","hash":"6167ee16ccab398e3a88c485834bccd820705e03","modified":1702457038100},{"_id":"source/_posts/design-pattern/observer-design-pattern-demo.md","hash":"80c74fc588804545431d1839d8902bbc1300afe1","modified":1702457038100},{"_id":"source/_posts/design-pattern/template-method-pattern.md","hash":"571529ccdcd3afa4633bd6434bd9b0b81736243d","modified":1702457038102},{"_id":"source/assets/img/favicons/favicon-16x16.png","hash":"ab4166e81042ed0cb31f56e4964e7d725b3a8191","modified":1702456868359},{"_id":"source/assets/img/favicons/favicon-32x32.png","hash":"ef5101d936269916cf75868eb1c7ecd39853b91c","modified":1702456868359},{"_id":"source/_posts/design-pattern/strategy-design-pattern-demo.md","hash":"7a3f2765c015dc1d7cf1cf8e1bd3d0c6a8587f90","modified":1702457038101},{"_id":"source/assets/img/favicons/site.webmanifest","hash":"93933d06a74c1a2dc3a5b90b5c01aba3e7f1fee8","modified":1702456868360},{"_id":"source/assets/img/favicons/mstile-150x150.png","hash":"49a118170ecd009bc298037b7c7b5bcfe3e7f085","modified":1702456868360},{"_id":"source/assets/img/favicons/browserconfig.xml","hash":"dc5a8f280913e401151ddeb621df1904c1cda374","modified":1702456868357},{"_id":"source/assets/img/favicons/safari-pinned-tab.svg","hash":"239cf2ebb0de15883cb569676afc8ed45ca9cf06","modified":1702456868360},{"_id":"source/assets/img/img_202311112225443281.png","hash":"7972335e6f5bb9ccccc7e4d080d40aa35684d3ed","modified":1702456868363},{"_id":"source/assets/img/img_202311130227323161.png","hash":"529016082766dff494c7075280040e42aea39768","modified":1702456868372},{"_id":"source/assets/img/img_202311131941497659.png","hash":"527f29678b30db22e259fda4dfc930bb72830196","modified":1702456868375},{"_id":"source/assets/img/img_202311162146456205.png","hash":"ffb8ffb1a13458b33b375e3988b9474fa43681c3","modified":1702456868386},{"_id":"themes/hexo-theme-Claudia/.gitignore","hash":"bd20d54c57507594cd16a21021c3600f9311a1f5","modified":1702456868474},{"_id":"themes/hexo-theme-Claudia/CONTRIBUTING.md","hash":"618215987cc9a774c37cc70efa1cb8545457a49c","modified":1702456868475},{"_id":"themes/hexo-theme-Claudia/CODE_OF_CONDUCT.md","hash":"787b987cd6079f93c7846b69c3b4dfa41cb3ac03","modified":1702456868475},{"_id":"source/assets/img/img_202311241307079570.png","hash":"959ee76c9fee92ffa8ce4852aa7c0818eaf63ba9","modified":1702456868421},{"_id":"themes/hexo-theme-Claudia/package.json","hash":"c59cb2089c51ed56deb2df69171d7adc63c1148f","modified":1702456868480},{"_id":"themes/hexo-theme-Claudia/_config.yml","hash":"5948396a690a283c78d365a5183acdf107e6fe6b","modified":1702456868476},{"_id":"themes/hexo-theme-Claudia/README.md","hash":"c6f8d7e06f79a64d18aeee6592dd44abe097cf77","modified":1702456868475},{"_id":"themes/hexo-theme-Claudia/README-CN.md","hash":"4688e3f1046585e3d7ae79f63104ed301864a240","modified":1702456868475},{"_id":"themes/hexo-theme-Claudia/CHANGELOG.md","hash":"59b1995c016ad26343409f7ddff9f5feb75038e2","modified":1702456868474},{"_id":"themes/hexo-theme-Claudia/.github/FUNDING.yml","hash":"dd672081ec4678929f6c1ac3ebbef4d990291ecd","modified":1702456868474},{"_id":"themes/hexo-theme-Claudia/LICENSE","hash":"9812afb9d0aa8596067b6fd30cf6089345b7b678","modified":1702456868475},{"_id":"themes/hexo-theme-Claudia/.github/PULL_REQUEST_TEMPLATE.md","hash":"35751990a36fffe5a5f6fd682452fe5594cadde9","modified":1702456868474},{"_id":"themes/hexo-theme-Claudia/languages/zh-CN.yml","hash":"dfaa6ca86d6dc041616f09e5e0b16221bdf7e122","modified":1702456868477},{"_id":"themes/hexo-theme-Claudia/languages/en.yml","hash":"66d680dcaaa2374c8a400c7266e48a4f662a9035","modified":1702456868477},{"_id":"themes/hexo-theme-Claudia/layout/about.pug","hash":"98dea176f76053d5deaf35ed25518d218d70be7d","modified":1702456868478},{"_id":"themes/hexo-theme-Claudia/layout/archive.pug","hash":"68c709495bc39a659d9c4b19216714a5ac2b5579","modified":1702456868478},{"_id":"themes/hexo-theme-Claudia/layout/page.pug","hash":"6c5db904a03adb4794b7ada222389da12d395bc7","modified":1702456868478},{"_id":"themes/hexo-theme-Claudia/layout/index.pug","hash":"96b3b857b19b62823f84a164d20293cc16d891aa","modified":1702456868478},{"_id":"themes/hexo-theme-Claudia/layout/tag.pug","hash":"16dac6e0a6ef939ceb6adb21dfbe0276538ff269","modified":1702456868479},{"_id":"themes/hexo-theme-Claudia/layout/post.pug","hash":"ebbb41aa73d3c702b983cfe740261b5b366d1145","modified":1702456868478},{"_id":"themes/hexo-theme-Claudia/layout/category.pug","hash":"2147f3d66640bc6604c9b15325a480d196a4df3d","modified":1702456868478},{"_id":"themes/hexo-theme-Claudia/.github/ISSUE_TEMPLATE/bug_report.md","hash":"b38365fec9b6cac6bbb75441082f041c4efd35bf","modified":1702456868474},{"_id":"themes/hexo-theme-Claudia/layout/widget/methods.pug","hash":"fa62f6ad95d1a4cda5038595d19d4d11b4b39e17","modified":1702456868479},{"_id":"themes/hexo-theme-Claudia/layout/widget/base.pug","hash":"21a5eab68859adedc9997581fc54e848693c17d4","modified":1702456868479},{"_id":"themes/hexo-theme-Claudia/.github/ISSUE_TEMPLATE/feature_request.md","hash":"9d8447814c3ac93d7fbd336015e7ef80c4a32831","modified":1702456868474},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-archives.pug","hash":"e6bcf8b09a5e06119baf3f97f7798ef7600ab65c","modified":1702456868479},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-categories.pug","hash":"ea3bcd5f5fb06e26d8b67f30f224e7c129672980","modified":1702456868479},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-profile.pug","hash":"fbe18f3dd5e8d2850f8e6510da4fbd499d5096f0","modified":1702456868480},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-post-list.pug","hash":"f034a4b8231f7933d06e364671b11847c74b9a5c","modified":1702456868480},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-sns.pug","hash":"8ec154d321b36a5f3bf5974c75668b45ec660c1d","modified":1702456868480},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-search.pug","hash":"c17612dd4ae2d439d757818ec0e4215d71dd9ad5","modified":1702456868480},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-header.pug","hash":"5e9b2035b31372c2bb11db6efe0e36b7df64d884","modified":1702456868479},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-tag.pug","hash":"714a05148758e1e3cc12635c875cb6ef1753c6ab","modified":1702456868480},{"_id":"themes/hexo-theme-Claudia/layout/widget/widget-recent.pug","hash":"7512dceae690ea219d562a6e450d633e29916072","modified":1702456868480},{"_id":"themes/hexo-theme-Claudia/source/js/img_zoom.js","hash":"a384c3a60fcbdad813cb8340200dfb07ebbcc48c","modified":1702456868493},{"_id":"themes/hexo-theme-Claudia/source/js/common.js","hash":"7f62c8c148ee0b528a2bea47b248b2a7f5501142","modified":1702456868492},{"_id":"themes/hexo-theme-Claudia/source/style/base.scss","hash":"da7457c952b6b433f273d7ecc562d24dcd4aa431","modified":1702456868497},{"_id":"themes/hexo-theme-Claudia/source/images/favicon.ico","hash":"61a79c50c00742fe80341f373917ef55425b92ee","modified":1702456868490},{"_id":"themes/hexo-theme-Claudia/source/style/about.scss","hash":"4a1beebb317c598b11fc4815e70b07bbb6d2aed7","modified":1702456868497},{"_id":"themes/hexo-theme-Claudia/source/js/post.js","hash":"04edd583f103ba444d8174d55e7f45e27b8f2549","modified":1702456868496},{"_id":"themes/hexo-theme-Claudia/source/style/archive.scss","hash":"cd1dc16dfa7c482cc88ddabaf8c9a459299a98cf","modified":1702456868497},{"_id":"themes/hexo-theme-Claudia/source/style/post.scss","hash":"8a3520a0ceb22a2fde35b09485e2df6dd5a23b6f","modified":1702456868499},{"_id":"themes/hexo-theme-Claudia/source/style/widget-header.scss","hash":"18782c2ab206abbeb0ee59632864251acfd20d85","modified":1702456868500},{"_id":"themes/hexo-theme-Claudia/source/style/common/helper.scss","hash":"7cd0982fe839e760523f8f85ea6f06f2b5d2111a","modified":1702456868498},{"_id":"themes/hexo-theme-Claudia/source/style/themes/default-dark.scss","hash":"0cbdc5738503f55e5b84e1bd00e445c98c7d56d2","modified":1702456868499},{"_id":"themes/hexo-theme-Claudia/source/style/common/variable.scss","hash":"fffe6eacfa4d814626a1e1d84dc651233eded060","modified":1702456868499},{"_id":"themes/hexo-theme-Claudia/source/style/widget-post-list.scss","hash":"53ea5dc4fb868f3553a5c117e528082ba3c7961c","modified":1702456868500},{"_id":"themes/hexo-theme-Claudia/source/style/themes/theme.scss","hash":"caf7517c9200bbf7152a7f5edba4298fbf9ae629","modified":1702456868500},{"_id":"themes/hexo-theme-Claudia/source/style/themes/highlight-theme-light.css","hash":"f7b19080f00e10723bc86e6819fc25143a0137c5","modified":1702456868499},{"_id":"themes/hexo-theme-Claudia/source/style/themes/default-light.scss","hash":"23e7c1f87e252db80d34d36a2129e98dde7b1b55","modified":1702456868499},{"_id":"themes/hexo-theme-Claudia/source/style/common/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1702456868499},{"_id":"source/assets/img/favicons/android-chrome-192x192.png","hash":"498f37c544ee77e948e63168438d1b1840d07701","modified":1702456868353},{"_id":"source/assets/img/img_202311121735237199.png","hash":"968b47752dc846980353de12d5416d0af8e49256","modified":1702456868371},{"_id":"source/assets/img/favicons/apple-touch-icon.png","hash":"888f7f1228e06b8c87c0a0c45414d4cadbfa50fb","modified":1702456868357},{"_id":"source/assets/img/img_202311241434531606.png","hash":"1a0d0bfc73a882fe6a2db1fa273a4c01ce801ff9","modified":1702456868423},{"_id":"source/assets/img/img_202311230930147088.png","hash":"02e68926d489e7f4af9624ac51db59ef9f8409a0","modified":1702456868420},{"_id":"themes/hexo-theme-Claudia/img.png","hash":"2239d04aa7d31850b024d3ccac609fbf9dcb98d2","modified":1702456868477},{"_id":"themes/hexo-theme-Claudia/source/js/jquery-3.6.1.min.js","hash":"0fa72756e48c33a6feeace1ffa5d790d58b53729","modified":1702456868496},{"_id":"themes/hexo-theme-Claudia/source/js/jquery-fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1702456868496},{"_id":"themes/hexo-theme-Claudia/source/js/highlight.pack.js","hash":"2ef9bbbc688ce413686ce0eb64d0b25af4ea34e2","modified":1702456868493},{"_id":"source/assets/img/img_202311120105246528.png","hash":"389176b316c47883ad8806286128bb8357952f7b","modified":1702456868369},{"_id":"source/assets/img/img_202311180514299621.png","hash":"ae2062aa8002eab68cbbc1c3ddb653a54659cf53","modified":1702456868403},{"_id":"themes/hexo-theme-Claudia/screenshot/BuyMeCoffeeQRCode.png","hash":"df14bf998f23f9e8a323e2d79802e887875c8842","modified":1702456868482},{"_id":"themes/hexo-theme-Claudia/source/style/common/bulma.css","hash":"7ede761951c6f274850a1038416559a8f648c493","modified":1702456868498},{"_id":"source/assets/img/img_202311141520211655.png","hash":"08fe8e28942b04b036f6db7c1b1d1f27f527c16b","modified":1702456868376},{"_id":"source/assets/img/img_202311182234203649.png","hash":"68a745ab7885a4daf2d8b8f047aed9cbdbec95d5","modified":1702456868408},{"_id":"source/assets/img/img_202311141802036688.png","hash":"2ff042644344998baa70b505233750d84f01bd2e","modified":1702456868378},{"_id":"source/assets/img/img_202311180006318654.png","hash":"c1ca47719d4cdf1f7ba794bffcbc4c66aebd61d0","modified":1702456868397},{"_id":"source/assets/img/img_202311180516007386.png","hash":"6b38eb1747aa3c0597e1bb26bef01e166f11a7b7","modified":1702456868406},{"_id":"source/assets/img/favicons/android-chrome-512x512.png","hash":"bad22b7ecb65ede119847fcbf58b165c4eb89899","modified":1702456868355},{"_id":"themes/hexo-theme-Claudia/screenshot/claudia-cover.png","hash":"757680cd3648e3569d6a18abaf33180dc427d620","modified":1702456868488},{"_id":"source/assets/img/img_202311180103427767.png","hash":"97201f782483bc644dc6e8790b11cc300b159302","modified":1702456868401},{"_id":"source/assets/img/img_202311212007505770.png","hash":"b01942694a01338e144f600995fe234e7ecaa8c4","modified":1702456868418},{"_id":"themes/hexo-theme-Claudia/source/images/avatar.png","hash":"3b11ffb03bcf4eefd3b850bc2dafe48a8774e65b","modified":1702456868490},{"_id":"source/assets/img/img_202311151738162426.png","hash":"be80514cb9094e7b12703bc9ac756783e5047e71","modified":1702456868381},{"_id":"source/assets/img/img_202311152245318150.png","hash":"4592c0db59a66cce6d502f604e1372e418ff2abd","modified":1702456868384},{"_id":"themes/hexo-theme-Claudia/screenshot/claudia-cover-v2.png","hash":"f477d90d327a638a46b3caa172332e931955a532","modified":1702456868485},{"_id":"source/assets/img/img_202311170358241255.png","hash":"90771a60b647dc4a2cc2325ef9fef9b82f5e9ba6","modified":1702456868392},{"_id":"source/assets/img/img_202311211957171241.png","hash":"e7a30b7a37b839552ce1999389cf57550da4ee01","modified":1702456868412},{"_id":"source/assets/img/lucy.png","hash":"273c80fb6031a8dbc7551d045e28fcffbb5c68ca","modified":1702456868463},{"_id":"public/atom.xml","hash":"35bb5a06840bbdf0e5b2c355c2457766ac7bf281","modified":1702457898233},{"_id":"public/search.xml","hash":"7720ee09a398a963561bdadf55159a95a0458711","modified":1702457898233},{"_id":"public/2023/12-13/others-set-gem-sources/index.html","hash":"4975dfadee434f74eb820dd937e43db2c91e0f03","modified":1702457898233},{"_id":"public/2023/12-13/others-pylint-django-vscode-no-member-in-models/index.html","hash":"5bf62290680af7f61b21dd82acf2283e7b757550","modified":1702457898233},{"_id":"public/2023/12-13/others-runtime-error-failed-to-lock-pipfile/index.html","hash":"c39443e7d1502c39fca997eb996c63b22748e7f3","modified":1702457898233},{"_id":"public/2023/12-13/others-jekyll-chirpy-gitee/index.html","hash":"4abce73e5fee67a19ad6094323e129e727cf7e17","modified":1702457898233},{"_id":"public/2023/12-13/django-rest-serializer-basics/index.html","hash":"7c94a71a8686e0065f7a1f2d80b0e3675687ef4d","modified":1702457898233},{"_id":"public/2023/12-13/django-rest-model-serializer/index.html","hash":"60014e6bab6ac96e8d03128de1590ec7ce864c54","modified":1702457898233},{"_id":"public/2023/12-13/django-rest-deserializing/index.html","hash":"83c73ee75fe24a771239a89aaed3c9379ba88e40","modified":1702457898233},{"_id":"public/2023/12-13/django-8-basic-data-validation/index.html","hash":"ca31daf3109df026f46c360393b1750b9e380813","modified":1702457898233},{"_id":"public/2023/12-13/others-jekyll-quickstart/index.html","hash":"3efe10654907782602804f8bd080f1e6fd4818be","modified":1702457898233},{"_id":"public/2023/12-13/django-9-extending-pluggable-apps/index.html","hash":"42dc8f73cc56df2e5e57fc7c6a5e9e611772222f","modified":1702457898233},{"_id":"public/2023/12-13/django-admin-cli/index.html","hash":"4ebcf92e2c98b051584064496a8b8aae8a24dfb2","modified":1702457898233},{"_id":"public/2023/12-13/django-basic-config/index.html","hash":"557c0c802968ebafce02442468ce88b1e45ac710","modified":1702457898233},{"_id":"public/2023/12-13/django-5-use-django-admin/index.html","hash":"b00142a39b2ee098e35e0f8e7916bcfe8770252e","modified":1702457898233},{"_id":"public/2023/12-13/django-6-generic-relationships/index.html","hash":"6c464115eccd6a287f41b22f095eb972bb8b549e","modified":1702457898233},{"_id":"public/2023/12-13/django-4-use-django-orm/index.html","hash":"1d6decc1777255576d3bef60a100357e532334be","modified":1702457898233},{"_id":"public/2023/12-13/django-7-custom-model-manager/index.html","hash":"f12f5152b77ae924fab0185a4c5b348fa6d0b5b9","modified":1702457898233},{"_id":"public/2023/12-13/django-1-first-django-project/index.html","hash":"d6154027740589db02827ff303457e15f2491ea5","modified":1702457898233},{"_id":"public/2023/12-13/django-10-using-restful-api-in-django/index.html","hash":"c9364c04a8365359db21fb5234e9006bdc171778","modified":1702457898233},{"_id":"public/2023/12-13/django-2-creating-models/index.html","hash":"50b9df00cd769197fbc024cc29f743927366e43e","modified":1702457898233},{"_id":"public/2023/12-13/django-3-using-mysql/index.html","hash":"e9a5ab591ae6e0b23c953057e98fe6c1c21863ec","modified":1702457898233},{"_id":"public/2023/11-25/design-pattern-builder-design-pattern-demo/index.html","hash":"f8984f89e9515d29744c9ceda49b8e3322c3d46b","modified":1702457898233},{"_id":"public/2023/11-25/design-pattern-abstract-factory-design-pattern/index.html","hash":"6ef0aaf70bfa3c622eb677b3f715d69ad3df519d","modified":1702457898233},{"_id":"public/2023/11-24/design-pattern-factory-method-design-pattern-demo/index.html","hash":"af590d51ecc2eed4aee709d31a73e890ec00d802","modified":1702457898233},{"_id":"public/2023/11-24/design-pattern-proxy-design-pattern-demo/index.html","hash":"ea99f1059a02fbb097a5ec97cb0d37dd9e8191bc","modified":1702457898233},{"_id":"public/2023/11-24/design-pattern-singleton-design-pattern-demo/index.html","hash":"ff4b85425a3e469c570d9c42e4fb7d7b16680702","modified":1702457898233},{"_id":"public/2023/11-23/design-pattern-bridge-design-pattern-demo/index.html","hash":"de03df3a5b04c6e8615a32f09d6e6061b8f53cef","modified":1702457898233},{"_id":"public/2023/11-24/design-pattern-prototype-design-pattern-demo/index.html","hash":"3226234d92cc23574cca8b68e7b93ef5335318a1","modified":1702457898233},{"_id":"public/2023/11-23/design-pattern-flyweight-design-pattern-demo/index.html","hash":"4397ce4b5643c8b088e2ad2bb9fc6943fba15dde","modified":1702457898233},{"_id":"public/2023/11-23/design-pattern-facade-design-pattern-demo/index.html","hash":"a55c9843cfccdc7ba182470de8875b837e800a85","modified":1702457898233},{"_id":"public/2023/11-22/design-pattern-decorator-design-pattern-demo/index.html","hash":"9d04674796dd11fe77b9f8b85ed278b671b7a529","modified":1702457898233},{"_id":"public/2023/11-22/design-pattern-adapter-design-pattern-demo/index.html","hash":"7c943a54dcc57089c1a865477b092ddadae5ef43","modified":1702457898233},{"_id":"public/2023/11-21/design-pattern-chain-of-responsibility-design-pattern/index.html","hash":"f22237fc9847bf8cf387910bad97f409932dff2c","modified":1702457898233},{"_id":"public/2023/11-21/design-pattern-iterator-design-pattern-demo/index.html","hash":"f5bf6b827dc1f73e60168d4fe656f087d99f6ddb","modified":1702457898233},{"_id":"public/2023/11-21/design-pattern-visitor-design-pattern/index.html","hash":"8b78578a84baa4c7ab738ccaf733c6b625101272","modified":1702457898233},{"_id":"public/2023/11-21/design-pattern-mediator-design-pattern-demo/index.html","hash":"dc52df7bfe5d6500a9615b6b6791ba2bc27171ef","modified":1702457898233},{"_id":"public/2023/11-21/design-pattern-composite-design-pattern/index.html","hash":"84bdc19edefb4582d4349286cf2e4606a9ae7b15","modified":1702457898233},{"_id":"public/2023/11-20/design-pattern-observer-design-pattern-demo/index.html","hash":"f06c21a2f16bef612c27b9eff1ac699b48f6fa3a","modified":1702457898233},{"_id":"public/2023/11-20/design-pattern-template-method-pattern/index.html","hash":"087d235eb2c9ca5fb02c2809fe15ea24f7698455","modified":1702457898233},{"_id":"public/2023/11-20/design-pattern-strategy-design-pattern-demo/index.html","hash":"1fbea10180a7943d39bb376e72c412fd619dc1c9","modified":1702457898233},{"_id":"public/2023/11-20/design-pattern-state-design-pattern/index.html","hash":"b2f21aac9c5ddaf30bc4ba30ba5735329fb739a9","modified":1702457898233},{"_id":"public/2023/11-19/design-pattern-design-pattern-memento/index.html","hash":"b7f353d50a73ec0dd9161cbe49fedca99049a7b0","modified":1702457898233},{"_id":"public/2023/11-20/design-pattern-command-design-pattern-demo/index.html","hash":"ec68cc5fb4f692450643a4e9dd5ac1aa95b73c2d","modified":1702457898233},{"_id":"public/2023/11-19/others-pylint-config-in-vscode/index.html","hash":"fe5c3e53a4b068adc309d7f1e49f4bfbe694de19","modified":1702457898233},{"_id":"public/2023/11-17/others-custom-oh-my-zsh-theme/index.html","hash":"eb9928e48cb82fb6c46dcba20713ccbf356963ed","modified":1702457898233},{"_id":"public/2023/11-17/others-git-note/index.html","hash":"5bb8ab1b3208e6af2c6a0a27826f6bb5f6fa844b","modified":1702457898233},{"_id":"public/2023/11-16/others-linux-basic-commands/index.html","hash":"620aae6a52deb83a7efbfae1c46a5e8d86297852","modified":1702457898233},{"_id":"public/2023/11-15/others-docker-notes/index.html","hash":"993e35d2ae4aa19e372d59057e29795fad50fbdf","modified":1702457898233},{"_id":"public/2023/11-15/others-note-for-learn-mysql/index.html","hash":"88ab265e2ba4495fbecb21d441811b12c626d664","modified":1702457898233},{"_id":"public/2023/11-13/django-rest-filters-search-ordering-pagination/index.html","hash":"070019ea1f9e8024d6024cdb04781d4899b77033","modified":1702457898233},{"_id":"public/2023/11-14/others-python-valuable-opensource-libraries-collection/index.html","hash":"f8b75820c28f1a52ea9669c6ec533ffdbf03b386","modified":1702457898233},{"_id":"public/2023/11-13/django-rest-drf-nested-router/index.html","hash":"ccce9c03f04cbdd32d6004d28fa6288f23dd8619","modified":1702457898233},{"_id":"public/2023/11-13/django-rest-view-set-and-router/index.html","hash":"4257efbb8802ebc25519c194b7bbc0f18a268938","modified":1702457898233},{"_id":"public/2023/11-13/django-rest-custom-generic-view/index.html","hash":"dc8b90532c252eaf5cffc758bdbefaa92b588d6c","modified":1702457898233},{"_id":"public/2023/11-12/django-rest-generic-view/index.html","hash":"aae86e14d48e3014db9264e0cf48510775054887","modified":1702457898233},{"_id":"public/2023/11-12/django-rest-apiview/index.html","hash":"05ded7afcd82387863c014e404545f3ac718e6b5","modified":1702457898233},{"_id":"public/2023/11-12/django-rest-save-update-delete/index.html","hash":"6c45dc640149953ea1d609281986dcdc0c0ea7b3","modified":1702457898233},{"_id":"public/archives/index.html","hash":"9f9e7609788335dac569a588ea748d0f6bae9775","modified":1702457898233},{"_id":"public/archives/page/2/index.html","hash":"481c6b3c58ae12ce0282c9d84f2e1fef3c50648b","modified":1702457898233},{"_id":"public/archives/page/3/index.html","hash":"f1d7487d2ed1c9f9de8f78854b8960d7f0e8ea78","modified":1702457898233},{"_id":"public/archives/page/4/index.html","hash":"a81a352c53b0bbf69c431d2f2335da7c6c96a8a5","modified":1702457898233},{"_id":"public/archives/page/5/index.html","hash":"6e613a22870426740c2089cfd752f98221439257","modified":1702457898233},{"_id":"public/archives/page/6/index.html","hash":"d1438c853eb8a8557ee625ba47bf5ac2f5d03940","modified":1702457898233},{"_id":"public/archives/2023/index.html","hash":"47f42f1104ba5abede7a43bf03b19e0f42b40bbd","modified":1702457898233},{"_id":"public/archives/2023/page/2/index.html","hash":"e79bda14f7c1aa2b1ba1ae226dc69162a0a239b8","modified":1702457898233},{"_id":"public/archives/2023/page/3/index.html","hash":"c2926d6f2a16cc1280d99dec5a30562c33fbd526","modified":1702457898233},{"_id":"public/archives/2023/page/4/index.html","hash":"6a654a8339a1a3e748e707ba7de4873512118e65","modified":1702457898233},{"_id":"public/archives/2023/page/5/index.html","hash":"c18cd01bd3c82033c3bed8ecb762abb874e1a053","modified":1702457898233},{"_id":"public/archives/2023/11/index.html","hash":"e2e58e20ba48a4d17ddad7c70e56a6942ea184cb","modified":1702457898233},{"_id":"public/archives/2023/page/6/index.html","hash":"41bfd58e8f0bac262822c056bd7e5191faa0a534","modified":1702457898233},{"_id":"public/archives/2023/11/page/2/index.html","hash":"9ea5b67c1974f1b98a5c2424d12dd053a371a533","modified":1702457898233},{"_id":"public/archives/2023/11/page/3/index.html","hash":"b03ddedcad85d91119255b252227bbfb4c6f9e81","modified":1702457898233},{"_id":"public/archives/2023/11/page/4/index.html","hash":"4c60c14bb3c5bdce341380d403d472168dfafad9","modified":1702457898233},{"_id":"public/archives/2023/12/index.html","hash":"4867edf0cc7c6bbedd7054670136db517ffc1606","modified":1702457898233},{"_id":"public/archives/2023/12/page/2/index.html","hash":"f74a22bd71a3875b42ec09075c2e15146e7ab559","modified":1702457898233},{"_id":"public/categories/笔记/index.html","hash":"ca060607b17bcea32580b170360b3f4d693951dc","modified":1702457898233},{"_id":"public/categories/笔记/page/2/index.html","hash":"215e3373205034dbe29849209dda6f07e992e787","modified":1702457898233},{"_id":"public/categories/笔记/page/3/index.html","hash":"c3e7e78ae104bb0f8d4f16a7145e6df19c2c7b3c","modified":1702457898233},{"_id":"public/categories/笔记/page/5/index.html","hash":"3c9f981fc5346c2cc0e8d430f9b8f8c31c0b6f31","modified":1702457898233},{"_id":"public/categories/笔记/page/4/index.html","hash":"bab791d861c8d743879c0a051c00a3a0d88bb07e","modified":1702457898233},{"_id":"public/categories/笔记/杂项/index.html","hash":"4cab3f76d940474a9d8697faab9cec491b7507e7","modified":1702457898233},{"_id":"public/categories/笔记/docker/index.html","hash":"5a6abf6abb1303562e824a04b2fa363ec177f264","modified":1702457898233},{"_id":"public/categories/笔记/Docker/index.html","hash":"10a7b6d34a1d3b1c53b33c1e06b97197ec8574d0","modified":1702457898233},{"_id":"public/categories/速查/index.html","hash":"7b16f490d015d0010d7a1273bf644a931c9d188a","modified":1702457898233},{"_id":"public/categories/笔记/git/index.html","hash":"42b25149fae247c54235ecf83ebf5c827ba84f1a","modified":1702457898233},{"_id":"public/categories/笔记/jekyll/index.html","hash":"0d000786fce3b69c0e00798243c1329ff343cbf0","modified":1702457898233},{"_id":"public/categories/笔记/数据库/index.html","hash":"3d6a4785888367ed99ee4ebc789879207dc3f52c","modified":1702457898233},{"_id":"public/categories/笔记/Django/index.html","hash":"11c7c570d3e98959a92d194c8864fab4ae7a9ba8","modified":1702457898233},{"_id":"public/categories/笔记/Django/page/2/index.html","hash":"967764b50cfe6bc1cfdd9aacdd72c68a6f5a790d","modified":1702457898233},{"_id":"public/categories/速查/配置/index.html","hash":"e871f8cbd0febcbb645d99ad79150f85180468ad","modified":1702457898233},{"_id":"public/categories/速查/异常/index.html","hash":"7437e280d27b1ba01e24683a45566baf81aa73ea","modified":1702457898233},{"_id":"public/categories/速查/工具/index.html","hash":"14dce50938558fdfdcb331953dfcfb68d6a22d72","modified":1702457898233},{"_id":"public/categories/笔记/设计模式/page/2/index.html","hash":"e8518824c6bc70a355f4e52bce37a8981c5289f7","modified":1702457898233},{"_id":"public/categories/笔记/设计模式/index.html","hash":"0cda811f44e70dabf47eb627bb38c333a039b7f8","modified":1702457898233},{"_id":"public/categories/笔记/设计模式/page/3/index.html","hash":"da7197f2da90b41618c4aacc3173ef2cdac63340","modified":1702457898233},{"_id":"public/index.html","hash":"2f0c4fc552c0fbea3a101243cd3831880c0d89dc","modified":1702457898233},{"_id":"public/page/2/index.html","hash":"d75730d53e7ee18225be4a2a08b5b31640752cea","modified":1702457898233},{"_id":"public/page/3/index.html","hash":"03f470f259c4e7ae2f152c1daa98b3a3feb2316f","modified":1702457898233},{"_id":"public/page/4/index.html","hash":"4575d658c2eabe66610dff6bc22e3c2632def856","modified":1702457898233},{"_id":"public/page/5/index.html","hash":"10f3aedf4cb14ac6e9884b1d9aee4729fa3c3554","modified":1702457898233},{"_id":"public/page/6/index.html","hash":"6e2ed43fe1a9540ab0eb8f1e8c6cbf9fbf320d4d","modified":1702457898233},{"_id":"public/tags/zsh/index.html","hash":"bcfc0f5bf7778a33808ef46ccf29a5c50270384c","modified":1702457898233},{"_id":"public/tags/theme/index.html","hash":"104193555e21754f59166437e920ac067cb23ef1","modified":1702457898233},{"_id":"public/tags/git/index.html","hash":"3e00781a164c25054da2c28887d579f7a4b54997","modified":1702457898233},{"_id":"public/tags/⭐️/index.html","hash":"ad8f84b186f7693ed6a97122b9f5f9788997c49b","modified":1702457898233},{"_id":"public/tags/jekyll/index.html","hash":"4df90f5fd6a57a26356a8e3bca0530c2421f1492","modified":1702457898233},{"_id":"public/tags/gitee/index.html","hash":"f26ef96ac081a7bc81d0b91b25c842b75fd594de","modified":1702457898233},{"_id":"public/tags/shell/index.html","hash":"5be25398dd5294a0849332608aa84384183bf0a8","modified":1702457898233},{"_id":"public/tags/python/index.html","hash":"4cac7dda716010132f58b9ef3274fd67916bec8e","modified":1702457898233},{"_id":"public/tags/pylint/index.html","hash":"d2b3be837e4d9020153ffecd5c4ed56f54d06906","modified":1702457898233},{"_id":"public/tags/python/page/2/index.html","hash":"7a1507c9d9a220edcdb98b6a1b7133ee85816545","modified":1702457898233},{"_id":"public/tags/python/page/3/index.html","hash":"b5b4704e9c3a4855c46d30e2b915ead692f42cbe","modified":1702457898233},{"_id":"public/tags/django/index.html","hash":"2d7453c24348c6855a5dba8ae8b6d28e6735e4fb","modified":1702457898233},{"_id":"public/tags/linux/index.html","hash":"93a57c1bbf76c7293366506d596b19fa6cf687b8","modified":1702457898233},{"_id":"public/tags/docker/index.html","hash":"4808d69880051b63b36bbe2c4c7816c0a1b7b9df","modified":1702457898233},{"_id":"public/tags/django/page/2/index.html","hash":"d3dc874702853da35e50a97f20b3f871912ccba0","modified":1702457898233},{"_id":"public/tags/django/page/3/index.html","hash":"1116a5e7f861b2b8d373f0516d82e61ffe23054a","modified":1702457898233},{"_id":"public/tags/vscode/index.html","hash":"df274a163ddb57f41021d98ae79fc6956c5ca556","modified":1702457898233},{"_id":"public/tags/Database/index.html","hash":"b21484d760796bd512ed969ff027a078e220df10","modified":1702457898233},{"_id":"public/tags/MySQL/index.html","hash":"031bb80a67cfa4e046a17da64a9b8dc5be4c6440","modified":1702457898233},{"_id":"public/tags/pip/index.html","hash":"aa0d4ad519448053929e193c9fb2d306aa4237d9","modified":1702457898233},{"_id":"public/tags/pipenv/index.html","hash":"38910a1d4bc03fb5eaf41d0d26e9715614d37581","modified":1702457898233},{"_id":"public/tags/mysql/index.html","hash":"c34300905086093588a703a0cd99ccceb37a4a08","modified":1702457898233},{"_id":"public/tags/exception/index.html","hash":"b125aa8bd6b8f3d198801bb54941d1aa020896b3","modified":1702457898233},{"_id":"public/tags/opensource/index.html","hash":"5739be47c672ca27847ed76586aceb4b4af8e311","modified":1702457898233},{"_id":"public/tags/backend/index.html","hash":"ee96e67b5f18831dfa119d8b8176c946a03f01d0","modified":1702457898233},{"_id":"public/tags/backend/page/2/index.html","hash":"4b48ebbc574cc8dbd5ede883b708e7bd1aa03f26","modified":1702457898233},{"_id":"public/tags/REST/index.html","hash":"a83a96602ab5d3429f4fda978e1d21022a1f4c3d","modified":1702457898233},{"_id":"public/tags/gem/index.html","hash":"fc414386ed924fc116bc66000512150e15507a34","modified":1702457898233},{"_id":"public/tags/config/index.html","hash":"f6a5fe61096a461619dee893823523bf91145c77","modified":1702457898233},{"_id":"public/tags/design-pattern/index.html","hash":"83a53fb36960d2d36690684f3460289ba7745cc0","modified":1702457898233},{"_id":"public/tags/design-pattern/page/2/index.html","hash":"797b4617dda623bba3a9acab09739fc954d0cef4","modified":1702457898233},{"_id":"public/tags/design-pattern/page/3/index.html","hash":"5c00c1124fe88ededbb3be91edb268220b522ea3","modified":1702457898233},{"_id":"public/CNAME","hash":"d10bc9c6b0779d3be61bb762db25fc53a9939d37","modified":1702457898233},{"_id":"public/presentations/index.html","hash":"f87884e9d729c62a334a3c5260d358942067172b","modified":1702457898233},{"_id":"public/assets/img/48223734b31de65181a4a38de6d8ac54.png","hash":"2d4787c10a650ac22b41e44db0bb06c9185adeeb","modified":1702457898233},{"_id":"public/assets/img/image-20231108212229095.png","hash":"f8420f6fa89d4d4b7d6dc12994a18dcf5e7510e0","modified":1702457898233},{"_id":"public/assets/img/image-20231109160342949.png","hash":"771d764ba7195e3b94a3a7e16e9cfaaf3721abc7","modified":1702457898233},{"_id":"public/assets/img/image-20231109181130563.png","hash":"5e0f477d446ea6c218e89c66823bfae93d6e5f41","modified":1702457898233},{"_id":"public/assets/img/img_202311112240579548.png","hash":"98d0895621179d874121bb794d96dd707118d9f7","modified":1702457898233},{"_id":"public/assets/img/img_202311112248208661.png","hash":"edac1c34e4e1f32d66d1f8cb2aa80a4011a8a70e","modified":1702457898233},{"_id":"public/assets/img/img_202311111749462365.png","hash":"95ee4208fefa787541178dcbe417b6b5dd3eb606","modified":1702457898233},{"_id":"public/images/favicon.ico","hash":"61a79c50c00742fe80341f373917ef55425b92ee","modified":1702457898233},{"_id":"public/assets/img/img_202311120215571964.png","hash":"a63e75140db92f56512d78db4dbd210627773b80","modified":1702457898233},{"_id":"public/assets/img/img_202311112310499438.png","hash":"5fd3990798282ee76b2fa812f359d479a622e682","modified":1702457898233},{"_id":"public/assets/img/img_202311131814429529.png","hash":"84a380dfa9f295cb48c4f49c8b7b683122ecd03c","modified":1702457898233},{"_id":"public/assets/img/img_202311131817332685.png","hash":"e8ba9d7b6a186afb295f2c03a71025e4f4959668","modified":1702457898233},{"_id":"public/assets/img/img_202311130250548202.png","hash":"4920e3edc35df18e422db48914ea8b420d4338d5","modified":1702457898233},{"_id":"public/assets/img/img_202311122320571347.png","hash":"4dce2d4d4a2d2e253af2c72706118836b29ff634","modified":1702457898233},{"_id":"public/assets/img/separator_1.png","hash":"c1d8909c7e7842d55d4adeb90b8da38a5b0c2b4c","modified":1702457898233},{"_id":"public/assets/img/separator_3.png","hash":"0a5aa0d16fb118c8752068b8c0ed3a1c25279827","modified":1702457898233},{"_id":"public/assets/img/separator_5.png","hash":"3cbc04b75b9ae05d04e8cfd973cdb6dd64db96ef","modified":1702457898233},{"_id":"public/assets/img/favicons/browserconfig.xml","hash":"dc5a8f280913e401151ddeb621df1904c1cda374","modified":1702457898233},{"_id":"public/assets/img/favicons/mstile-150x150.png","hash":"49a118170ecd009bc298037b7c7b5bcfe3e7f085","modified":1702457898233},{"_id":"public/assets/img/favicons/favicon-32x32.png","hash":"ef5101d936269916cf75868eb1c7ecd39853b91c","modified":1702457898233},{"_id":"public/assets/img/favicons/favicon-16x16.png","hash":"ab4166e81042ed0cb31f56e4964e7d725b3a8191","modified":1702457898233},{"_id":"public/assets/img/favicons/site.webmanifest","hash":"93933d06a74c1a2dc3a5b90b5c01aba3e7f1fee8","modified":1702457898233},{"_id":"public/assets/img/favicons/safari-pinned-tab.svg","hash":"239cf2ebb0de15883cb569676afc8ed45ca9cf06","modified":1702457898233},{"_id":"public/assets/img/img_202311112225443281.png","hash":"7972335e6f5bb9ccccc7e4d080d40aa35684d3ed","modified":1702457898233},{"_id":"public/assets/img/img_202311130227323161.png","hash":"529016082766dff494c7075280040e42aea39768","modified":1702457898233},{"_id":"public/assets/img/img_202311131941497659.png","hash":"527f29678b30db22e259fda4dfc930bb72830196","modified":1702457898233},{"_id":"public/assets/img/img_202311162146456205.png","hash":"ffb8ffb1a13458b33b375e3988b9474fa43681c3","modified":1702457898233},{"_id":"public/assets/img/img_202311241307079570.png","hash":"959ee76c9fee92ffa8ce4852aa7c0818eaf63ba9","modified":1702457898233},{"_id":"public/assets/img/favicons/android-chrome-192x192.png","hash":"498f37c544ee77e948e63168438d1b1840d07701","modified":1702457898233},{"_id":"public/assets/img/favicons/apple-touch-icon.png","hash":"888f7f1228e06b8c87c0a0c45414d4cadbfa50fb","modified":1702457898233},{"_id":"public/js/img_zoom.js","hash":"a384c3a60fcbdad813cb8340200dfb07ebbcc48c","modified":1702457898233},{"_id":"public/js/common.js","hash":"7f62c8c148ee0b528a2bea47b248b2a7f5501142","modified":1702457898233},{"_id":"public/js/highlight.pack.js","hash":"2ef9bbbc688ce413686ce0eb64d0b25af4ea34e2","modified":1702457898233},{"_id":"public/js/jquery-fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1702457898233},{"_id":"public/js/jquery-3.6.1.min.js","hash":"0fa72756e48c33a6feeace1ffa5d790d58b53729","modified":1702457898233},{"_id":"public/style/common/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1702457898233},{"_id":"public/js/post.js","hash":"04edd583f103ba444d8174d55e7f45e27b8f2549","modified":1702457898233},{"_id":"public/style/themes/highlight-theme-light.css","hash":"f7b19080f00e10723bc86e6819fc25143a0137c5","modified":1702457898233},{"_id":"public/style/common/bulma.css","hash":"7ede761951c6f274850a1038416559a8f648c493","modified":1702457898233},{"_id":"public/assets/img/img_202311121735237199.png","hash":"968b47752dc846980353de12d5416d0af8e49256","modified":1702457898233},{"_id":"public/assets/img/img_202311230930147088.png","hash":"02e68926d489e7f4af9624ac51db59ef9f8409a0","modified":1702457898233},{"_id":"public/assets/img/img_202311241434531606.png","hash":"1a0d0bfc73a882fe6a2db1fa273a4c01ce801ff9","modified":1702457898233},{"_id":"public/style/themes/default-dark.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1702457898233},{"_id":"public/style/themes/default-light.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1702457898233},{"_id":"public/style/common/variable.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1702457898233},{"_id":"public/style/archive.css","hash":"fc79cddde5b0ee019889337bb3098d73bb6824cb","modified":1702457898233},{"_id":"public/style/about.css","hash":"54acbee918d1f3fb104e91ca074d397ccd38f5ed","modified":1702457898233},{"_id":"public/style/widget-header.css","hash":"80113d3a162a87b0574b478700242e8bb8cc9cf0","modified":1702457898233},{"_id":"public/style/common/helper.css","hash":"0b7612eebf65156aceec2f91b229ddeb38092456","modified":1702457898233},{"_id":"public/style/themes/theme.css","hash":"a334f9eaa157eda2bce485b22237a5d24cdf7d70","modified":1702457898233},{"_id":"public/style/post.css","hash":"9e42bd627735bf438d97c1709f76b853f2989a25","modified":1702457898233},{"_id":"public/style/base.css","hash":"e83bb81e864a736a80abe2901485cf43a1d86a87","modified":1702457898233},{"_id":"public/style/widget-post-list.css","hash":"f2b934eb3827d33353661f6480e2c320c0527bd4","modified":1702457898233},{"_id":"public/assets/img/img_202311120105246528.png","hash":"389176b316c47883ad8806286128bb8357952f7b","modified":1702457898233},{"_id":"public/assets/img/img_202311180514299621.png","hash":"ae2062aa8002eab68cbbc1c3ddb653a54659cf53","modified":1702457898233},{"_id":"public/assets/img/img_202311141520211655.png","hash":"08fe8e28942b04b036f6db7c1b1d1f27f527c16b","modified":1702457898233},{"_id":"public/assets/img/img_202311182234203649.png","hash":"68a745ab7885a4daf2d8b8f047aed9cbdbec95d5","modified":1702457898233},{"_id":"public/assets/img/img_202311141802036688.png","hash":"2ff042644344998baa70b505233750d84f01bd2e","modified":1702457898233},{"_id":"public/assets/img/img_202311180006318654.png","hash":"c1ca47719d4cdf1f7ba794bffcbc4c66aebd61d0","modified":1702457898233},{"_id":"public/assets/img/img_202311180516007386.png","hash":"6b38eb1747aa3c0597e1bb26bef01e166f11a7b7","modified":1702457898233},{"_id":"public/assets/img/favicons/android-chrome-512x512.png","hash":"bad22b7ecb65ede119847fcbf58b165c4eb89899","modified":1702457898233},{"_id":"public/images/avatar.png","hash":"3b11ffb03bcf4eefd3b850bc2dafe48a8774e65b","modified":1702457898233},{"_id":"public/assets/img/img_202311180103427767.png","hash":"97201f782483bc644dc6e8790b11cc300b159302","modified":1702457898233},{"_id":"public/assets/img/img_202311212007505770.png","hash":"b01942694a01338e144f600995fe234e7ecaa8c4","modified":1702457898233},{"_id":"public/assets/img/img_202311152245318150.png","hash":"4592c0db59a66cce6d502f604e1372e418ff2abd","modified":1702457898233},{"_id":"public/assets/img/img_202311151738162426.png","hash":"be80514cb9094e7b12703bc9ac756783e5047e71","modified":1702457898233},{"_id":"public/assets/img/img_202311170358241255.png","hash":"90771a60b647dc4a2cc2325ef9fef9b82f5e9ba6","modified":1702457898233},{"_id":"public/assets/img/img_202311211957171241.png","hash":"e7a30b7a37b839552ce1999389cf57550da4ee01","modified":1702457898233},{"_id":"public/assets/img/lucy.png","hash":"273c80fb6031a8dbc7551d045e28fcffbb5c68ca","modified":1702457898233}],"Category":[{"name":"笔记","_id":"clq3jh5uu0002i3er8a01e5ee"},{"name":"Docker","parent":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5uy000fi3eref9d6ff0"},{"name":"杂项","parent":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5uy000ki3er8wcu5ikk"},{"name":"docker","parent":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5uz000si3eratuy0d3y"},{"name":"速查","_id":"clq3jh5v0000yi3erehq02oyr"},{"name":"git","parent":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v00016i3er5dg2eblr"},{"name":"jekyll","parent":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v1001gi3erbafnb4lj"},{"name":"数据库","parent":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v3001ti3erdxx3fa33"},{"name":"Django","parent":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v4002ei3ergxwpacr4"},{"name":"配置","parent":"clq3jh5v0000yi3erehq02oyr","_id":"clq3jh5v8003ii3ere7zyh6b4"},{"name":"异常","parent":"clq3jh5v0000yi3erehq02oyr","_id":"clq3jh5v90045i3er9t6g1hcn"},{"name":"工具","parent":"clq3jh5v0000yi3erehq02oyr","_id":"clq3jh5va004fi3er5e3533ai"},{"name":"设计模式","parent":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vc0065i3er24og82vg"}],"Data":[{"_id":"menu","data":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}],"Page":[],"Post":[{"title":"自定义终端主题","date":"2023-11-17T11:17:12.000Z","image":"/assets/img/img_202311180006318654.png","_content":"\n## 安装Oh-my-zsh\n\n1. 使用`zsh`作为终端shell程序, 可以通过命令设置:\n  ```bash\n  chsh -s /bin/zsh\n  ```\n\n2. 安装Oh-my-zsh:\n  ```bash\n  sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n  ```\n\n3. 安装`Powerline`, 一款状态栏工具, 可以梅花终端和vim界面.\n  ```bash\n  pip install powerline-status\n  ```\n\n4. 安装Powerline的字体库, 依次运行命令:\n  ```bash\n  # clone\n  git clone https://github.com/powerline/fonts.git --depth=1\n  # or use gitee mirror when git is unable to access\n  git clone https://gitee.com/nestalk/fonts.git --depth=1\n  # install\n  cd fonts\n  ./install.sh\n  # clean-up a bit\n  cd ..\n  rm -rf fonts\n  ```\n\n5. 更换字体, 在终端, vscode中修改终端的字体为`Meslo LG`\n   * 终端: 设置 -> 描述文件 -> 文本 -> 字体\n   * VSCODE: cmd+shift+p -> settings.json:\n     ```json\n     {\n      \"editor.fontFamily\": \"Menlo, Monaco, 'Courier New', monospace, 'Meslo LG'\"\n     }\n     ```\n\n     > 事实上vscode不修改字体也没太大问题, 改了有时候反倒不舒服. 如果存在乱码可以通过自定义主题替换一下乱码字符.\n     >\n     {: .prompt-tip}\n\n## 设置ohmyzsh主题\n\noh-my-zsh内置了很多主题, 保存在目录`~/.oh-my-zsh/themes`下.\n\n也可以访问[github 主题页](https://github.com/ohmyzsh/ohmyzsh/wiki/Themes)获取更多主题.\n\n额外的[社区主题仓库](https://github.com/ohmyzsh/ohmyzsh/wiki/External-themes)\n\n通过`vim ~/.zshrc`命令修改配置文件, 可以指定主题等.\n\n## 设置语法高亮\n\n安装`zsh-syntax-highlighting`插件.\n\n```bash\nbrew install zsh-syntax-highlighting\n```\n\n在Mac上配置语法高亮插件:\n\n```bash\necho \"source $(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\" >> ${ZDOTDIR:-$HOME}/.zshrc\n```\n\n> 不同系统配置有所区别, 具体可参照[插件文档](https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md)\n>\n{: .prompt-tip}\n\n## 添加代码补全插件\n\n提供模糊代码补全的插件`zsh-completions`.\n\n```bash\ngit clone https://github.com/zsh-users/zsh-completions ${ZSH_CUSTOM:=~/.oh-my-zsh/custom}/plugins/zsh-completions\n```\n\n在`~/.zshrc`文件中添加插件\n\n```text\nplugins=(   \n    # other plugins...\n    zsh-completions\n)\n```\n\n## 添加历史命令补全插件\n\n通过历史命令自动补全的插件`zsh-autosuggestions`.\n\n```bash\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\n```\n\n同样在`~/.zshrc`文件中添加插件:\n\n```text\nplugins=( \n    # other plugins...\n    zsh-autosuggestions\n)\n```\n\n## 自定义主题\n\n折腾了不断实践, 最终结果还算满意, 基于内置的`agnoster`重新做了一下自定义.\n\n在Mac终端的最终显示效果如下:\n\n![preview](/assets/img/img_202311180103427767.png)\n\n* `⌘`: 表示默认用户在本机登录, 如果通过如果\n* `❖`: 表示文件路径, 就是个装饰\n* `◌`: git默认前缀, 会根据仓库状态有所改变\n* 红色部分代表处于虚拟环境下.\n\n为了使主题的一些配置生效, 需要在`./zshrc`文件中配置两个变量\n\n```python\nDEFAULT_USER=\"your name\"\nVIRTUAL_ENV_DISABLE_PROMPT=false\n```\n\n之后复制一份内置主题的文件, 并在其基础上自由发挥了, 至于主题的改法, 基本都是搜索加试错扣出来的.\n\n反正做好一次以后也就不用再折腾了, 时间也算花的值得.\n\n完成之后把主题的配置文件备份在[gitee仓库](https://gitee.com/nestalk/ohmyzsh_custom_theme), 以后也就走不丢了.\n","source":"_posts/others/custom-oh-my-zsh-theme.md","raw":"---\ntitle: 自定义终端主题\ndate: 2023-11-17 19:17:12 +0800\ncategories: [笔记, 杂项]\ntags: [zsh, theme, ⭐️]\nimage: /assets/img/img_202311180006318654.png\n---\n\n## 安装Oh-my-zsh\n\n1. 使用`zsh`作为终端shell程序, 可以通过命令设置:\n  ```bash\n  chsh -s /bin/zsh\n  ```\n\n2. 安装Oh-my-zsh:\n  ```bash\n  sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n  ```\n\n3. 安装`Powerline`, 一款状态栏工具, 可以梅花终端和vim界面.\n  ```bash\n  pip install powerline-status\n  ```\n\n4. 安装Powerline的字体库, 依次运行命令:\n  ```bash\n  # clone\n  git clone https://github.com/powerline/fonts.git --depth=1\n  # or use gitee mirror when git is unable to access\n  git clone https://gitee.com/nestalk/fonts.git --depth=1\n  # install\n  cd fonts\n  ./install.sh\n  # clean-up a bit\n  cd ..\n  rm -rf fonts\n  ```\n\n5. 更换字体, 在终端, vscode中修改终端的字体为`Meslo LG`\n   * 终端: 设置 -> 描述文件 -> 文本 -> 字体\n   * VSCODE: cmd+shift+p -> settings.json:\n     ```json\n     {\n      \"editor.fontFamily\": \"Menlo, Monaco, 'Courier New', monospace, 'Meslo LG'\"\n     }\n     ```\n\n     > 事实上vscode不修改字体也没太大问题, 改了有时候反倒不舒服. 如果存在乱码可以通过自定义主题替换一下乱码字符.\n     >\n     {: .prompt-tip}\n\n## 设置ohmyzsh主题\n\noh-my-zsh内置了很多主题, 保存在目录`~/.oh-my-zsh/themes`下.\n\n也可以访问[github 主题页](https://github.com/ohmyzsh/ohmyzsh/wiki/Themes)获取更多主题.\n\n额外的[社区主题仓库](https://github.com/ohmyzsh/ohmyzsh/wiki/External-themes)\n\n通过`vim ~/.zshrc`命令修改配置文件, 可以指定主题等.\n\n## 设置语法高亮\n\n安装`zsh-syntax-highlighting`插件.\n\n```bash\nbrew install zsh-syntax-highlighting\n```\n\n在Mac上配置语法高亮插件:\n\n```bash\necho \"source $(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\" >> ${ZDOTDIR:-$HOME}/.zshrc\n```\n\n> 不同系统配置有所区别, 具体可参照[插件文档](https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md)\n>\n{: .prompt-tip}\n\n## 添加代码补全插件\n\n提供模糊代码补全的插件`zsh-completions`.\n\n```bash\ngit clone https://github.com/zsh-users/zsh-completions ${ZSH_CUSTOM:=~/.oh-my-zsh/custom}/plugins/zsh-completions\n```\n\n在`~/.zshrc`文件中添加插件\n\n```text\nplugins=(   \n    # other plugins...\n    zsh-completions\n)\n```\n\n## 添加历史命令补全插件\n\n通过历史命令自动补全的插件`zsh-autosuggestions`.\n\n```bash\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\n```\n\n同样在`~/.zshrc`文件中添加插件:\n\n```text\nplugins=( \n    # other plugins...\n    zsh-autosuggestions\n)\n```\n\n## 自定义主题\n\n折腾了不断实践, 最终结果还算满意, 基于内置的`agnoster`重新做了一下自定义.\n\n在Mac终端的最终显示效果如下:\n\n![preview](/assets/img/img_202311180103427767.png)\n\n* `⌘`: 表示默认用户在本机登录, 如果通过如果\n* `❖`: 表示文件路径, 就是个装饰\n* `◌`: git默认前缀, 会根据仓库状态有所改变\n* 红色部分代表处于虚拟环境下.\n\n为了使主题的一些配置生效, 需要在`./zshrc`文件中配置两个变量\n\n```python\nDEFAULT_USER=\"your name\"\nVIRTUAL_ENV_DISABLE_PROMPT=false\n```\n\n之后复制一份内置主题的文件, 并在其基础上自由发挥了, 至于主题的改法, 基本都是搜索加试错扣出来的.\n\n反正做好一次以后也就不用再折腾了, 时间也算花的值得.\n\n完成之后把主题的配置文件备份在[gitee仓库](https://gitee.com/nestalk/ohmyzsh_custom_theme), 以后也就走不丢了.\n","slug":"others-custom-oh-my-zsh-theme","published":1,"updated":"2023-12-13T08:43:58.102Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5ur0000i3er7pos1jbu","content":"<h2 id=\"安装Oh-my-zsh\"><a href=\"#安装Oh-my-zsh\" class=\"headerlink\" title=\"安装Oh-my-zsh\"></a>安装Oh-my-zsh</h2><ol>\n<li>使用<code>zsh</code>作为终端shell程序, 可以通过命令设置:</li>\n</ol>\n<pre><code class=\"bash\">chsh -s /bin/zsh\n</code></pre>\n<ol start=\"2\">\n<li>安装Oh-my-zsh:</li>\n</ol>\n<pre><code class=\"bash\">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;\n</code></pre>\n<ol start=\"3\">\n<li>安装<code>Powerline</code>, 一款状态栏工具, 可以梅花终端和vim界面.</li>\n</ol>\n<pre><code class=\"bash\">pip install powerline-status\n</code></pre>\n<ol start=\"4\">\n<li>安装Powerline的字体库, 依次运行命令:</li>\n</ol>\n<pre><code class=\"bash\"># clone\ngit clone https://github.com/powerline/fonts.git --depth=1\n# or use gitee mirror when git is unable to access\ngit clone https://gitee.com/nestalk/fonts.git --depth=1\n# install\ncd fonts\n./install.sh\n# clean-up a bit\ncd ..\nrm -rf fonts\n</code></pre>\n<ol start=\"5\">\n<li>更换字体, 在终端, vscode中修改终端的字体为<code>Meslo LG</code><ul>\n<li><p>终端: 设置 -&gt; 描述文件 -&gt; 文本 -&gt; 字体</p>\n</li>\n<li><p>VSCODE: cmd+shift+p -&gt; settings.json:</p>\n<pre><code class=\"json\">&#123;\n &quot;editor.fontFamily&quot;: &quot;Menlo, Monaco, &#39;Courier New&#39;, monospace, &#39;Meslo LG&#39;&quot;\n&#125;\n</code></pre>\n<blockquote>\n<p>事实上vscode不修改字体也没太大问题, 改了有时候反倒不舒服. 如果存在乱码可以通过自定义主题替换一下乱码字符.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"设置ohmyzsh主题\"><a href=\"#设置ohmyzsh主题\" class=\"headerlink\" title=\"设置ohmyzsh主题\"></a>设置ohmyzsh主题</h2><p>oh-my-zsh内置了很多主题, 保存在目录<code>~/.oh-my-zsh/themes</code>下.</p>\n<p>也可以访问<a href=\"https://github.com/ohmyzsh/ohmyzsh/wiki/Themes\">github 主题页</a>获取更多主题.</p>\n<p>额外的<a href=\"https://github.com/ohmyzsh/ohmyzsh/wiki/External-themes\">社区主题仓库</a></p>\n<p>通过<code>vim ~/.zshrc</code>命令修改配置文件, 可以指定主题等.</p>\n<h2 id=\"设置语法高亮\"><a href=\"#设置语法高亮\" class=\"headerlink\" title=\"设置语法高亮\"></a>设置语法高亮</h2><p>安装<code>zsh-syntax-highlighting</code>插件.</p>\n<pre><code class=\"bash\">brew install zsh-syntax-highlighting\n</code></pre>\n<p>在Mac上配置语法高亮插件:</p>\n<pre><code class=\"bash\">echo &quot;source $(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrc\n</code></pre>\n<blockquote>\n<p>不同系统配置有所区别, 具体可参照<a href=\"https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md\">插件文档</a></p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h2 id=\"添加代码补全插件\"><a href=\"#添加代码补全插件\" class=\"headerlink\" title=\"添加代码补全插件\"></a>添加代码补全插件</h2><p>提供模糊代码补全的插件<code>zsh-completions</code>.</p>\n<pre><code class=\"bash\">git clone https://github.com/zsh-users/zsh-completions $&#123;ZSH_CUSTOM:=~/.oh-my-zsh/custom&#125;/plugins/zsh-completions\n</code></pre>\n<p>在<code>~/.zshrc</code>文件中添加插件</p>\n<pre><code class=\"text\">plugins=(   \n    # other plugins...\n    zsh-completions\n)\n</code></pre>\n<h2 id=\"添加历史命令补全插件\"><a href=\"#添加历史命令补全插件\" class=\"headerlink\" title=\"添加历史命令补全插件\"></a>添加历史命令补全插件</h2><p>通过历史命令自动补全的插件<code>zsh-autosuggestions</code>.</p>\n<pre><code class=\"bash\">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions\n</code></pre>\n<p>同样在<code>~/.zshrc</code>文件中添加插件:</p>\n<pre><code class=\"text\">plugins=( \n    # other plugins...\n    zsh-autosuggestions\n)\n</code></pre>\n<h2 id=\"自定义主题\"><a href=\"#自定义主题\" class=\"headerlink\" title=\"自定义主题\"></a>自定义主题</h2><p>折腾了不断实践, 最终结果还算满意, 基于内置的<code>agnoster</code>重新做了一下自定义.</p>\n<p>在Mac终端的最终显示效果如下:</p>\n<p><img src=\"/assets/img/img_202311180103427767.png\" alt=\"preview\"></p>\n<ul>\n<li><code>⌘</code>: 表示默认用户在本机登录, 如果通过如果</li>\n<li><code>❖</code>: 表示文件路径, 就是个装饰</li>\n<li><code>◌</code>: git默认前缀, 会根据仓库状态有所改变</li>\n<li>红色部分代表处于虚拟环境下.</li>\n</ul>\n<p>为了使主题的一些配置生效, 需要在<code>./zshrc</code>文件中配置两个变量</p>\n<pre><code class=\"python\">DEFAULT_USER=&quot;your name&quot;\nVIRTUAL_ENV_DISABLE_PROMPT=false\n</code></pre>\n<p>之后复制一份内置主题的文件, 并在其基础上自由发挥了, 至于主题的改法, 基本都是搜索加试错扣出来的.</p>\n<p>反正做好一次以后也就不用再折腾了, 时间也算花的值得.</p>\n<p>完成之后把主题的配置文件备份在<a href=\"https://gitee.com/nestalk/ohmyzsh_custom_theme\">gitee仓库</a>, 以后也就走不丢了.</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"安装Oh-my-zsh\"><a href=\"#安装Oh-my-zsh\" class=\"headerlink\" title=\"安装Oh-my-zsh\"></a>安装Oh-my-zsh</h2><ol>\n<li>使用<code>zsh</code>作为终端shell程序, 可以通过命令设置:</li>\n</ol>\n<pre><code class=\"bash\">chsh -s /bin/zsh\n</code></pre>\n<ol start=\"2\">\n<li>安装Oh-my-zsh:</li>\n</ol>\n<pre><code class=\"bash\">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;\n</code></pre>\n<ol start=\"3\">\n<li>安装<code>Powerline</code>, 一款状态栏工具, 可以梅花终端和vim界面.</li>\n</ol>\n<pre><code class=\"bash\">pip install powerline-status\n</code></pre>\n<ol start=\"4\">\n<li>安装Powerline的字体库, 依次运行命令:</li>\n</ol>\n<pre><code class=\"bash\"># clone\ngit clone https://github.com/powerline/fonts.git --depth=1\n# or use gitee mirror when git is unable to access\ngit clone https://gitee.com/nestalk/fonts.git --depth=1\n# install\ncd fonts\n./install.sh\n# clean-up a bit\ncd ..\nrm -rf fonts\n</code></pre>\n<ol start=\"5\">\n<li>更换字体, 在终端, vscode中修改终端的字体为<code>Meslo LG</code><ul>\n<li><p>终端: 设置 -&gt; 描述文件 -&gt; 文本 -&gt; 字体</p>\n</li>\n<li><p>VSCODE: cmd+shift+p -&gt; settings.json:</p>\n<pre><code class=\"json\">&#123;\n &quot;editor.fontFamily&quot;: &quot;Menlo, Monaco, &#39;Courier New&#39;, monospace, &#39;Meslo LG&#39;&quot;\n&#125;\n</code></pre>\n<blockquote>\n<p>事实上vscode不修改字体也没太大问题, 改了有时候反倒不舒服. 如果存在乱码可以通过自定义主题替换一下乱码字符.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"设置ohmyzsh主题\"><a href=\"#设置ohmyzsh主题\" class=\"headerlink\" title=\"设置ohmyzsh主题\"></a>设置ohmyzsh主题</h2><p>oh-my-zsh内置了很多主题, 保存在目录<code>~/.oh-my-zsh/themes</code>下.</p>\n<p>也可以访问<a href=\"https://github.com/ohmyzsh/ohmyzsh/wiki/Themes\">github 主题页</a>获取更多主题.</p>\n<p>额外的<a href=\"https://github.com/ohmyzsh/ohmyzsh/wiki/External-themes\">社区主题仓库</a></p>\n<p>通过<code>vim ~/.zshrc</code>命令修改配置文件, 可以指定主题等.</p>\n<h2 id=\"设置语法高亮\"><a href=\"#设置语法高亮\" class=\"headerlink\" title=\"设置语法高亮\"></a>设置语法高亮</h2><p>安装<code>zsh-syntax-highlighting</code>插件.</p>\n<pre><code class=\"bash\">brew install zsh-syntax-highlighting\n</code></pre>\n<p>在Mac上配置语法高亮插件:</p>\n<pre><code class=\"bash\">echo &quot;source $(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrc\n</code></pre>\n<blockquote>\n<p>不同系统配置有所区别, 具体可参照<a href=\"https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md\">插件文档</a></p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h2 id=\"添加代码补全插件\"><a href=\"#添加代码补全插件\" class=\"headerlink\" title=\"添加代码补全插件\"></a>添加代码补全插件</h2><p>提供模糊代码补全的插件<code>zsh-completions</code>.</p>\n<pre><code class=\"bash\">git clone https://github.com/zsh-users/zsh-completions $&#123;ZSH_CUSTOM:=~/.oh-my-zsh/custom&#125;/plugins/zsh-completions\n</code></pre>\n<p>在<code>~/.zshrc</code>文件中添加插件</p>\n<pre><code class=\"text\">plugins=(   \n    # other plugins...\n    zsh-completions\n)\n</code></pre>\n<h2 id=\"添加历史命令补全插件\"><a href=\"#添加历史命令补全插件\" class=\"headerlink\" title=\"添加历史命令补全插件\"></a>添加历史命令补全插件</h2><p>通过历史命令自动补全的插件<code>zsh-autosuggestions</code>.</p>\n<pre><code class=\"bash\">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions\n</code></pre>\n<p>同样在<code>~/.zshrc</code>文件中添加插件:</p>\n<pre><code class=\"text\">plugins=( \n    # other plugins...\n    zsh-autosuggestions\n)\n</code></pre>\n<h2 id=\"自定义主题\"><a href=\"#自定义主题\" class=\"headerlink\" title=\"自定义主题\"></a>自定义主题</h2><p>折腾了不断实践, 最终结果还算满意, 基于内置的<code>agnoster</code>重新做了一下自定义.</p>\n<p>在Mac终端的最终显示效果如下:</p>\n<p><img src=\"/assets/img/img_202311180103427767.png\" alt=\"preview\"></p>\n<ul>\n<li><code>⌘</code>: 表示默认用户在本机登录, 如果通过如果</li>\n<li><code>❖</code>: 表示文件路径, 就是个装饰</li>\n<li><code>◌</code>: git默认前缀, 会根据仓库状态有所改变</li>\n<li>红色部分代表处于虚拟环境下.</li>\n</ul>\n<p>为了使主题的一些配置生效, 需要在<code>./zshrc</code>文件中配置两个变量</p>\n<pre><code class=\"python\">DEFAULT_USER=&quot;your name&quot;\nVIRTUAL_ENV_DISABLE_PROMPT=false\n</code></pre>\n<p>之后复制一份内置主题的文件, 并在其基础上自由发挥了, 至于主题的改法, 基本都是搜索加试错扣出来的.</p>\n<p>反正做好一次以后也就不用再折腾了, 时间也算花的值得.</p>\n<p>完成之后把主题的配置文件备份在<a href=\"https://gitee.com/nestalk/ohmyzsh_custom_theme\">gitee仓库</a>, 以后也就走不丢了.</p>\n"},{"title":"git学习笔记","date":"2023-11-16T19:59:52.000Z","_content":"\n## 配置Git\n\n[Git config 官方多语言文档](https://git-scm.com/docs/git-config/zh_HANS-CN)\n\n* `git config --global core.editor \"code --wait\"`: 指定vscode作为全局编辑器.\n* `git config --global diff.tool vscode`: 设置通过vscode查看文件变更.\n* `git config --global difftool.vscode.cmd \"code --wait --diff $LOCAL $REMOTE\"`: 配置git打开vscode的命令参数.\n* `git config --global -e`: 使用全局编辑器编辑配置文件.\n* `git config --global core.autocrlf input`: 配置换行符\n  > windows的换行符是`\\r\\n`, 而mac是`\\n`, 如果配置错误就会在使用git时出现很多不必要的麻烦.\n  >\n  > * Mac: `core.autocrlf input`\n  > * Win: `core.autocrlf true`\n  >\n  > 通常在git安装时会自动配置, 知道原理即可.\n  >\n  {: .prompt-tip}\n* `git config --global init.defaultBranch <name>`: 设置git默认分支名称, 未设置默认为`master`, 但是初始化git时会有额外的提示信息.\n* `git config --global alias.lg \"log --pretty=format:'%an -> %h'\"`: 为git命令创建别名, 可以通过别名将复杂的git命令和参数进行简化.\n  \n  > [pretty fromat相关文档](https://git-scm.com/docs/git-log#_pretty_formats)\n  >\n  > 一个自用的简略信息:`%Cgreen%an<%ae>%Creset->%Cblue%h%Creset@%as:%Cred%s%Creset`\n  >\n  {: .prompt-info}\n\n* `git config --global core.pager=cat`: 设置git命令的输出分页器, 默认使用less, 会将结果单独显示在一个屏幕中, 需要按`q`才能退出, 原始终端则没有内容. 改为`cat`则直接在当前命令行输出, 根据个人偏好配置即可.\n\n![sep](/assets/img/separator_1.png)\n\n## Git 命令行工具\n\n### 仓库管理\n\n* `git init`: 初始化git目录, 自动创建`.git`文件夹.\n* `git status`: 查看当前git状态. 也可结合参数`-s`显示简略信息.\n* `git add [option]`: 将变更内容添加到缓存区.\n* `git commit -m\"commit message\"`: 提交到本地仓库.\n  \n  > 如果设置了git的全局编辑器, 可以直接使用`git commit`, 此时会使用指定的编辑器打开一个文本文件, 可以更为方便的输入提交描述.\n  >\n  {: .prompt-tip}\n\n* `git commit -am \"commit message\"`: 跳过缓存, 直接将全部修改提交到本地仓库.\n\n### 文件操作\n\n* `git ls-files`: 显示git管理的文件.\n* `git rm [file]`: 在git和本地同时删除指定文件.\n* `git rm --cached [file]`: 仅删除git缓存的文件, 本地文件不受影响.\n* `git mv [file]`: 在本地和git中同时移动或者重命名文件.\n* `git restore [file]`: 将本地已有索引的文件恢复至修改前的状态.\n  * `--staged`: 将缓存区的内容回复至之前的状态.\n  * `--source=[HEAD~n | id] filename`: 将修改或删除的文件恢复到之前提交的版本.\n* `git clean`: 删除所有未创建索引的内容, 危险操作, 需要配合参数执行.\n  * `-f`: force强制执行\n  * `-d`: 包含文件夹\n\n### 源码管理\n\n* `git diff`: 显示缓存区与工作区的变动\n  * `--staged`: 查看缓存区的变动内容.\n  * `HEAD~2 HEAD [filename]`: 查看最近3次的全部或特定文件的变化.\n* `git log`: 显示提交记录\n  * `--oneline`: 显示提交记录摘要\n  * `--reverse`: 逆序显示\n* `git show`: 显示最后一次提交的变更内容\n  * `HEAD~n`: HEAD代表最后一次提交, `n`表示向前数n次, 比如`HEAD~n`\n  * 也可以通过log查看提交id, 通过指定id查看提交内容.\n  * `HEAD:path/to/file`: 查看特定文件的变动.\n  * `HEAD --name-status`: 查看更改的文件.\n* `git checkout [id]`: 将工作区恢复至指定的快照id.\n  * `HEAD~n`: 向前数n个快照.\n  * `master`: 设置为最新的快照.\n\n### 查找bug\n\n当一个快照出现问题, 而这个问题有可能是由于之前的快照索引的, 那么诸葛快照查找就会非常麻烦.\n\n为了这种情况, git 提供了一个强大的工具, `bisect`. bisection的缩写, 本质就是采用二分法查找出错的快照.\n\n1. `git bisect start`: 开始二分查找\n2. `git bisect bad`: 标记当前快照有问题, 通常在master快照下执行\n3. `git bisect good [id | HEAD~n]`: 指定之前的一个确定没问题的快照, 此时bisect会自动帮助我们在不同的快照之间进行切换, 用以检查错误.\n4. `git bisect good`: 标记当前检查的快照正常, bisect会自动切换至下一个快照\n5. `git bisect bad`: 标记该快照为异常快照\n6. `git bisect reset`: 退出bisect模式.\n\n### 设置快照标签\n\n* `git tag v1.0.0`: 设置当前快照的标签为`v1.0.0`\n* `git tag empty d873716 -m \"empty project\"`: 为指定id的快照添加empty标签, 同时设置标签信息.\n* `git checkout empty`: 根据标签checkout\n* `git tag -n`: 列出所有标签和标签信息.\n* `git tag --points-at <id>`: 列出指定或者当前快照的标签\n* `git tag -d [tagname]`: 删除标签\n\n![sep](/assets/img/separator_1.png)\n\n## .gitignore文件\n\n在根目录下建立`.gitignore`文件用以配置忽略版本控制的文件.\n\n```python\nlogs/       # 忽略logs目录\nmain.log    # 忽略指定文件\n*.log       # 忽略匹配文件\n```\n\n> 对于已经加入git索引的内容不会受到`.gitignore`文件的影响.\n>\n> 需要通过`git rm --cached`命令手动将其在索引中删除.\n>\n{: .prompt-tip}\n\n[.gitignore 模板仓库](https://github.com/github/gitignore/tree/main)\n\n![sep](/assets/img/separator_1.png)\n\n## Git可视化软件\n\n[Sourcetree](https://www.sourcetreeapp.com): 完全免费, 仅支持Windows和Mac.\n\n![preview](https://wac-cdn.atlassian.com/dam/jcr:580c367b-c240-453d-aa18-c7ced44324f9/hero-mac-screenshot.png?cdnVersion=1320)\n\n[GitKraken](https://www.gitkraken.com): 针对开源软件项目免费. UI是相当的舒服~~\n\n![preview](/assets/img/img_202311170358241255.png)\n\n![sep](/assets/img/separator_3.png)\n\n## Git 分支管理\n\ngit的分支是一个指向`master`快照的指针, 并不会创建新的文件系统, 所以不会像svn一样产生额外的消耗.\n\n* `git branch bugfix`: 创建名为bugfix的分支\n* `git branch`: 列出所有分支\n* `git switch bugfix`: 切换到bugfix分支\n* `git switch -C bugfix`: 创建并切换到bugfix分支\n* `git branch -m bugfix bugfix-somebug`: 重命名分支\n* `git branch -d bugfix-somebug`: 删除指定分支, 如果分支存在未合并的内容则无法删除. 在确定删除的情况下可以使用`-D`强制执行.\n* `git branch --merged`: 显示已经合并的分支\n* `git branch --no-merged`: 显示尚未合并的分支\n\n### 确定两个分支之间的不同\n\n* `git log master..bugfix-somebug`: 显示分支之后的提交内容.\n* `git diff master..bugfix-somebug`: 显示两个分支之间的差异.\n  > 如果当前已经在master分之下, 可以省略`master..`\n  >\n  {: .prompt-tip}\n* `git diff --name-only bugfix-somebug`: 显示有差异的文件.\n* `git diff --name-status bugfix-somebug`: 显示有差异的文件状态.\n  > 比较实用的命令, 可以创建两个别名, 比如`dno`,`dns`\n  >\n  {: .prompt-tip}\n\n### 通过stash缓存变动内容\n\n在工作区发生了变动, 并且没有进行提交时, 如果需要切换到其他的分支, 可以将变动内容暂存以备之后使用.\n\n* `git stash push -m \"stash message\"`: 将工作区的变动内容移至暂存区.\n  * 如果工作区包含为索引的内容, 可以使用`-am`参数, 即`--all -m`.\n* `git stash list`: 列出暂存区索引.\n* `git stash show n`: 显示第n条暂存内容的变更项.\n* `git stash apply n`: 取回暂存区的第n个索引.\n* `git stash drop n`: 删除第n项\n* `git stash clear`: 清空暂存区\n\n### 合并分支\n\n合并分支大致分为两种情况:\n\n1. 在分支修改完成后, 主分支没有发生变化, 此时可以直接让主分支指向当前分支. 成为Fast Forward.\n   ![ff](/assets/img/img_202311180514299621.png)\n\n2. 在分支代码修改完成后, 主分支有其他的提交, 此时则需要重新建立一个合并提交.\n   ![3wf](/assets/img/img_202311180516007386.png)\n\n对于第一种情况来说, 合并分支非常简单, 只需要在`master`分支下执行合并命令即可;\n\n```bash\ngit merge bugfix-somebug\n```\n\n如果不希望使用`Fast Forward`可以添加参数`--no-ff`. 这样当前的master就会和分支合并为一个新的快照.\n\n有些公司会禁用FF合并, 因为这会让项目的演化信息丢失, 整个项目的研发路线成为一条支线. 如果在应用分之后希望退回之前的状态, 那么就需要找到建立分支时的快照.\n\n但不使用FF的情况下无论何时想要取消合并只需要回退一步就可以了.\n\n也可以通过git配置禁用FF从而省略关键字:\n\n```bash\ngit config merge.ff false # 当前工作区禁用\ngit config --global merge.ff false # 全局禁用\n```\n\n还有一种不太常用的合并方式, `git merge --squash branch`. 直译压缩合并.\n\n会将指定分支中的变动内容加入到当前分支, 可以直接使其为对当前分支的修改. 但本质上并没有将分支合并到主分支上.\n\n因此只适用于较小变动的分支, 且应当在合并操作之后将分支删除.\n\n因为虽然压缩合并已经将分支内容写入了主分支内, 但是通过`git branch --merged`命令查看已经合并的分支时不会显示压缩合并的分支. 这会产生歧义, 无法判断该分支是否已经被正确处理了.\n\n### 解决合并冲突\n\n当合并两个分支时, 如果他们对同一个文件进行过修改提交时就会出现冲突(conflicts).\n此时通过`git status`查看产生冲突的文件, 手动选择需要保留的代码并提交即可.\n\n在使用GitKraken一类功能强大的可视化工具时可以很好的解决合并分支和冲突问题.\n\n但GitKranken只针对开源项目免费.\n\n也有一些免费的合并工具, 比如[P4Merge](https://www.perforce.com/zh-hans/chanpin/helix-core-apps/merge-diff-tool-p4merge)\n\n可以通过git全局设置来指定默认的合并工具\n\n```bash\ngit config --global merge.tool p4merge\ngit config --global mergetool.p4merge.path \"/Applications/p4merge.app/Contents/MacOS/p4merge\"\n```\n\n配置完成后, 当出现冲突时就可以直接使用`git mergetool`启动工具.\n\n如果希望中止合并, 可以直接使用命令`git merge --abort`.\n\n> p4merge会自动为冲突文件创建副本, 而git则会询问这一副本文件.\n>\n> 可以在`.gitignore`文件中添加备份文件`*.orig`\n>\n> 或直接通过全局配置禁用备份:\n>\n> ```bash\n> git config --global mergetool.keepBackup false\n> ```\n>\n{: .prompt-tip}\n\n### 撤销提交\n\n如果希望撤销一个提交, 可以通过命令 `git reset [mode] HEAD~1`完成.\n\n撤销命令存在三种模式:\n\n* `--soft`: 仅修改快照指针, 本地缓存(stage)和工作区不受影响\n* `--mixed`: 修改快照指针, 同时将指向的快照版本放入本地缓存, 工作区不受影响.\n* `--hard`: 修改快照指针, 同时将快照放入工作区, 相当于checkout.\n\n也可以通过`git revert HEAD`指令进行回退.\n\n### Rebase 重建分支\n\n在分支创建后, 如果主分支有新的提交, 可以将分支进行重建操作, 以使项目呈线性的提交历史.\n\n在分支下执行指令`git rebase master`即可.\n\n![rebase](/assets/img/img_202311182234203649.png)\n\n> rebase会修改项目的提交历史, 仅在本地, 不要在团队项目中使用.\n>\n{: .prompt-warning}\n","source":"_posts/others/git-note.md","raw":"---\ntitle: git学习笔记\ndate: 2023-11-17 03:59:52 +0800\ncategories: [笔记, git]\ntags: [git]\n---\n\n## 配置Git\n\n[Git config 官方多语言文档](https://git-scm.com/docs/git-config/zh_HANS-CN)\n\n* `git config --global core.editor \"code --wait\"`: 指定vscode作为全局编辑器.\n* `git config --global diff.tool vscode`: 设置通过vscode查看文件变更.\n* `git config --global difftool.vscode.cmd \"code --wait --diff $LOCAL $REMOTE\"`: 配置git打开vscode的命令参数.\n* `git config --global -e`: 使用全局编辑器编辑配置文件.\n* `git config --global core.autocrlf input`: 配置换行符\n  > windows的换行符是`\\r\\n`, 而mac是`\\n`, 如果配置错误就会在使用git时出现很多不必要的麻烦.\n  >\n  > * Mac: `core.autocrlf input`\n  > * Win: `core.autocrlf true`\n  >\n  > 通常在git安装时会自动配置, 知道原理即可.\n  >\n  {: .prompt-tip}\n* `git config --global init.defaultBranch <name>`: 设置git默认分支名称, 未设置默认为`master`, 但是初始化git时会有额外的提示信息.\n* `git config --global alias.lg \"log --pretty=format:'%an -> %h'\"`: 为git命令创建别名, 可以通过别名将复杂的git命令和参数进行简化.\n  \n  > [pretty fromat相关文档](https://git-scm.com/docs/git-log#_pretty_formats)\n  >\n  > 一个自用的简略信息:`%Cgreen%an<%ae>%Creset->%Cblue%h%Creset@%as:%Cred%s%Creset`\n  >\n  {: .prompt-info}\n\n* `git config --global core.pager=cat`: 设置git命令的输出分页器, 默认使用less, 会将结果单独显示在一个屏幕中, 需要按`q`才能退出, 原始终端则没有内容. 改为`cat`则直接在当前命令行输出, 根据个人偏好配置即可.\n\n![sep](/assets/img/separator_1.png)\n\n## Git 命令行工具\n\n### 仓库管理\n\n* `git init`: 初始化git目录, 自动创建`.git`文件夹.\n* `git status`: 查看当前git状态. 也可结合参数`-s`显示简略信息.\n* `git add [option]`: 将变更内容添加到缓存区.\n* `git commit -m\"commit message\"`: 提交到本地仓库.\n  \n  > 如果设置了git的全局编辑器, 可以直接使用`git commit`, 此时会使用指定的编辑器打开一个文本文件, 可以更为方便的输入提交描述.\n  >\n  {: .prompt-tip}\n\n* `git commit -am \"commit message\"`: 跳过缓存, 直接将全部修改提交到本地仓库.\n\n### 文件操作\n\n* `git ls-files`: 显示git管理的文件.\n* `git rm [file]`: 在git和本地同时删除指定文件.\n* `git rm --cached [file]`: 仅删除git缓存的文件, 本地文件不受影响.\n* `git mv [file]`: 在本地和git中同时移动或者重命名文件.\n* `git restore [file]`: 将本地已有索引的文件恢复至修改前的状态.\n  * `--staged`: 将缓存区的内容回复至之前的状态.\n  * `--source=[HEAD~n | id] filename`: 将修改或删除的文件恢复到之前提交的版本.\n* `git clean`: 删除所有未创建索引的内容, 危险操作, 需要配合参数执行.\n  * `-f`: force强制执行\n  * `-d`: 包含文件夹\n\n### 源码管理\n\n* `git diff`: 显示缓存区与工作区的变动\n  * `--staged`: 查看缓存区的变动内容.\n  * `HEAD~2 HEAD [filename]`: 查看最近3次的全部或特定文件的变化.\n* `git log`: 显示提交记录\n  * `--oneline`: 显示提交记录摘要\n  * `--reverse`: 逆序显示\n* `git show`: 显示最后一次提交的变更内容\n  * `HEAD~n`: HEAD代表最后一次提交, `n`表示向前数n次, 比如`HEAD~n`\n  * 也可以通过log查看提交id, 通过指定id查看提交内容.\n  * `HEAD:path/to/file`: 查看特定文件的变动.\n  * `HEAD --name-status`: 查看更改的文件.\n* `git checkout [id]`: 将工作区恢复至指定的快照id.\n  * `HEAD~n`: 向前数n个快照.\n  * `master`: 设置为最新的快照.\n\n### 查找bug\n\n当一个快照出现问题, 而这个问题有可能是由于之前的快照索引的, 那么诸葛快照查找就会非常麻烦.\n\n为了这种情况, git 提供了一个强大的工具, `bisect`. bisection的缩写, 本质就是采用二分法查找出错的快照.\n\n1. `git bisect start`: 开始二分查找\n2. `git bisect bad`: 标记当前快照有问题, 通常在master快照下执行\n3. `git bisect good [id | HEAD~n]`: 指定之前的一个确定没问题的快照, 此时bisect会自动帮助我们在不同的快照之间进行切换, 用以检查错误.\n4. `git bisect good`: 标记当前检查的快照正常, bisect会自动切换至下一个快照\n5. `git bisect bad`: 标记该快照为异常快照\n6. `git bisect reset`: 退出bisect模式.\n\n### 设置快照标签\n\n* `git tag v1.0.0`: 设置当前快照的标签为`v1.0.0`\n* `git tag empty d873716 -m \"empty project\"`: 为指定id的快照添加empty标签, 同时设置标签信息.\n* `git checkout empty`: 根据标签checkout\n* `git tag -n`: 列出所有标签和标签信息.\n* `git tag --points-at <id>`: 列出指定或者当前快照的标签\n* `git tag -d [tagname]`: 删除标签\n\n![sep](/assets/img/separator_1.png)\n\n## .gitignore文件\n\n在根目录下建立`.gitignore`文件用以配置忽略版本控制的文件.\n\n```python\nlogs/       # 忽略logs目录\nmain.log    # 忽略指定文件\n*.log       # 忽略匹配文件\n```\n\n> 对于已经加入git索引的内容不会受到`.gitignore`文件的影响.\n>\n> 需要通过`git rm --cached`命令手动将其在索引中删除.\n>\n{: .prompt-tip}\n\n[.gitignore 模板仓库](https://github.com/github/gitignore/tree/main)\n\n![sep](/assets/img/separator_1.png)\n\n## Git可视化软件\n\n[Sourcetree](https://www.sourcetreeapp.com): 完全免费, 仅支持Windows和Mac.\n\n![preview](https://wac-cdn.atlassian.com/dam/jcr:580c367b-c240-453d-aa18-c7ced44324f9/hero-mac-screenshot.png?cdnVersion=1320)\n\n[GitKraken](https://www.gitkraken.com): 针对开源软件项目免费. UI是相当的舒服~~\n\n![preview](/assets/img/img_202311170358241255.png)\n\n![sep](/assets/img/separator_3.png)\n\n## Git 分支管理\n\ngit的分支是一个指向`master`快照的指针, 并不会创建新的文件系统, 所以不会像svn一样产生额外的消耗.\n\n* `git branch bugfix`: 创建名为bugfix的分支\n* `git branch`: 列出所有分支\n* `git switch bugfix`: 切换到bugfix分支\n* `git switch -C bugfix`: 创建并切换到bugfix分支\n* `git branch -m bugfix bugfix-somebug`: 重命名分支\n* `git branch -d bugfix-somebug`: 删除指定分支, 如果分支存在未合并的内容则无法删除. 在确定删除的情况下可以使用`-D`强制执行.\n* `git branch --merged`: 显示已经合并的分支\n* `git branch --no-merged`: 显示尚未合并的分支\n\n### 确定两个分支之间的不同\n\n* `git log master..bugfix-somebug`: 显示分支之后的提交内容.\n* `git diff master..bugfix-somebug`: 显示两个分支之间的差异.\n  > 如果当前已经在master分之下, 可以省略`master..`\n  >\n  {: .prompt-tip}\n* `git diff --name-only bugfix-somebug`: 显示有差异的文件.\n* `git diff --name-status bugfix-somebug`: 显示有差异的文件状态.\n  > 比较实用的命令, 可以创建两个别名, 比如`dno`,`dns`\n  >\n  {: .prompt-tip}\n\n### 通过stash缓存变动内容\n\n在工作区发生了变动, 并且没有进行提交时, 如果需要切换到其他的分支, 可以将变动内容暂存以备之后使用.\n\n* `git stash push -m \"stash message\"`: 将工作区的变动内容移至暂存区.\n  * 如果工作区包含为索引的内容, 可以使用`-am`参数, 即`--all -m`.\n* `git stash list`: 列出暂存区索引.\n* `git stash show n`: 显示第n条暂存内容的变更项.\n* `git stash apply n`: 取回暂存区的第n个索引.\n* `git stash drop n`: 删除第n项\n* `git stash clear`: 清空暂存区\n\n### 合并分支\n\n合并分支大致分为两种情况:\n\n1. 在分支修改完成后, 主分支没有发生变化, 此时可以直接让主分支指向当前分支. 成为Fast Forward.\n   ![ff](/assets/img/img_202311180514299621.png)\n\n2. 在分支代码修改完成后, 主分支有其他的提交, 此时则需要重新建立一个合并提交.\n   ![3wf](/assets/img/img_202311180516007386.png)\n\n对于第一种情况来说, 合并分支非常简单, 只需要在`master`分支下执行合并命令即可;\n\n```bash\ngit merge bugfix-somebug\n```\n\n如果不希望使用`Fast Forward`可以添加参数`--no-ff`. 这样当前的master就会和分支合并为一个新的快照.\n\n有些公司会禁用FF合并, 因为这会让项目的演化信息丢失, 整个项目的研发路线成为一条支线. 如果在应用分之后希望退回之前的状态, 那么就需要找到建立分支时的快照.\n\n但不使用FF的情况下无论何时想要取消合并只需要回退一步就可以了.\n\n也可以通过git配置禁用FF从而省略关键字:\n\n```bash\ngit config merge.ff false # 当前工作区禁用\ngit config --global merge.ff false # 全局禁用\n```\n\n还有一种不太常用的合并方式, `git merge --squash branch`. 直译压缩合并.\n\n会将指定分支中的变动内容加入到当前分支, 可以直接使其为对当前分支的修改. 但本质上并没有将分支合并到主分支上.\n\n因此只适用于较小变动的分支, 且应当在合并操作之后将分支删除.\n\n因为虽然压缩合并已经将分支内容写入了主分支内, 但是通过`git branch --merged`命令查看已经合并的分支时不会显示压缩合并的分支. 这会产生歧义, 无法判断该分支是否已经被正确处理了.\n\n### 解决合并冲突\n\n当合并两个分支时, 如果他们对同一个文件进行过修改提交时就会出现冲突(conflicts).\n此时通过`git status`查看产生冲突的文件, 手动选择需要保留的代码并提交即可.\n\n在使用GitKraken一类功能强大的可视化工具时可以很好的解决合并分支和冲突问题.\n\n但GitKranken只针对开源项目免费.\n\n也有一些免费的合并工具, 比如[P4Merge](https://www.perforce.com/zh-hans/chanpin/helix-core-apps/merge-diff-tool-p4merge)\n\n可以通过git全局设置来指定默认的合并工具\n\n```bash\ngit config --global merge.tool p4merge\ngit config --global mergetool.p4merge.path \"/Applications/p4merge.app/Contents/MacOS/p4merge\"\n```\n\n配置完成后, 当出现冲突时就可以直接使用`git mergetool`启动工具.\n\n如果希望中止合并, 可以直接使用命令`git merge --abort`.\n\n> p4merge会自动为冲突文件创建副本, 而git则会询问这一副本文件.\n>\n> 可以在`.gitignore`文件中添加备份文件`*.orig`\n>\n> 或直接通过全局配置禁用备份:\n>\n> ```bash\n> git config --global mergetool.keepBackup false\n> ```\n>\n{: .prompt-tip}\n\n### 撤销提交\n\n如果希望撤销一个提交, 可以通过命令 `git reset [mode] HEAD~1`完成.\n\n撤销命令存在三种模式:\n\n* `--soft`: 仅修改快照指针, 本地缓存(stage)和工作区不受影响\n* `--mixed`: 修改快照指针, 同时将指向的快照版本放入本地缓存, 工作区不受影响.\n* `--hard`: 修改快照指针, 同时将快照放入工作区, 相当于checkout.\n\n也可以通过`git revert HEAD`指令进行回退.\n\n### Rebase 重建分支\n\n在分支创建后, 如果主分支有新的提交, 可以将分支进行重建操作, 以使项目呈线性的提交历史.\n\n在分支下执行指令`git rebase master`即可.\n\n![rebase](/assets/img/img_202311182234203649.png)\n\n> rebase会修改项目的提交历史, 仅在本地, 不要在团队项目中使用.\n>\n{: .prompt-warning}\n","slug":"others-git-note","published":1,"updated":"2023-12-13T08:41:08.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5uu0001i3er63pvd6c7","content":"<h2 id=\"配置Git\"><a href=\"#配置Git\" class=\"headerlink\" title=\"配置Git\"></a>配置Git</h2><p><a href=\"https://git-scm.com/docs/git-config/zh_HANS-CN\">Git config 官方多语言文档</a></p>\n<ul>\n<li><p><code>git config --global core.editor &quot;code --wait&quot;</code>: 指定vscode作为全局编辑器.</p>\n</li>\n<li><p><code>git config --global diff.tool vscode</code>: 设置通过vscode查看文件变更.</p>\n</li>\n<li><p><code>git config --global difftool.vscode.cmd &quot;code --wait --diff $LOCAL $REMOTE&quot;</code>: 配置git打开vscode的命令参数.</p>\n</li>\n<li><p><code>git config --global -e</code>: 使用全局编辑器编辑配置文件.</p>\n</li>\n<li><p><code>git config --global core.autocrlf input</code>: 配置换行符</p>\n<blockquote>\n<p>windows的换行符是<code>\\r\\n</code>, 而mac是<code>\\n</code>, 如果配置错误就会在使用git时出现很多不必要的麻烦.</p>\n<ul>\n<li>Mac: <code>core.autocrlf input</code></li>\n<li>Win: <code>core.autocrlf true</code></li>\n</ul>\n<p>通常在git安装时会自动配置, 知道原理即可.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n</li>\n<li><p><code>git config --global init.defaultBranch &lt;name&gt;</code>: 设置git默认分支名称, 未设置默认为<code>master</code>, 但是初始化git时会有额外的提示信息.</p>\n</li>\n<li><p><code>git config --global alias.lg &quot;log --pretty=format:&#39;%an -&gt; %h&#39;&quot;</code>: 为git命令创建别名, 可以通过别名将复杂的git命令和参数进行简化.</p>\n<blockquote>\n<p><a href=\"https://git-scm.com/docs/git-log#_pretty_formats\">pretty fromat相关文档</a></p>\n<p>一个自用的简略信息:<code>%Cgreen%an&lt;%ae&gt;%Creset-&gt;%Cblue%h%Creset@%as:%Cred%s%Creset</code></p>\n</blockquote>\n<p>{: .prompt-info}</p>\n</li>\n<li><p><code>git config --global core.pager=cat</code>: 设置git命令的输出分页器, 默认使用less, 会将结果单独显示在一个屏幕中, 需要按<code>q</code>才能退出, 原始终端则没有内容. 改为<code>cat</code>则直接在当前命令行输出, 根据个人偏好配置即可.</p>\n</li>\n</ul>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h2 id=\"Git-命令行工具\"><a href=\"#Git-命令行工具\" class=\"headerlink\" title=\"Git 命令行工具\"></a>Git 命令行工具</h2><h3 id=\"仓库管理\"><a href=\"#仓库管理\" class=\"headerlink\" title=\"仓库管理\"></a>仓库管理</h3><ul>\n<li><p><code>git init</code>: 初始化git目录, 自动创建<code>.git</code>文件夹.</p>\n</li>\n<li><p><code>git status</code>: 查看当前git状态. 也可结合参数<code>-s</code>显示简略信息.</p>\n</li>\n<li><p><code>git add [option]</code>: 将变更内容添加到缓存区.</p>\n</li>\n<li><p><code>git commit -m&quot;commit message&quot;</code>: 提交到本地仓库.</p>\n<blockquote>\n<p>如果设置了git的全局编辑器, 可以直接使用<code>git commit</code>, 此时会使用指定的编辑器打开一个文本文件, 可以更为方便的输入提交描述.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n</li>\n<li><p><code>git commit -am &quot;commit message&quot;</code>: 跳过缓存, 直接将全部修改提交到本地仓库.</p>\n</li>\n</ul>\n<h3 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h3><ul>\n<li><code>git ls-files</code>: 显示git管理的文件.</li>\n<li><code>git rm [file]</code>: 在git和本地同时删除指定文件.</li>\n<li><code>git rm --cached [file]</code>: 仅删除git缓存的文件, 本地文件不受影响.</li>\n<li><code>git mv [file]</code>: 在本地和git中同时移动或者重命名文件.</li>\n<li><code>git restore [file]</code>: 将本地已有索引的文件恢复至修改前的状态.<ul>\n<li><code>--staged</code>: 将缓存区的内容回复至之前的状态.</li>\n<li><code>--source=[HEAD~n | id] filename</code>: 将修改或删除的文件恢复到之前提交的版本.</li>\n</ul>\n</li>\n<li><code>git clean</code>: 删除所有未创建索引的内容, 危险操作, 需要配合参数执行.<ul>\n<li><code>-f</code>: force强制执行</li>\n<li><code>-d</code>: 包含文件夹</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"源码管理\"><a href=\"#源码管理\" class=\"headerlink\" title=\"源码管理\"></a>源码管理</h3><ul>\n<li><code>git diff</code>: 显示缓存区与工作区的变动<ul>\n<li><code>--staged</code>: 查看缓存区的变动内容.</li>\n<li><code>HEAD~2 HEAD [filename]</code>: 查看最近3次的全部或特定文件的变化.</li>\n</ul>\n</li>\n<li><code>git log</code>: 显示提交记录<ul>\n<li><code>--oneline</code>: 显示提交记录摘要</li>\n<li><code>--reverse</code>: 逆序显示</li>\n</ul>\n</li>\n<li><code>git show</code>: 显示最后一次提交的变更内容<ul>\n<li><code>HEAD~n</code>: HEAD代表最后一次提交, <code>n</code>表示向前数n次, 比如<code>HEAD~n</code></li>\n<li>也可以通过log查看提交id, 通过指定id查看提交内容.</li>\n<li><code>HEAD:path/to/file</code>: 查看特定文件的变动.</li>\n<li><code>HEAD --name-status</code>: 查看更改的文件.</li>\n</ul>\n</li>\n<li><code>git checkout [id]</code>: 将工作区恢复至指定的快照id.<ul>\n<li><code>HEAD~n</code>: 向前数n个快照.</li>\n<li><code>master</code>: 设置为最新的快照.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"查找bug\"><a href=\"#查找bug\" class=\"headerlink\" title=\"查找bug\"></a>查找bug</h3><p>当一个快照出现问题, 而这个问题有可能是由于之前的快照索引的, 那么诸葛快照查找就会非常麻烦.</p>\n<p>为了这种情况, git 提供了一个强大的工具, <code>bisect</code>. bisection的缩写, 本质就是采用二分法查找出错的快照.</p>\n<ol>\n<li><code>git bisect start</code>: 开始二分查找</li>\n<li><code>git bisect bad</code>: 标记当前快照有问题, 通常在master快照下执行</li>\n<li><code>git bisect good [id | HEAD~n]</code>: 指定之前的一个确定没问题的快照, 此时bisect会自动帮助我们在不同的快照之间进行切换, 用以检查错误.</li>\n<li><code>git bisect good</code>: 标记当前检查的快照正常, bisect会自动切换至下一个快照</li>\n<li><code>git bisect bad</code>: 标记该快照为异常快照</li>\n<li><code>git bisect reset</code>: 退出bisect模式.</li>\n</ol>\n<h3 id=\"设置快照标签\"><a href=\"#设置快照标签\" class=\"headerlink\" title=\"设置快照标签\"></a>设置快照标签</h3><ul>\n<li><code>git tag v1.0.0</code>: 设置当前快照的标签为<code>v1.0.0</code></li>\n<li><code>git tag empty d873716 -m &quot;empty project&quot;</code>: 为指定id的快照添加empty标签, 同时设置标签信息.</li>\n<li><code>git checkout empty</code>: 根据标签checkout</li>\n<li><code>git tag -n</code>: 列出所有标签和标签信息.</li>\n<li><code>git tag --points-at &lt;id&gt;</code>: 列出指定或者当前快照的标签</li>\n<li><code>git tag -d [tagname]</code>: 删除标签</li>\n</ul>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h2 id=\"gitignore文件\"><a href=\"#gitignore文件\" class=\"headerlink\" title=\".gitignore文件\"></a>.gitignore文件</h2><p>在根目录下建立<code>.gitignore</code>文件用以配置忽略版本控制的文件.</p>\n<pre><code class=\"python\">logs/       # 忽略logs目录\nmain.log    # 忽略指定文件\n*.log       # 忽略匹配文件\n</code></pre>\n<blockquote>\n<p>对于已经加入git索引的内容不会受到<code>.gitignore</code>文件的影响.</p>\n<p>需要通过<code>git rm --cached</code>命令手动将其在索引中删除.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<p><a href=\"https://github.com/github/gitignore/tree/main\">.gitignore 模板仓库</a></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h2 id=\"Git可视化软件\"><a href=\"#Git可视化软件\" class=\"headerlink\" title=\"Git可视化软件\"></a>Git可视化软件</h2><p><a href=\"https://www.sourcetreeapp.com/\">Sourcetree</a>: 完全免费, 仅支持Windows和Mac.</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:580c367b-c240-453d-aa18-c7ced44324f9/hero-mac-screenshot.png?cdnVersion=1320\" alt=\"preview\"></p>\n<p><a href=\"https://www.gitkraken.com/\">GitKraken</a>: 针对开源软件项目免费. UI是相当的舒服~~</p>\n<p><img src=\"/assets/img/img_202311170358241255.png\" alt=\"preview\"></p>\n<p><img src=\"/assets/img/separator_3.png\" alt=\"sep\"></p>\n<h2 id=\"Git-分支管理\"><a href=\"#Git-分支管理\" class=\"headerlink\" title=\"Git 分支管理\"></a>Git 分支管理</h2><p>git的分支是一个指向<code>master</code>快照的指针, 并不会创建新的文件系统, 所以不会像svn一样产生额外的消耗.</p>\n<ul>\n<li><code>git branch bugfix</code>: 创建名为bugfix的分支</li>\n<li><code>git branch</code>: 列出所有分支</li>\n<li><code>git switch bugfix</code>: 切换到bugfix分支</li>\n<li><code>git switch -C bugfix</code>: 创建并切换到bugfix分支</li>\n<li><code>git branch -m bugfix bugfix-somebug</code>: 重命名分支</li>\n<li><code>git branch -d bugfix-somebug</code>: 删除指定分支, 如果分支存在未合并的内容则无法删除. 在确定删除的情况下可以使用<code>-D</code>强制执行.</li>\n<li><code>git branch --merged</code>: 显示已经合并的分支</li>\n<li><code>git branch --no-merged</code>: 显示尚未合并的分支</li>\n</ul>\n<h3 id=\"确定两个分支之间的不同\"><a href=\"#确定两个分支之间的不同\" class=\"headerlink\" title=\"确定两个分支之间的不同\"></a>确定两个分支之间的不同</h3><ul>\n<li><code>git log master..bugfix-somebug</code>: 显示分支之后的提交内容.</li>\n<li><code>git diff master..bugfix-somebug</code>: 显示两个分支之间的差异.<blockquote>\n<p>如果当前已经在master分之下, 可以省略<code>master..</code></p>\n</blockquote>\n{: .prompt-tip}</li>\n<li><code>git diff --name-only bugfix-somebug</code>: 显示有差异的文件.</li>\n<li><code>git diff --name-status bugfix-somebug</code>: 显示有差异的文件状态.<blockquote>\n<p>比较实用的命令, 可以创建两个别名, 比如<code>dno</code>,<code>dns</code></p>\n</blockquote>\n{: .prompt-tip}</li>\n</ul>\n<h3 id=\"通过stash缓存变动内容\"><a href=\"#通过stash缓存变动内容\" class=\"headerlink\" title=\"通过stash缓存变动内容\"></a>通过stash缓存变动内容</h3><p>在工作区发生了变动, 并且没有进行提交时, 如果需要切换到其他的分支, 可以将变动内容暂存以备之后使用.</p>\n<ul>\n<li><code>git stash push -m &quot;stash message&quot;</code>: 将工作区的变动内容移至暂存区.<ul>\n<li>如果工作区包含为索引的内容, 可以使用<code>-am</code>参数, 即<code>--all -m</code>.</li>\n</ul>\n</li>\n<li><code>git stash list</code>: 列出暂存区索引.</li>\n<li><code>git stash show n</code>: 显示第n条暂存内容的变更项.</li>\n<li><code>git stash apply n</code>: 取回暂存区的第n个索引.</li>\n<li><code>git stash drop n</code>: 删除第n项</li>\n<li><code>git stash clear</code>: 清空暂存区</li>\n</ul>\n<h3 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h3><p>合并分支大致分为两种情况:</p>\n<ol>\n<li><p>在分支修改完成后, 主分支没有发生变化, 此时可以直接让主分支指向当前分支. 成为Fast Forward.<br><img src=\"/assets/img/img_202311180514299621.png\" alt=\"ff\"></p>\n</li>\n<li><p>在分支代码修改完成后, 主分支有其他的提交, 此时则需要重新建立一个合并提交.<br><img src=\"/assets/img/img_202311180516007386.png\" alt=\"3wf\"></p>\n</li>\n</ol>\n<p>对于第一种情况来说, 合并分支非常简单, 只需要在<code>master</code>分支下执行合并命令即可;</p>\n<pre><code class=\"bash\">git merge bugfix-somebug\n</code></pre>\n<p>如果不希望使用<code>Fast Forward</code>可以添加参数<code>--no-ff</code>. 这样当前的master就会和分支合并为一个新的快照.</p>\n<p>有些公司会禁用FF合并, 因为这会让项目的演化信息丢失, 整个项目的研发路线成为一条支线. 如果在应用分之后希望退回之前的状态, 那么就需要找到建立分支时的快照.</p>\n<p>但不使用FF的情况下无论何时想要取消合并只需要回退一步就可以了.</p>\n<p>也可以通过git配置禁用FF从而省略关键字:</p>\n<pre><code class=\"bash\">git config merge.ff false # 当前工作区禁用\ngit config --global merge.ff false # 全局禁用\n</code></pre>\n<p>还有一种不太常用的合并方式, <code>git merge --squash branch</code>. 直译压缩合并.</p>\n<p>会将指定分支中的变动内容加入到当前分支, 可以直接使其为对当前分支的修改. 但本质上并没有将分支合并到主分支上.</p>\n<p>因此只适用于较小变动的分支, 且应当在合并操作之后将分支删除.</p>\n<p>因为虽然压缩合并已经将分支内容写入了主分支内, 但是通过<code>git branch --merged</code>命令查看已经合并的分支时不会显示压缩合并的分支. 这会产生歧义, 无法判断该分支是否已经被正确处理了.</p>\n<h3 id=\"解决合并冲突\"><a href=\"#解决合并冲突\" class=\"headerlink\" title=\"解决合并冲突\"></a>解决合并冲突</h3><p>当合并两个分支时, 如果他们对同一个文件进行过修改提交时就会出现冲突(conflicts).<br>此时通过<code>git status</code>查看产生冲突的文件, 手动选择需要保留的代码并提交即可.</p>\n<p>在使用GitKraken一类功能强大的可视化工具时可以很好的解决合并分支和冲突问题.</p>\n<p>但GitKranken只针对开源项目免费.</p>\n<p>也有一些免费的合并工具, 比如<a href=\"https://www.perforce.com/zh-hans/chanpin/helix-core-apps/merge-diff-tool-p4merge\">P4Merge</a></p>\n<p>可以通过git全局设置来指定默认的合并工具</p>\n<pre><code class=\"bash\">git config --global merge.tool p4merge\ngit config --global mergetool.p4merge.path &quot;/Applications/p4merge.app/Contents/MacOS/p4merge&quot;\n</code></pre>\n<p>配置完成后, 当出现冲突时就可以直接使用<code>git mergetool</code>启动工具.</p>\n<p>如果希望中止合并, 可以直接使用命令<code>git merge --abort</code>.</p>\n<blockquote>\n<p>p4merge会自动为冲突文件创建副本, 而git则会询问这一副本文件.</p>\n<p>可以在<code>.gitignore</code>文件中添加备份文件<code>*.orig</code></p>\n<p>或直接通过全局配置禁用备份:</p>\n<pre><code class=\"bash\">git config --global mergetool.keepBackup false\n</code></pre>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h3 id=\"撤销提交\"><a href=\"#撤销提交\" class=\"headerlink\" title=\"撤销提交\"></a>撤销提交</h3><p>如果希望撤销一个提交, 可以通过命令 <code>git reset [mode] HEAD~1</code>完成.</p>\n<p>撤销命令存在三种模式:</p>\n<ul>\n<li><code>--soft</code>: 仅修改快照指针, 本地缓存(stage)和工作区不受影响</li>\n<li><code>--mixed</code>: 修改快照指针, 同时将指向的快照版本放入本地缓存, 工作区不受影响.</li>\n<li><code>--hard</code>: 修改快照指针, 同时将快照放入工作区, 相当于checkout.</li>\n</ul>\n<p>也可以通过<code>git revert HEAD</code>指令进行回退.</p>\n<h3 id=\"Rebase-重建分支\"><a href=\"#Rebase-重建分支\" class=\"headerlink\" title=\"Rebase 重建分支\"></a>Rebase 重建分支</h3><p>在分支创建后, 如果主分支有新的提交, 可以将分支进行重建操作, 以使项目呈线性的提交历史.</p>\n<p>在分支下执行指令<code>git rebase master</code>即可.</p>\n<p><img src=\"/assets/img/img_202311182234203649.png\" alt=\"rebase\"></p>\n<blockquote>\n<p>rebase会修改项目的提交历史, 仅在本地, 不要在团队项目中使用.</p>\n</blockquote>\n<p>{: .prompt-warning}</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"配置Git\"><a href=\"#配置Git\" class=\"headerlink\" title=\"配置Git\"></a>配置Git</h2><p><a href=\"https://git-scm.com/docs/git-config/zh_HANS-CN\">Git config 官方多语言文档</a></p>\n<ul>\n<li><p><code>git config --global core.editor &quot;code --wait&quot;</code>: 指定vscode作为全局编辑器.</p>\n</li>\n<li><p><code>git config --global diff.tool vscode</code>: 设置通过vscode查看文件变更.</p>\n</li>\n<li><p><code>git config --global difftool.vscode.cmd &quot;code --wait --diff $LOCAL $REMOTE&quot;</code>: 配置git打开vscode的命令参数.</p>\n</li>\n<li><p><code>git config --global -e</code>: 使用全局编辑器编辑配置文件.</p>\n</li>\n<li><p><code>git config --global core.autocrlf input</code>: 配置换行符</p>\n<blockquote>\n<p>windows的换行符是<code>\\r\\n</code>, 而mac是<code>\\n</code>, 如果配置错误就会在使用git时出现很多不必要的麻烦.</p>\n<ul>\n<li>Mac: <code>core.autocrlf input</code></li>\n<li>Win: <code>core.autocrlf true</code></li>\n</ul>\n<p>通常在git安装时会自动配置, 知道原理即可.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n</li>\n<li><p><code>git config --global init.defaultBranch &lt;name&gt;</code>: 设置git默认分支名称, 未设置默认为<code>master</code>, 但是初始化git时会有额外的提示信息.</p>\n</li>\n<li><p><code>git config --global alias.lg &quot;log --pretty=format:&#39;%an -&gt; %h&#39;&quot;</code>: 为git命令创建别名, 可以通过别名将复杂的git命令和参数进行简化.</p>\n<blockquote>\n<p><a href=\"https://git-scm.com/docs/git-log#_pretty_formats\">pretty fromat相关文档</a></p>\n<p>一个自用的简略信息:<code>%Cgreen%an&lt;%ae&gt;%Creset-&gt;%Cblue%h%Creset@%as:%Cred%s%Creset</code></p>\n</blockquote>\n<p>{: .prompt-info}</p>\n</li>\n<li><p><code>git config --global core.pager=cat</code>: 设置git命令的输出分页器, 默认使用less, 会将结果单独显示在一个屏幕中, 需要按<code>q</code>才能退出, 原始终端则没有内容. 改为<code>cat</code>则直接在当前命令行输出, 根据个人偏好配置即可.</p>\n</li>\n</ul>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h2 id=\"Git-命令行工具\"><a href=\"#Git-命令行工具\" class=\"headerlink\" title=\"Git 命令行工具\"></a>Git 命令行工具</h2><h3 id=\"仓库管理\"><a href=\"#仓库管理\" class=\"headerlink\" title=\"仓库管理\"></a>仓库管理</h3><ul>\n<li><p><code>git init</code>: 初始化git目录, 自动创建<code>.git</code>文件夹.</p>\n</li>\n<li><p><code>git status</code>: 查看当前git状态. 也可结合参数<code>-s</code>显示简略信息.</p>\n</li>\n<li><p><code>git add [option]</code>: 将变更内容添加到缓存区.</p>\n</li>\n<li><p><code>git commit -m&quot;commit message&quot;</code>: 提交到本地仓库.</p>\n<blockquote>\n<p>如果设置了git的全局编辑器, 可以直接使用<code>git commit</code>, 此时会使用指定的编辑器打开一个文本文件, 可以更为方便的输入提交描述.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n</li>\n<li><p><code>git commit -am &quot;commit message&quot;</code>: 跳过缓存, 直接将全部修改提交到本地仓库.</p>\n</li>\n</ul>\n<h3 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h3><ul>\n<li><code>git ls-files</code>: 显示git管理的文件.</li>\n<li><code>git rm [file]</code>: 在git和本地同时删除指定文件.</li>\n<li><code>git rm --cached [file]</code>: 仅删除git缓存的文件, 本地文件不受影响.</li>\n<li><code>git mv [file]</code>: 在本地和git中同时移动或者重命名文件.</li>\n<li><code>git restore [file]</code>: 将本地已有索引的文件恢复至修改前的状态.<ul>\n<li><code>--staged</code>: 将缓存区的内容回复至之前的状态.</li>\n<li><code>--source=[HEAD~n | id] filename</code>: 将修改或删除的文件恢复到之前提交的版本.</li>\n</ul>\n</li>\n<li><code>git clean</code>: 删除所有未创建索引的内容, 危险操作, 需要配合参数执行.<ul>\n<li><code>-f</code>: force强制执行</li>\n<li><code>-d</code>: 包含文件夹</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"源码管理\"><a href=\"#源码管理\" class=\"headerlink\" title=\"源码管理\"></a>源码管理</h3><ul>\n<li><code>git diff</code>: 显示缓存区与工作区的变动<ul>\n<li><code>--staged</code>: 查看缓存区的变动内容.</li>\n<li><code>HEAD~2 HEAD [filename]</code>: 查看最近3次的全部或特定文件的变化.</li>\n</ul>\n</li>\n<li><code>git log</code>: 显示提交记录<ul>\n<li><code>--oneline</code>: 显示提交记录摘要</li>\n<li><code>--reverse</code>: 逆序显示</li>\n</ul>\n</li>\n<li><code>git show</code>: 显示最后一次提交的变更内容<ul>\n<li><code>HEAD~n</code>: HEAD代表最后一次提交, <code>n</code>表示向前数n次, 比如<code>HEAD~n</code></li>\n<li>也可以通过log查看提交id, 通过指定id查看提交内容.</li>\n<li><code>HEAD:path/to/file</code>: 查看特定文件的变动.</li>\n<li><code>HEAD --name-status</code>: 查看更改的文件.</li>\n</ul>\n</li>\n<li><code>git checkout [id]</code>: 将工作区恢复至指定的快照id.<ul>\n<li><code>HEAD~n</code>: 向前数n个快照.</li>\n<li><code>master</code>: 设置为最新的快照.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"查找bug\"><a href=\"#查找bug\" class=\"headerlink\" title=\"查找bug\"></a>查找bug</h3><p>当一个快照出现问题, 而这个问题有可能是由于之前的快照索引的, 那么诸葛快照查找就会非常麻烦.</p>\n<p>为了这种情况, git 提供了一个强大的工具, <code>bisect</code>. bisection的缩写, 本质就是采用二分法查找出错的快照.</p>\n<ol>\n<li><code>git bisect start</code>: 开始二分查找</li>\n<li><code>git bisect bad</code>: 标记当前快照有问题, 通常在master快照下执行</li>\n<li><code>git bisect good [id | HEAD~n]</code>: 指定之前的一个确定没问题的快照, 此时bisect会自动帮助我们在不同的快照之间进行切换, 用以检查错误.</li>\n<li><code>git bisect good</code>: 标记当前检查的快照正常, bisect会自动切换至下一个快照</li>\n<li><code>git bisect bad</code>: 标记该快照为异常快照</li>\n<li><code>git bisect reset</code>: 退出bisect模式.</li>\n</ol>\n<h3 id=\"设置快照标签\"><a href=\"#设置快照标签\" class=\"headerlink\" title=\"设置快照标签\"></a>设置快照标签</h3><ul>\n<li><code>git tag v1.0.0</code>: 设置当前快照的标签为<code>v1.0.0</code></li>\n<li><code>git tag empty d873716 -m &quot;empty project&quot;</code>: 为指定id的快照添加empty标签, 同时设置标签信息.</li>\n<li><code>git checkout empty</code>: 根据标签checkout</li>\n<li><code>git tag -n</code>: 列出所有标签和标签信息.</li>\n<li><code>git tag --points-at &lt;id&gt;</code>: 列出指定或者当前快照的标签</li>\n<li><code>git tag -d [tagname]</code>: 删除标签</li>\n</ul>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h2 id=\"gitignore文件\"><a href=\"#gitignore文件\" class=\"headerlink\" title=\".gitignore文件\"></a>.gitignore文件</h2><p>在根目录下建立<code>.gitignore</code>文件用以配置忽略版本控制的文件.</p>\n<pre><code class=\"python\">logs/       # 忽略logs目录\nmain.log    # 忽略指定文件\n*.log       # 忽略匹配文件\n</code></pre>\n<blockquote>\n<p>对于已经加入git索引的内容不会受到<code>.gitignore</code>文件的影响.</p>\n<p>需要通过<code>git rm --cached</code>命令手动将其在索引中删除.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<p><a href=\"https://github.com/github/gitignore/tree/main\">.gitignore 模板仓库</a></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h2 id=\"Git可视化软件\"><a href=\"#Git可视化软件\" class=\"headerlink\" title=\"Git可视化软件\"></a>Git可视化软件</h2><p><a href=\"https://www.sourcetreeapp.com/\">Sourcetree</a>: 完全免费, 仅支持Windows和Mac.</p>\n<p><img src=\"https://wac-cdn.atlassian.com/dam/jcr:580c367b-c240-453d-aa18-c7ced44324f9/hero-mac-screenshot.png?cdnVersion=1320\" alt=\"preview\"></p>\n<p><a href=\"https://www.gitkraken.com/\">GitKraken</a>: 针对开源软件项目免费. UI是相当的舒服~~</p>\n<p><img src=\"/assets/img/img_202311170358241255.png\" alt=\"preview\"></p>\n<p><img src=\"/assets/img/separator_3.png\" alt=\"sep\"></p>\n<h2 id=\"Git-分支管理\"><a href=\"#Git-分支管理\" class=\"headerlink\" title=\"Git 分支管理\"></a>Git 分支管理</h2><p>git的分支是一个指向<code>master</code>快照的指针, 并不会创建新的文件系统, 所以不会像svn一样产生额外的消耗.</p>\n<ul>\n<li><code>git branch bugfix</code>: 创建名为bugfix的分支</li>\n<li><code>git branch</code>: 列出所有分支</li>\n<li><code>git switch bugfix</code>: 切换到bugfix分支</li>\n<li><code>git switch -C bugfix</code>: 创建并切换到bugfix分支</li>\n<li><code>git branch -m bugfix bugfix-somebug</code>: 重命名分支</li>\n<li><code>git branch -d bugfix-somebug</code>: 删除指定分支, 如果分支存在未合并的内容则无法删除. 在确定删除的情况下可以使用<code>-D</code>强制执行.</li>\n<li><code>git branch --merged</code>: 显示已经合并的分支</li>\n<li><code>git branch --no-merged</code>: 显示尚未合并的分支</li>\n</ul>\n<h3 id=\"确定两个分支之间的不同\"><a href=\"#确定两个分支之间的不同\" class=\"headerlink\" title=\"确定两个分支之间的不同\"></a>确定两个分支之间的不同</h3><ul>\n<li><code>git log master..bugfix-somebug</code>: 显示分支之后的提交内容.</li>\n<li><code>git diff master..bugfix-somebug</code>: 显示两个分支之间的差异.<blockquote>\n<p>如果当前已经在master分之下, 可以省略<code>master..</code></p>\n</blockquote>\n{: .prompt-tip}</li>\n<li><code>git diff --name-only bugfix-somebug</code>: 显示有差异的文件.</li>\n<li><code>git diff --name-status bugfix-somebug</code>: 显示有差异的文件状态.<blockquote>\n<p>比较实用的命令, 可以创建两个别名, 比如<code>dno</code>,<code>dns</code></p>\n</blockquote>\n{: .prompt-tip}</li>\n</ul>\n<h3 id=\"通过stash缓存变动内容\"><a href=\"#通过stash缓存变动内容\" class=\"headerlink\" title=\"通过stash缓存变动内容\"></a>通过stash缓存变动内容</h3><p>在工作区发生了变动, 并且没有进行提交时, 如果需要切换到其他的分支, 可以将变动内容暂存以备之后使用.</p>\n<ul>\n<li><code>git stash push -m &quot;stash message&quot;</code>: 将工作区的变动内容移至暂存区.<ul>\n<li>如果工作区包含为索引的内容, 可以使用<code>-am</code>参数, 即<code>--all -m</code>.</li>\n</ul>\n</li>\n<li><code>git stash list</code>: 列出暂存区索引.</li>\n<li><code>git stash show n</code>: 显示第n条暂存内容的变更项.</li>\n<li><code>git stash apply n</code>: 取回暂存区的第n个索引.</li>\n<li><code>git stash drop n</code>: 删除第n项</li>\n<li><code>git stash clear</code>: 清空暂存区</li>\n</ul>\n<h3 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h3><p>合并分支大致分为两种情况:</p>\n<ol>\n<li><p>在分支修改完成后, 主分支没有发生变化, 此时可以直接让主分支指向当前分支. 成为Fast Forward.<br><img src=\"/assets/img/img_202311180514299621.png\" alt=\"ff\"></p>\n</li>\n<li><p>在分支代码修改完成后, 主分支有其他的提交, 此时则需要重新建立一个合并提交.<br><img src=\"/assets/img/img_202311180516007386.png\" alt=\"3wf\"></p>\n</li>\n</ol>\n<p>对于第一种情况来说, 合并分支非常简单, 只需要在<code>master</code>分支下执行合并命令即可;</p>\n<pre><code class=\"bash\">git merge bugfix-somebug\n</code></pre>\n<p>如果不希望使用<code>Fast Forward</code>可以添加参数<code>--no-ff</code>. 这样当前的master就会和分支合并为一个新的快照.</p>\n<p>有些公司会禁用FF合并, 因为这会让项目的演化信息丢失, 整个项目的研发路线成为一条支线. 如果在应用分之后希望退回之前的状态, 那么就需要找到建立分支时的快照.</p>\n<p>但不使用FF的情况下无论何时想要取消合并只需要回退一步就可以了.</p>\n<p>也可以通过git配置禁用FF从而省略关键字:</p>\n<pre><code class=\"bash\">git config merge.ff false # 当前工作区禁用\ngit config --global merge.ff false # 全局禁用\n</code></pre>\n<p>还有一种不太常用的合并方式, <code>git merge --squash branch</code>. 直译压缩合并.</p>\n<p>会将指定分支中的变动内容加入到当前分支, 可以直接使其为对当前分支的修改. 但本质上并没有将分支合并到主分支上.</p>\n<p>因此只适用于较小变动的分支, 且应当在合并操作之后将分支删除.</p>\n<p>因为虽然压缩合并已经将分支内容写入了主分支内, 但是通过<code>git branch --merged</code>命令查看已经合并的分支时不会显示压缩合并的分支. 这会产生歧义, 无法判断该分支是否已经被正确处理了.</p>\n<h3 id=\"解决合并冲突\"><a href=\"#解决合并冲突\" class=\"headerlink\" title=\"解决合并冲突\"></a>解决合并冲突</h3><p>当合并两个分支时, 如果他们对同一个文件进行过修改提交时就会出现冲突(conflicts).<br>此时通过<code>git status</code>查看产生冲突的文件, 手动选择需要保留的代码并提交即可.</p>\n<p>在使用GitKraken一类功能强大的可视化工具时可以很好的解决合并分支和冲突问题.</p>\n<p>但GitKranken只针对开源项目免费.</p>\n<p>也有一些免费的合并工具, 比如<a href=\"https://www.perforce.com/zh-hans/chanpin/helix-core-apps/merge-diff-tool-p4merge\">P4Merge</a></p>\n<p>可以通过git全局设置来指定默认的合并工具</p>\n<pre><code class=\"bash\">git config --global merge.tool p4merge\ngit config --global mergetool.p4merge.path &quot;/Applications/p4merge.app/Contents/MacOS/p4merge&quot;\n</code></pre>\n<p>配置完成后, 当出现冲突时就可以直接使用<code>git mergetool</code>启动工具.</p>\n<p>如果希望中止合并, 可以直接使用命令<code>git merge --abort</code>.</p>\n<blockquote>\n<p>p4merge会自动为冲突文件创建副本, 而git则会询问这一副本文件.</p>\n<p>可以在<code>.gitignore</code>文件中添加备份文件<code>*.orig</code></p>\n<p>或直接通过全局配置禁用备份:</p>\n<pre><code class=\"bash\">git config --global mergetool.keepBackup false\n</code></pre>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h3 id=\"撤销提交\"><a href=\"#撤销提交\" class=\"headerlink\" title=\"撤销提交\"></a>撤销提交</h3><p>如果希望撤销一个提交, 可以通过命令 <code>git reset [mode] HEAD~1</code>完成.</p>\n<p>撤销命令存在三种模式:</p>\n<ul>\n<li><code>--soft</code>: 仅修改快照指针, 本地缓存(stage)和工作区不受影响</li>\n<li><code>--mixed</code>: 修改快照指针, 同时将指向的快照版本放入本地缓存, 工作区不受影响.</li>\n<li><code>--hard</code>: 修改快照指针, 同时将快照放入工作区, 相当于checkout.</li>\n</ul>\n<p>也可以通过<code>git revert HEAD</code>指令进行回退.</p>\n<h3 id=\"Rebase-重建分支\"><a href=\"#Rebase-重建分支\" class=\"headerlink\" title=\"Rebase 重建分支\"></a>Rebase 重建分支</h3><p>在分支创建后, 如果主分支有新的提交, 可以将分支进行重建操作, 以使项目呈线性的提交历史.</p>\n<p>在分支下执行指令<code>git rebase master</code>即可.</p>\n<p><img src=\"/assets/img/img_202311182234203649.png\" alt=\"rebase\"></p>\n<blockquote>\n<p>rebase会修改项目的提交历史, 仅在本地, 不要在团队项目中使用.</p>\n</blockquote>\n<p>{: .prompt-warning}</p>\n"},{"title":"使用jekyll框架基于chirpy主题与gitee建站","date":"2023-12-13T08:41:08.350Z","_content":"\n## 选择模板\n\njekyll框架存有很多优质模板, 可以在以下链接查阅:\n[http://jekyllthemes.org/](http://jekyllthemes.org/)\n\n本次建站是用[jekyll-theme-chirpy](https://github.com/cotes2020/jekyll-theme-chirpy.git)主题.\n\n由于主题本身基于`Node.js`制作, 需要提前安装[Node.js](https://nodejs.org/en)\n\n在`Gitee`中创建仓库,并从Github中导入`jekyll-theme-chirpy`, 导入时可以直接改名为自己希望的名字, 随后克隆到本地\n\n```bash\ngit clone https://gitee.com/nestalk/noteblog.git\ncd noteblog\n```\n\n运行主题初始化脚本, 自动移除不相关的示例文件以及Git配置, 创建项目所需的js文件\n\n```bash\nbash tools/init\n```\n\n运行bundle安装依赖:\n\n```bash\nbundle \n```\n\n启动本地服务:\n\n```bash\nbundle exec jekyll serve\n```\n\n## 配置主题\n\n`_config.yml`:\n\n```yml\nlang: zh-CN\ntitle: Nestor's noteblog # the main title\ntagline: Design can be art.<br/> Design can be simple.<br/> That's why it's so complicated. # it will display as the sub-title\ndescription: >- # used by seo meta and the atom feed\n  技术学习笔记, 如: Python, Django等等. 以及个人博客文章.\nsocial:\n  # Change to your full name.\n  # It will be displayed as the default author of the posts and the copyright owner in the Footer\n  name: Nestor\n  email: admin@nestor.me # change to your email address\n  links:\n    # The first element serves as the copyright owner's link\n    - https://gitee.com/nestalk # change to your github homepage\n    - https://weibo.com/u/1239998601 # change to your twitter homepage  \ntheme_mode: dark # [light|dark]    \navatar: /assets/img/avatar.png\n```\n\n关于分享的一些设置还没研究透, 留下几个问题:\n\n* git链接 -> gitee链接\n* Twitter -> weibo\n\n## 添加文章\n\n添加文章始终应该在`_post`目录下, 直接创建文件即可, 不需要额外的文件夹.\n但是文件的命名规则是固定的:\n\n`YYYY-MM-DD-TITLE.md`\n\n### 添加头文件\n\n```yaml\n---\ntitle: TITLE\ndate: YYYY-MM-DD HH:MM:SS +/-TTTT\ncategories: [TOP_CATEGORIE, SUB_CATEGORIE]\ntags: [TAG]     # TAG names should always be lowercase\n---\n```\n\n* `categories` 最多包含两项, 但是`tag`几个都行\n* `math`: 数学公式功能, 出于性能因素默认关闭, 但是可以在需要的页面上手动打开 `math: true`, 基于`LaTex_math`实现, 相关[拓展资料](https://www.jianshu.com/p/0ea47ae02262)\n* `toc`: 是否显示目录, 默认为`true`, 可以手动设置为`false`, 一般没必要关闭.\n* `comments`: 是否开启评论功能, 如果开启需要一个支持评论的后台系统, 需要的时候在研究. 对于已有评论系统的可以手动设置`false`关闭\n* `mermaid`: 流程图插件, 需要使用时标记为`true`即可, [mermaid文档](http://mermaid.js.org/intro/)\n* `img_path`: 当前md文件中的所有图片都基于该路径进行查找\n* `images:`: 封面图, 可以为当前文章添加一个封面图片, 要求尺寸为`1200 * 630`, 可以仅提供一个路径, 或者进行完整设置:\n\n```yaml\n---\nimage:\n    path: /path/to/image\n    alt: image alternative text\n---\n```\n\n* `pin`: 是否置顶文章\n\n为了简化操作, 在vscode中制作了一个专门的code snippet来解决这一问题:\n\n``` json\n    \"front matter for markdown\" : {\n        \"scope\": \"markdown, md\",\n        \"prefix\": \"matter\",\n        \"body\": [\n            \"---\",\n            \"title: '${1: title}'\",\n            \"date: '${2: YYYY-MM-DD HH:MM:SS}' +08000\",\n            \"categories: ['${3: first category, second category}']\",\n            \"tags: ['${4: tags}']\",\n            \"---\"\n        ],\n        \"description\": \"Generate Front Matter data for jekyll markdown post files.\"\n    }\n```\n\n### 调整图片\n\n设置图片标题:\n\n```markdown\n![img-description](/path/to/image)\n_Image Caption_\n```\n\n设置图片大小:\n\n```markdown\n![Desktop View](/assets/img/sample/mockup.png){: width=\"700\" height=\"400\" }\n或者\n![Desktop View](/assets/img/sample/mockup.png){: w=\"700\" h=\"400\" }\n```\n\n调整图片位置:\n\n```markdown\n![Desktop View](/assets/img/sample/mockup.png){: .normal }\n![Desktop View](/assets/img/sample/mockup.png){: .left }\n![Desktop View](/assets/img/sample/mockup.png){: .right }\n```\n\n明暗适配:\n\n```markdown\n![Light mode only](/path/to/light-mode.png){: .light }\n![Dark mode only](/path/to/dark-mode.png){: .dark }\n```\n\n添加阴影:\n\n```markdown\n![Desktop View](/assets/img/sample/mockup.png){: .shadow }\n```\n\n### 提示信息\n\nChirpy集成了Prompts插件, 可以为段落引用添加样式, 如:\n\n```markdown\n> Example line for prompt.\n{: .prompt-info }\n```\n\n可选的提示样式包括`tip`, `info`, `warning`, `danger`\n\n### 修改Favicon\n\n[Favicon在线制作工具](https://realfavicongenerator.net)\n\n上传一个正方形图片后会生成一个favicons文件夹, 下载后删除解压包中的文件:\n\n* browserconfig.xml\n* site.webmanifest\n\n将剩余的图片复制到`/assets/img/favicons`文件夹下进行覆盖即可.\n","source":"_posts/others/jekyll-chirpy-gitee.md","raw":"---\ntitle: 使用jekyll框架基于chirpy主题与gitee建站\ndate: 2023-11-11 14:04:24 +08000\ncategories: [笔记, jekyll]\ntags: [jekyll, gitee]\n---\n\n## 选择模板\n\njekyll框架存有很多优质模板, 可以在以下链接查阅:\n[http://jekyllthemes.org/](http://jekyllthemes.org/)\n\n本次建站是用[jekyll-theme-chirpy](https://github.com/cotes2020/jekyll-theme-chirpy.git)主题.\n\n由于主题本身基于`Node.js`制作, 需要提前安装[Node.js](https://nodejs.org/en)\n\n在`Gitee`中创建仓库,并从Github中导入`jekyll-theme-chirpy`, 导入时可以直接改名为自己希望的名字, 随后克隆到本地\n\n```bash\ngit clone https://gitee.com/nestalk/noteblog.git\ncd noteblog\n```\n\n运行主题初始化脚本, 自动移除不相关的示例文件以及Git配置, 创建项目所需的js文件\n\n```bash\nbash tools/init\n```\n\n运行bundle安装依赖:\n\n```bash\nbundle \n```\n\n启动本地服务:\n\n```bash\nbundle exec jekyll serve\n```\n\n## 配置主题\n\n`_config.yml`:\n\n```yml\nlang: zh-CN\ntitle: Nestor's noteblog # the main title\ntagline: Design can be art.<br/> Design can be simple.<br/> That's why it's so complicated. # it will display as the sub-title\ndescription: >- # used by seo meta and the atom feed\n  技术学习笔记, 如: Python, Django等等. 以及个人博客文章.\nsocial:\n  # Change to your full name.\n  # It will be displayed as the default author of the posts and the copyright owner in the Footer\n  name: Nestor\n  email: admin@nestor.me # change to your email address\n  links:\n    # The first element serves as the copyright owner's link\n    - https://gitee.com/nestalk # change to your github homepage\n    - https://weibo.com/u/1239998601 # change to your twitter homepage  \ntheme_mode: dark # [light|dark]    \navatar: /assets/img/avatar.png\n```\n\n关于分享的一些设置还没研究透, 留下几个问题:\n\n* git链接 -> gitee链接\n* Twitter -> weibo\n\n## 添加文章\n\n添加文章始终应该在`_post`目录下, 直接创建文件即可, 不需要额外的文件夹.\n但是文件的命名规则是固定的:\n\n`YYYY-MM-DD-TITLE.md`\n\n### 添加头文件\n\n```yaml\n---\ntitle: TITLE\ndate: YYYY-MM-DD HH:MM:SS +/-TTTT\ncategories: [TOP_CATEGORIE, SUB_CATEGORIE]\ntags: [TAG]     # TAG names should always be lowercase\n---\n```\n\n* `categories` 最多包含两项, 但是`tag`几个都行\n* `math`: 数学公式功能, 出于性能因素默认关闭, 但是可以在需要的页面上手动打开 `math: true`, 基于`LaTex_math`实现, 相关[拓展资料](https://www.jianshu.com/p/0ea47ae02262)\n* `toc`: 是否显示目录, 默认为`true`, 可以手动设置为`false`, 一般没必要关闭.\n* `comments`: 是否开启评论功能, 如果开启需要一个支持评论的后台系统, 需要的时候在研究. 对于已有评论系统的可以手动设置`false`关闭\n* `mermaid`: 流程图插件, 需要使用时标记为`true`即可, [mermaid文档](http://mermaid.js.org/intro/)\n* `img_path`: 当前md文件中的所有图片都基于该路径进行查找\n* `images:`: 封面图, 可以为当前文章添加一个封面图片, 要求尺寸为`1200 * 630`, 可以仅提供一个路径, 或者进行完整设置:\n\n```yaml\n---\nimage:\n    path: /path/to/image\n    alt: image alternative text\n---\n```\n\n* `pin`: 是否置顶文章\n\n为了简化操作, 在vscode中制作了一个专门的code snippet来解决这一问题:\n\n``` json\n    \"front matter for markdown\" : {\n        \"scope\": \"markdown, md\",\n        \"prefix\": \"matter\",\n        \"body\": [\n            \"---\",\n            \"title: '${1: title}'\",\n            \"date: '${2: YYYY-MM-DD HH:MM:SS}' +08000\",\n            \"categories: ['${3: first category, second category}']\",\n            \"tags: ['${4: tags}']\",\n            \"---\"\n        ],\n        \"description\": \"Generate Front Matter data for jekyll markdown post files.\"\n    }\n```\n\n### 调整图片\n\n设置图片标题:\n\n```markdown\n![img-description](/path/to/image)\n_Image Caption_\n```\n\n设置图片大小:\n\n```markdown\n![Desktop View](/assets/img/sample/mockup.png){: width=\"700\" height=\"400\" }\n或者\n![Desktop View](/assets/img/sample/mockup.png){: w=\"700\" h=\"400\" }\n```\n\n调整图片位置:\n\n```markdown\n![Desktop View](/assets/img/sample/mockup.png){: .normal }\n![Desktop View](/assets/img/sample/mockup.png){: .left }\n![Desktop View](/assets/img/sample/mockup.png){: .right }\n```\n\n明暗适配:\n\n```markdown\n![Light mode only](/path/to/light-mode.png){: .light }\n![Dark mode only](/path/to/dark-mode.png){: .dark }\n```\n\n添加阴影:\n\n```markdown\n![Desktop View](/assets/img/sample/mockup.png){: .shadow }\n```\n\n### 提示信息\n\nChirpy集成了Prompts插件, 可以为段落引用添加样式, 如:\n\n```markdown\n> Example line for prompt.\n{: .prompt-info }\n```\n\n可选的提示样式包括`tip`, `info`, `warning`, `danger`\n\n### 修改Favicon\n\n[Favicon在线制作工具](https://realfavicongenerator.net)\n\n上传一个正方形图片后会生成一个favicons文件夹, 下载后删除解压包中的文件:\n\n* browserconfig.xml\n* site.webmanifest\n\n将剩余的图片复制到`/assets/img/favicons`文件夹下进行覆盖即可.\n","slug":"others-jekyll-chirpy-gitee","published":1,"updated":"2023-12-13T08:41:08.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5uv0004i3er49x8foyu","content":"<h2 id=\"选择模板\"><a href=\"#选择模板\" class=\"headerlink\" title=\"选择模板\"></a>选择模板</h2><p>jekyll框架存有很多优质模板, 可以在以下链接查阅:<br><a href=\"http://jekyllthemes.org/\">http://jekyllthemes.org/</a></p>\n<p>本次建站是用<a href=\"https://github.com/cotes2020/jekyll-theme-chirpy.git\">jekyll-theme-chirpy</a>主题.</p>\n<p>由于主题本身基于<code>Node.js</code>制作, 需要提前安装<a href=\"https://nodejs.org/en\">Node.js</a></p>\n<p>在<code>Gitee</code>中创建仓库,并从Github中导入<code>jekyll-theme-chirpy</code>, 导入时可以直接改名为自己希望的名字, 随后克隆到本地</p>\n<pre><code class=\"bash\">git clone https://gitee.com/nestalk/noteblog.git\ncd noteblog\n</code></pre>\n<p>运行主题初始化脚本, 自动移除不相关的示例文件以及Git配置, 创建项目所需的js文件</p>\n<pre><code class=\"bash\">bash tools/init\n</code></pre>\n<p>运行bundle安装依赖:</p>\n<pre><code class=\"bash\">bundle \n</code></pre>\n<p>启动本地服务:</p>\n<pre><code class=\"bash\">bundle exec jekyll serve\n</code></pre>\n<h2 id=\"配置主题\"><a href=\"#配置主题\" class=\"headerlink\" title=\"配置主题\"></a>配置主题</h2><p><code>_config.yml</code>:</p>\n<pre><code class=\"yml\">lang: zh-CN\ntitle: Nestor&#39;s noteblog # the main title\ntagline: Design can be art.&lt;br/&gt; Design can be simple.&lt;br/&gt; That&#39;s why it&#39;s so complicated. # it will display as the sub-title\ndescription: &gt;- # used by seo meta and the atom feed\n  技术学习笔记, 如: Python, Django等等. 以及个人博客文章.\nsocial:\n  # Change to your full name.\n  # It will be displayed as the default author of the posts and the copyright owner in the Footer\n  name: Nestor\n  email: admin@nestor.me # change to your email address\n  links:\n    # The first element serves as the copyright owner&#39;s link\n    - https://gitee.com/nestalk # change to your github homepage\n    - https://weibo.com/u/1239998601 # change to your twitter homepage  \ntheme_mode: dark # [light|dark]    \navatar: /assets/img/avatar.png\n</code></pre>\n<p>关于分享的一些设置还没研究透, 留下几个问题:</p>\n<ul>\n<li>git链接 -&gt; gitee链接</li>\n<li>Twitter -&gt; weibo</li>\n</ul>\n<h2 id=\"添加文章\"><a href=\"#添加文章\" class=\"headerlink\" title=\"添加文章\"></a>添加文章</h2><p>添加文章始终应该在<code>_post</code>目录下, 直接创建文件即可, 不需要额外的文件夹.<br>但是文件的命名规则是固定的:</p>\n<p><code>YYYY-MM-DD-TITLE.md</code></p>\n<h3 id=\"添加头文件\"><a href=\"#添加头文件\" class=\"headerlink\" title=\"添加头文件\"></a>添加头文件</h3><pre><code class=\"yaml\">---\ntitle: TITLE\ndate: YYYY-MM-DD HH:MM:SS +/-TTTT\ncategories: [TOP_CATEGORIE, SUB_CATEGORIE]\ntags: [TAG]     # TAG names should always be lowercase\n---\n</code></pre>\n<ul>\n<li><code>categories</code> 最多包含两项, 但是<code>tag</code>几个都行</li>\n<li><code>math</code>: 数学公式功能, 出于性能因素默认关闭, 但是可以在需要的页面上手动打开 <code>math: true</code>, 基于<code>LaTex_math</code>实现, 相关<a href=\"https://www.jianshu.com/p/0ea47ae02262\">拓展资料</a></li>\n<li><code>toc</code>: 是否显示目录, 默认为<code>true</code>, 可以手动设置为<code>false</code>, 一般没必要关闭.</li>\n<li><code>comments</code>: 是否开启评论功能, 如果开启需要一个支持评论的后台系统, 需要的时候在研究. 对于已有评论系统的可以手动设置<code>false</code>关闭</li>\n<li><code>mermaid</code>: 流程图插件, 需要使用时标记为<code>true</code>即可, <a href=\"http://mermaid.js.org/intro/\">mermaid文档</a></li>\n<li><code>img_path</code>: 当前md文件中的所有图片都基于该路径进行查找</li>\n<li><code>images:</code>: 封面图, 可以为当前文章添加一个封面图片, 要求尺寸为<code>1200 * 630</code>, 可以仅提供一个路径, 或者进行完整设置:</li>\n</ul>\n<pre><code class=\"yaml\">---\nimage:\n    path: /path/to/image\n    alt: image alternative text\n---\n</code></pre>\n<ul>\n<li><code>pin</code>: 是否置顶文章</li>\n</ul>\n<p>为了简化操作, 在vscode中制作了一个专门的code snippet来解决这一问题:</p>\n<pre><code class=\"json\">    &quot;front matter for markdown&quot; : &#123;\n        &quot;scope&quot;: &quot;markdown, md&quot;,\n        &quot;prefix&quot;: &quot;matter&quot;,\n        &quot;body&quot;: [\n            &quot;---&quot;,\n            &quot;title: &#39;$&#123;1: title&#125;&#39;&quot;,\n            &quot;date: &#39;$&#123;2: YYYY-MM-DD HH:MM:SS&#125;&#39; +08000&quot;,\n            &quot;categories: [&#39;$&#123;3: first category, second category&#125;&#39;]&quot;,\n            &quot;tags: [&#39;$&#123;4: tags&#125;&#39;]&quot;,\n            &quot;---&quot;\n        ],\n        &quot;description&quot;: &quot;Generate Front Matter data for jekyll markdown post files.&quot;\n    &#125;\n</code></pre>\n<h3 id=\"调整图片\"><a href=\"#调整图片\" class=\"headerlink\" title=\"调整图片\"></a>调整图片</h3><p>设置图片标题:</p>\n<pre><code class=\"markdown\">![img-description](/path/to/image)\n_Image Caption_\n</code></pre>\n<p>设置图片大小:</p>\n<pre><code class=\"markdown\">![Desktop View](/assets/img/sample/mockup.png)&#123;: width=&quot;700&quot; height=&quot;400&quot; &#125;\n或者\n![Desktop View](/assets/img/sample/mockup.png)&#123;: w=&quot;700&quot; h=&quot;400&quot; &#125;\n</code></pre>\n<p>调整图片位置:</p>\n<pre><code class=\"markdown\">![Desktop View](/assets/img/sample/mockup.png)&#123;: .normal &#125;\n![Desktop View](/assets/img/sample/mockup.png)&#123;: .left &#125;\n![Desktop View](/assets/img/sample/mockup.png)&#123;: .right &#125;\n</code></pre>\n<p>明暗适配:</p>\n<pre><code class=\"markdown\">![Light mode only](/path/to/light-mode.png)&#123;: .light &#125;\n![Dark mode only](/path/to/dark-mode.png)&#123;: .dark &#125;\n</code></pre>\n<p>添加阴影:</p>\n<pre><code class=\"markdown\">![Desktop View](/assets/img/sample/mockup.png)&#123;: .shadow &#125;\n</code></pre>\n<h3 id=\"提示信息\"><a href=\"#提示信息\" class=\"headerlink\" title=\"提示信息\"></a>提示信息</h3><p>Chirpy集成了Prompts插件, 可以为段落引用添加样式, 如:</p>\n<pre><code class=\"markdown\">&gt; Example line for prompt.\n&#123;: .prompt-info &#125;\n</code></pre>\n<p>可选的提示样式包括<code>tip</code>, <code>info</code>, <code>warning</code>, <code>danger</code></p>\n<h3 id=\"修改Favicon\"><a href=\"#修改Favicon\" class=\"headerlink\" title=\"修改Favicon\"></a>修改Favicon</h3><p><a href=\"https://realfavicongenerator.net/\">Favicon在线制作工具</a></p>\n<p>上传一个正方形图片后会生成一个favicons文件夹, 下载后删除解压包中的文件:</p>\n<ul>\n<li>browserconfig.xml</li>\n<li>site.webmanifest</li>\n</ul>\n<p>将剩余的图片复制到<code>/assets/img/favicons</code>文件夹下进行覆盖即可.</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"选择模板\"><a href=\"#选择模板\" class=\"headerlink\" title=\"选择模板\"></a>选择模板</h2><p>jekyll框架存有很多优质模板, 可以在以下链接查阅:<br><a href=\"http://jekyllthemes.org/\">http://jekyllthemes.org/</a></p>\n<p>本次建站是用<a href=\"https://github.com/cotes2020/jekyll-theme-chirpy.git\">jekyll-theme-chirpy</a>主题.</p>\n<p>由于主题本身基于<code>Node.js</code>制作, 需要提前安装<a href=\"https://nodejs.org/en\">Node.js</a></p>\n<p>在<code>Gitee</code>中创建仓库,并从Github中导入<code>jekyll-theme-chirpy</code>, 导入时可以直接改名为自己希望的名字, 随后克隆到本地</p>\n<pre><code class=\"bash\">git clone https://gitee.com/nestalk/noteblog.git\ncd noteblog\n</code></pre>\n<p>运行主题初始化脚本, 自动移除不相关的示例文件以及Git配置, 创建项目所需的js文件</p>\n<pre><code class=\"bash\">bash tools/init\n</code></pre>\n<p>运行bundle安装依赖:</p>\n<pre><code class=\"bash\">bundle \n</code></pre>\n<p>启动本地服务:</p>\n<pre><code class=\"bash\">bundle exec jekyll serve\n</code></pre>\n<h2 id=\"配置主题\"><a href=\"#配置主题\" class=\"headerlink\" title=\"配置主题\"></a>配置主题</h2><p><code>_config.yml</code>:</p>\n<pre><code class=\"yml\">lang: zh-CN\ntitle: Nestor&#39;s noteblog # the main title\ntagline: Design can be art.&lt;br/&gt; Design can be simple.&lt;br/&gt; That&#39;s why it&#39;s so complicated. # it will display as the sub-title\ndescription: &gt;- # used by seo meta and the atom feed\n  技术学习笔记, 如: Python, Django等等. 以及个人博客文章.\nsocial:\n  # Change to your full name.\n  # It will be displayed as the default author of the posts and the copyright owner in the Footer\n  name: Nestor\n  email: admin@nestor.me # change to your email address\n  links:\n    # The first element serves as the copyright owner&#39;s link\n    - https://gitee.com/nestalk # change to your github homepage\n    - https://weibo.com/u/1239998601 # change to your twitter homepage  \ntheme_mode: dark # [light|dark]    \navatar: /assets/img/avatar.png\n</code></pre>\n<p>关于分享的一些设置还没研究透, 留下几个问题:</p>\n<ul>\n<li>git链接 -&gt; gitee链接</li>\n<li>Twitter -&gt; weibo</li>\n</ul>\n<h2 id=\"添加文章\"><a href=\"#添加文章\" class=\"headerlink\" title=\"添加文章\"></a>添加文章</h2><p>添加文章始终应该在<code>_post</code>目录下, 直接创建文件即可, 不需要额外的文件夹.<br>但是文件的命名规则是固定的:</p>\n<p><code>YYYY-MM-DD-TITLE.md</code></p>\n<h3 id=\"添加头文件\"><a href=\"#添加头文件\" class=\"headerlink\" title=\"添加头文件\"></a>添加头文件</h3><pre><code class=\"yaml\">---\ntitle: TITLE\ndate: YYYY-MM-DD HH:MM:SS +/-TTTT\ncategories: [TOP_CATEGORIE, SUB_CATEGORIE]\ntags: [TAG]     # TAG names should always be lowercase\n---\n</code></pre>\n<ul>\n<li><code>categories</code> 最多包含两项, 但是<code>tag</code>几个都行</li>\n<li><code>math</code>: 数学公式功能, 出于性能因素默认关闭, 但是可以在需要的页面上手动打开 <code>math: true</code>, 基于<code>LaTex_math</code>实现, 相关<a href=\"https://www.jianshu.com/p/0ea47ae02262\">拓展资料</a></li>\n<li><code>toc</code>: 是否显示目录, 默认为<code>true</code>, 可以手动设置为<code>false</code>, 一般没必要关闭.</li>\n<li><code>comments</code>: 是否开启评论功能, 如果开启需要一个支持评论的后台系统, 需要的时候在研究. 对于已有评论系统的可以手动设置<code>false</code>关闭</li>\n<li><code>mermaid</code>: 流程图插件, 需要使用时标记为<code>true</code>即可, <a href=\"http://mermaid.js.org/intro/\">mermaid文档</a></li>\n<li><code>img_path</code>: 当前md文件中的所有图片都基于该路径进行查找</li>\n<li><code>images:</code>: 封面图, 可以为当前文章添加一个封面图片, 要求尺寸为<code>1200 * 630</code>, 可以仅提供一个路径, 或者进行完整设置:</li>\n</ul>\n<pre><code class=\"yaml\">---\nimage:\n    path: /path/to/image\n    alt: image alternative text\n---\n</code></pre>\n<ul>\n<li><code>pin</code>: 是否置顶文章</li>\n</ul>\n<p>为了简化操作, 在vscode中制作了一个专门的code snippet来解决这一问题:</p>\n<pre><code class=\"json\">    &quot;front matter for markdown&quot; : &#123;\n        &quot;scope&quot;: &quot;markdown, md&quot;,\n        &quot;prefix&quot;: &quot;matter&quot;,\n        &quot;body&quot;: [\n            &quot;---&quot;,\n            &quot;title: &#39;$&#123;1: title&#125;&#39;&quot;,\n            &quot;date: &#39;$&#123;2: YYYY-MM-DD HH:MM:SS&#125;&#39; +08000&quot;,\n            &quot;categories: [&#39;$&#123;3: first category, second category&#125;&#39;]&quot;,\n            &quot;tags: [&#39;$&#123;4: tags&#125;&#39;]&quot;,\n            &quot;---&quot;\n        ],\n        &quot;description&quot;: &quot;Generate Front Matter data for jekyll markdown post files.&quot;\n    &#125;\n</code></pre>\n<h3 id=\"调整图片\"><a href=\"#调整图片\" class=\"headerlink\" title=\"调整图片\"></a>调整图片</h3><p>设置图片标题:</p>\n<pre><code class=\"markdown\">![img-description](/path/to/image)\n_Image Caption_\n</code></pre>\n<p>设置图片大小:</p>\n<pre><code class=\"markdown\">![Desktop View](/assets/img/sample/mockup.png)&#123;: width=&quot;700&quot; height=&quot;400&quot; &#125;\n或者\n![Desktop View](/assets/img/sample/mockup.png)&#123;: w=&quot;700&quot; h=&quot;400&quot; &#125;\n</code></pre>\n<p>调整图片位置:</p>\n<pre><code class=\"markdown\">![Desktop View](/assets/img/sample/mockup.png)&#123;: .normal &#125;\n![Desktop View](/assets/img/sample/mockup.png)&#123;: .left &#125;\n![Desktop View](/assets/img/sample/mockup.png)&#123;: .right &#125;\n</code></pre>\n<p>明暗适配:</p>\n<pre><code class=\"markdown\">![Light mode only](/path/to/light-mode.png)&#123;: .light &#125;\n![Dark mode only](/path/to/dark-mode.png)&#123;: .dark &#125;\n</code></pre>\n<p>添加阴影:</p>\n<pre><code class=\"markdown\">![Desktop View](/assets/img/sample/mockup.png)&#123;: .shadow &#125;\n</code></pre>\n<h3 id=\"提示信息\"><a href=\"#提示信息\" class=\"headerlink\" title=\"提示信息\"></a>提示信息</h3><p>Chirpy集成了Prompts插件, 可以为段落引用添加样式, 如:</p>\n<pre><code class=\"markdown\">&gt; Example line for prompt.\n&#123;: .prompt-info &#125;\n</code></pre>\n<p>可选的提示样式包括<code>tip</code>, <code>info</code>, <code>warning</code>, <code>danger</code></p>\n<h3 id=\"修改Favicon\"><a href=\"#修改Favicon\" class=\"headerlink\" title=\"修改Favicon\"></a>修改Favicon</h3><p><a href=\"https://realfavicongenerator.net/\">Favicon在线制作工具</a></p>\n<p>上传一个正方形图片后会生成一个favicons文件夹, 下载后删除解压包中的文件:</p>\n<ul>\n<li>browserconfig.xml</li>\n<li>site.webmanifest</li>\n</ul>\n<p>将剩余的图片复制到<code>/assets/img/favicons</code>文件夹下进行覆盖即可.</p>\n"},{"title":"Docker笔记","date":"2023-11-15T14:26:58.000Z","image":"/assets/img/img_202311152245318150.png","_content":"\n## 安装docker\n\n[Docker文档](https://docs.docker.com/get-docker/)\n\n文档链接进入下载页面, 选择对应的系统下载安装即可.\n\n比较难受的是docker注册网站需要科学上网才能访问.\n\n安装并运行后, 终端执行以下命令查看是否成功:\n\n```bash\ndocker version\n```\n\n## 理解Docker的IMAGE和CONTAINER\n\n* `Image`: 包含了一个简化的操作系统, 比如`ubuntu`, 第三方库, 项目文件 环境变量等内容;\n* `Container`: 一个独立封装的虚拟环境.\n\n## Docker 基础命令\n\n* `docker ps`: 显示所有正在运行的容器\n  * `docker ps -a`: 显示所有容器\n* `docker start -i <id | name>`: 运行指定的容器, 可以是容器id或者容器别名. 如果使用id, 输入没有重名的前几位就可以, 别名则需要全名.\n* `docker run -it <image>`: 基于`image`在交互模式下创建新的`container`\n* `docker run -d <image>`: 在后台运行image\n* `docker run -d -p <host_port>:<container_port> <--name container_name> <image>`:在后台运行image, 创建指定名称的container, 并创建主机到容器的端口映射.\n* `docker exec <container_name> <linux_cmd><`: 在正在运行的容器中执行指令.\n* `docker image ls`: 列出所有本地镜像\n* `docker image rm <id | name>`: 删除指定的镜像\n* `docker container prune`: 删除所有停止的容器\n* `docker image prune`: 删除所有未使用的镜像\n* `docker build -t <image_name:tag> <path_to_Dockerfile>`: 创建本地镜像\n* `docker cp <source> <dist>`: 在容器与主机之间进行文件复制, 容器路径需要使用`container:path`主机路径则直接指定路径即可.\n\n## Dockerfile\n\n### 选择合适的基础镜像\n\nDocker的配置文件, 没有扩展名的文本文件. 直接在项目根目录下创建并编辑即可\n\n需要为项目确定一个基础镜像, 详情可以查看[官方文档](https://docs.docker.com/samples/)\n\n在`Dockerfile`中指定镜像:\n\n```text\nFROM node:14.16.0-alpine3.13\n```\n\n### 复制文件到镜像文件系统\n\n通过`COPY`或者`ADD`命令可以将特定的文件内容放入docker镜像\n\n```text\nCOPY . /app\n```\n\n或者\n\n```text\nWORKDIR /app\nCOPY . .\n```\n\n> 与shell的`cp`命令不同.\n>\n> 在`Dockerfile`中, 使用COPY命令的第一个`.`代表的是配置文件所在的目录.\n>\n> 而`/app`代表的是镜像文件的目录系统, 源文件路径和目标文件路径分属两个不同的文件系统.\n>\n> 通过`WORKDIR`指定是镜像中的工作目录\n>\n> 所以`COPY . .`的人话就是`将Dockerfile所在目录的全部分件复制到镜像中的工作目录下`\n>\n{: .prompt-tip}\n\n### 忽略特定内容\n\n配置docker忽略的文件`.dockerignore`, 与`.gitignore`文件类似\n\n```text\nnode_modules/\n```\n\n### 运行命令\n\n在部署docker镜像之后要执行的命令, 通常用来安装依赖等.\n\n```text\nRUN npm install\nRUN apt install python\n...\n```\n\n> 配合运行命令, 可以在打包镜像时忽略依赖库文件, 而在运行镜像时进行安装, 如此便可以极大的减小镜像文件所占用的空间.\n>\n{: .prompt-tip}\n\n### 设置环境变量\n\n直接在镜像环境中创建环境变量, 便可以直接在`shell`中进行使用.\n\n```text\nENV API_URL=https://some.url\n```\n\n### 开放端口\n\n指定容器的监听端口, 似的外部请求可以通过该端口与程序建立连接.\n\n```text\nEXPOSE 3000\n```\n\n> 该端口只是容器监听的端口, 而不是主机监听的端口. 在主机访问该端口对应的程序时需要设置端口映射.\n>\n> ```bash\n> docker run -d -p 8080:3000 my_image\n> ```\n>\n> 此时访问`127.0.0.1:8080`时就会映射到容器中监听3000端口的程序.\n>\n{: .prompt-info}\n\n### 修改用户\n\n默认情况下, docker在运行容器时使用的是`root`用户, 也就包含了全部权限, 出于安全考虑, 可以为镜像指定特定的用户和组以做权限管理.\n\n```text\nRUN addgroup app && adduser -S -G app app\n```\n\n> 在基于该指令创建镜像时出错, 可能是基础镜像的问题, 修改命令后正常:\n>\n> ```text\n> RUN addgroup app\n> RUN adduser --system app\n> RUN adduser app app\n> ```\n>\n{: .prompt-tip}\n\n### 启动指定项目\n\n通过`CMD`或`ENTRYPOINT`来指定镜像启动时的执行命令.\n\n```text\nCMD npm start\nCMD [\"npm\",\"start\"]\nENTRYPOINT npm start\nENTRYPOINT [\"npm\", \"start\"]\n```\n\n> 1. 使用[\"npm\", \"start\"]可以避免额外启动一个shell进程\n> 2. CMD和ENTRYPOINT的区别在于通过docker启动时直接填写命令可以替换CMD指令\n> 3. RUN和CMD的区别在于RUN是在构建镜像时执行, CMD是在启动镜像时执行.\n>\n{: .prompt-tip}\n\n### 优化docker镜像构建流程\n\ndocker在构建镜像时会为`Dockerfile`中的每一行配置创建一个单独的`layer`, 在重新构建时, 如果上一层`layer`没有任何变化则会直接使用之前的内容.\n\n在之前的配置文件中, 通过`COPY . .`将文件复制到了镜像中, 然后`RUN npm install`.\n\n```text\nCOPY . .\nRUN npm install\n```\n\n如果这样配置, 在进行任何文件内容修改, 如修改了一行代码, 也会导致文件内容变动, docker就只能重建镜像的文件系统, 也就是`COPY . .`这一层, 而在安装依赖之前的层发生了变动, 依赖就会被重新安装.\n\n因为依赖文件通常单独储存, 以node项目为例, 项目依赖都储存在`package*.json`中, 所以可以进行优化:\n\n```text\nCOPY package*.json .\nRUN npm install\nCOPY . .\n```\n\n此时构建镜像之后, 随便修改一个文件, 然后重新构建, 可以看到构建记录显示:\n\n![result](/assets/img/img_202311162146456205.png)\n\n由于`package*.json`文件没有变动, 直接通过缓存完成了复制依赖配置与安装依赖的步骤. 而构建速度也得到了极大的提升.\n\n因此, 在进行`Dockerfile`配置时, 不经常发生变动的内容应当优先配置, 而变动发生较多的内容则最后配置.\n\n## 设置镜像标签\n\n可以直接在构建镜像时直接设置标签:\n\n```bash\ndocker build -t image_name:tag_name .\n```\n\n为已有的镜像添加tag:\n\n```bash\ndocker image tag my_image:1 my_image:2\n```\n\n删除指定的标签:\n\n```bash\ndocker image remove my_image:2\n```\n\n> 如果镜像只有一个标签, 那么会直接删除镜像\n>\n{: .prompt-tip}\n\n## 打包和安装镜像\n\n除了通过Docker hub上传和加载镜像之外, 也可以直接将镜像进行打包, 并在其他的docker环境中载入.\n\n* 将指定的镜像文件打包:\n\n  ```bash\n  docker image save -o package.tar test_node:latest\n  ```\n\n* 载入指定的镜像文件:\n\n  ```bash\n  docker image load -i package.tar\n  ```\n\n## 创建主机到容器的文件映射\n\n在运行容器时可以将项目文件夹映射到容器之中, 这样在修改项目源码时容器中的内容也会一同更新, 从而省去了重新构建镜像的操作\n\n```bash\ndocker run -d -p 8080:3000 -v $(pwd):/app my_image\n```\n","source":"_posts/others/docker-notes.md","raw":"---\ntitle: Docker笔记\ndate: 2023-11-15 22:26:58 +0800\ncategories: [笔记, Docker]\ntags: [docker, linux, shell]\nimage: /assets/img/img_202311152245318150.png\n---\n\n## 安装docker\n\n[Docker文档](https://docs.docker.com/get-docker/)\n\n文档链接进入下载页面, 选择对应的系统下载安装即可.\n\n比较难受的是docker注册网站需要科学上网才能访问.\n\n安装并运行后, 终端执行以下命令查看是否成功:\n\n```bash\ndocker version\n```\n\n## 理解Docker的IMAGE和CONTAINER\n\n* `Image`: 包含了一个简化的操作系统, 比如`ubuntu`, 第三方库, 项目文件 环境变量等内容;\n* `Container`: 一个独立封装的虚拟环境.\n\n## Docker 基础命令\n\n* `docker ps`: 显示所有正在运行的容器\n  * `docker ps -a`: 显示所有容器\n* `docker start -i <id | name>`: 运行指定的容器, 可以是容器id或者容器别名. 如果使用id, 输入没有重名的前几位就可以, 别名则需要全名.\n* `docker run -it <image>`: 基于`image`在交互模式下创建新的`container`\n* `docker run -d <image>`: 在后台运行image\n* `docker run -d -p <host_port>:<container_port> <--name container_name> <image>`:在后台运行image, 创建指定名称的container, 并创建主机到容器的端口映射.\n* `docker exec <container_name> <linux_cmd><`: 在正在运行的容器中执行指令.\n* `docker image ls`: 列出所有本地镜像\n* `docker image rm <id | name>`: 删除指定的镜像\n* `docker container prune`: 删除所有停止的容器\n* `docker image prune`: 删除所有未使用的镜像\n* `docker build -t <image_name:tag> <path_to_Dockerfile>`: 创建本地镜像\n* `docker cp <source> <dist>`: 在容器与主机之间进行文件复制, 容器路径需要使用`container:path`主机路径则直接指定路径即可.\n\n## Dockerfile\n\n### 选择合适的基础镜像\n\nDocker的配置文件, 没有扩展名的文本文件. 直接在项目根目录下创建并编辑即可\n\n需要为项目确定一个基础镜像, 详情可以查看[官方文档](https://docs.docker.com/samples/)\n\n在`Dockerfile`中指定镜像:\n\n```text\nFROM node:14.16.0-alpine3.13\n```\n\n### 复制文件到镜像文件系统\n\n通过`COPY`或者`ADD`命令可以将特定的文件内容放入docker镜像\n\n```text\nCOPY . /app\n```\n\n或者\n\n```text\nWORKDIR /app\nCOPY . .\n```\n\n> 与shell的`cp`命令不同.\n>\n> 在`Dockerfile`中, 使用COPY命令的第一个`.`代表的是配置文件所在的目录.\n>\n> 而`/app`代表的是镜像文件的目录系统, 源文件路径和目标文件路径分属两个不同的文件系统.\n>\n> 通过`WORKDIR`指定是镜像中的工作目录\n>\n> 所以`COPY . .`的人话就是`将Dockerfile所在目录的全部分件复制到镜像中的工作目录下`\n>\n{: .prompt-tip}\n\n### 忽略特定内容\n\n配置docker忽略的文件`.dockerignore`, 与`.gitignore`文件类似\n\n```text\nnode_modules/\n```\n\n### 运行命令\n\n在部署docker镜像之后要执行的命令, 通常用来安装依赖等.\n\n```text\nRUN npm install\nRUN apt install python\n...\n```\n\n> 配合运行命令, 可以在打包镜像时忽略依赖库文件, 而在运行镜像时进行安装, 如此便可以极大的减小镜像文件所占用的空间.\n>\n{: .prompt-tip}\n\n### 设置环境变量\n\n直接在镜像环境中创建环境变量, 便可以直接在`shell`中进行使用.\n\n```text\nENV API_URL=https://some.url\n```\n\n### 开放端口\n\n指定容器的监听端口, 似的外部请求可以通过该端口与程序建立连接.\n\n```text\nEXPOSE 3000\n```\n\n> 该端口只是容器监听的端口, 而不是主机监听的端口. 在主机访问该端口对应的程序时需要设置端口映射.\n>\n> ```bash\n> docker run -d -p 8080:3000 my_image\n> ```\n>\n> 此时访问`127.0.0.1:8080`时就会映射到容器中监听3000端口的程序.\n>\n{: .prompt-info}\n\n### 修改用户\n\n默认情况下, docker在运行容器时使用的是`root`用户, 也就包含了全部权限, 出于安全考虑, 可以为镜像指定特定的用户和组以做权限管理.\n\n```text\nRUN addgroup app && adduser -S -G app app\n```\n\n> 在基于该指令创建镜像时出错, 可能是基础镜像的问题, 修改命令后正常:\n>\n> ```text\n> RUN addgroup app\n> RUN adduser --system app\n> RUN adduser app app\n> ```\n>\n{: .prompt-tip}\n\n### 启动指定项目\n\n通过`CMD`或`ENTRYPOINT`来指定镜像启动时的执行命令.\n\n```text\nCMD npm start\nCMD [\"npm\",\"start\"]\nENTRYPOINT npm start\nENTRYPOINT [\"npm\", \"start\"]\n```\n\n> 1. 使用[\"npm\", \"start\"]可以避免额外启动一个shell进程\n> 2. CMD和ENTRYPOINT的区别在于通过docker启动时直接填写命令可以替换CMD指令\n> 3. RUN和CMD的区别在于RUN是在构建镜像时执行, CMD是在启动镜像时执行.\n>\n{: .prompt-tip}\n\n### 优化docker镜像构建流程\n\ndocker在构建镜像时会为`Dockerfile`中的每一行配置创建一个单独的`layer`, 在重新构建时, 如果上一层`layer`没有任何变化则会直接使用之前的内容.\n\n在之前的配置文件中, 通过`COPY . .`将文件复制到了镜像中, 然后`RUN npm install`.\n\n```text\nCOPY . .\nRUN npm install\n```\n\n如果这样配置, 在进行任何文件内容修改, 如修改了一行代码, 也会导致文件内容变动, docker就只能重建镜像的文件系统, 也就是`COPY . .`这一层, 而在安装依赖之前的层发生了变动, 依赖就会被重新安装.\n\n因为依赖文件通常单独储存, 以node项目为例, 项目依赖都储存在`package*.json`中, 所以可以进行优化:\n\n```text\nCOPY package*.json .\nRUN npm install\nCOPY . .\n```\n\n此时构建镜像之后, 随便修改一个文件, 然后重新构建, 可以看到构建记录显示:\n\n![result](/assets/img/img_202311162146456205.png)\n\n由于`package*.json`文件没有变动, 直接通过缓存完成了复制依赖配置与安装依赖的步骤. 而构建速度也得到了极大的提升.\n\n因此, 在进行`Dockerfile`配置时, 不经常发生变动的内容应当优先配置, 而变动发生较多的内容则最后配置.\n\n## 设置镜像标签\n\n可以直接在构建镜像时直接设置标签:\n\n```bash\ndocker build -t image_name:tag_name .\n```\n\n为已有的镜像添加tag:\n\n```bash\ndocker image tag my_image:1 my_image:2\n```\n\n删除指定的标签:\n\n```bash\ndocker image remove my_image:2\n```\n\n> 如果镜像只有一个标签, 那么会直接删除镜像\n>\n{: .prompt-tip}\n\n## 打包和安装镜像\n\n除了通过Docker hub上传和加载镜像之外, 也可以直接将镜像进行打包, 并在其他的docker环境中载入.\n\n* 将指定的镜像文件打包:\n\n  ```bash\n  docker image save -o package.tar test_node:latest\n  ```\n\n* 载入指定的镜像文件:\n\n  ```bash\n  docker image load -i package.tar\n  ```\n\n## 创建主机到容器的文件映射\n\n在运行容器时可以将项目文件夹映射到容器之中, 这样在修改项目源码时容器中的内容也会一同更新, 从而省去了重新构建镜像的操作\n\n```bash\ndocker run -d -p 8080:3000 -v $(pwd):/app my_image\n```\n","slug":"others-docker-notes","published":1,"updated":"2023-12-13T08:41:08.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5uv0005i3erayluha0f","content":"<h2 id=\"安装docker\"><a href=\"#安装docker\" class=\"headerlink\" title=\"安装docker\"></a>安装docker</h2><p><a href=\"https://docs.docker.com/get-docker/\">Docker文档</a></p>\n<p>文档链接进入下载页面, 选择对应的系统下载安装即可.</p>\n<p>比较难受的是docker注册网站需要科学上网才能访问.</p>\n<p>安装并运行后, 终端执行以下命令查看是否成功:</p>\n<pre><code class=\"bash\">docker version\n</code></pre>\n<h2 id=\"理解Docker的IMAGE和CONTAINER\"><a href=\"#理解Docker的IMAGE和CONTAINER\" class=\"headerlink\" title=\"理解Docker的IMAGE和CONTAINER\"></a>理解Docker的IMAGE和CONTAINER</h2><ul>\n<li><code>Image</code>: 包含了一个简化的操作系统, 比如<code>ubuntu</code>, 第三方库, 项目文件 环境变量等内容;</li>\n<li><code>Container</code>: 一个独立封装的虚拟环境.</li>\n</ul>\n<h2 id=\"Docker-基础命令\"><a href=\"#Docker-基础命令\" class=\"headerlink\" title=\"Docker 基础命令\"></a>Docker 基础命令</h2><ul>\n<li><code>docker ps</code>: 显示所有正在运行的容器<ul>\n<li><code>docker ps -a</code>: 显示所有容器</li>\n</ul>\n</li>\n<li><code>docker start -i &lt;id | name&gt;</code>: 运行指定的容器, 可以是容器id或者容器别名. 如果使用id, 输入没有重名的前几位就可以, 别名则需要全名.</li>\n<li><code>docker run -it &lt;image&gt;</code>: 基于<code>image</code>在交互模式下创建新的<code>container</code></li>\n<li><code>docker run -d &lt;image&gt;</code>: 在后台运行image</li>\n<li><code>docker run -d -p &lt;host_port&gt;:&lt;container_port&gt; &lt;--name container_name&gt; &lt;image&gt;</code>:在后台运行image, 创建指定名称的container, 并创建主机到容器的端口映射.</li>\n<li><code>docker exec &lt;container_name&gt; &lt;linux_cmd&gt;&lt;</code>: 在正在运行的容器中执行指令.</li>\n<li><code>docker image ls</code>: 列出所有本地镜像</li>\n<li><code>docker image rm &lt;id | name&gt;</code>: 删除指定的镜像</li>\n<li><code>docker container prune</code>: 删除所有停止的容器</li>\n<li><code>docker image prune</code>: 删除所有未使用的镜像</li>\n<li><code>docker build -t &lt;image_name:tag&gt; &lt;path_to_Dockerfile&gt;</code>: 创建本地镜像</li>\n<li><code>docker cp &lt;source&gt; &lt;dist&gt;</code>: 在容器与主机之间进行文件复制, 容器路径需要使用<code>container:path</code>主机路径则直接指定路径即可.</li>\n</ul>\n<h2 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h2><h3 id=\"选择合适的基础镜像\"><a href=\"#选择合适的基础镜像\" class=\"headerlink\" title=\"选择合适的基础镜像\"></a>选择合适的基础镜像</h3><p>Docker的配置文件, 没有扩展名的文本文件. 直接在项目根目录下创建并编辑即可</p>\n<p>需要为项目确定一个基础镜像, 详情可以查看<a href=\"https://docs.docker.com/samples/\">官方文档</a></p>\n<p>在<code>Dockerfile</code>中指定镜像:</p>\n<pre><code class=\"text\">FROM node:14.16.0-alpine3.13\n</code></pre>\n<h3 id=\"复制文件到镜像文件系统\"><a href=\"#复制文件到镜像文件系统\" class=\"headerlink\" title=\"复制文件到镜像文件系统\"></a>复制文件到镜像文件系统</h3><p>通过<code>COPY</code>或者<code>ADD</code>命令可以将特定的文件内容放入docker镜像</p>\n<pre><code class=\"text\">COPY . /app\n</code></pre>\n<p>或者</p>\n<pre><code class=\"text\">WORKDIR /app\nCOPY . .\n</code></pre>\n<blockquote>\n<p>与shell的<code>cp</code>命令不同.</p>\n<p>在<code>Dockerfile</code>中, 使用COPY命令的第一个<code>.</code>代表的是配置文件所在的目录.</p>\n<p>而<code>/app</code>代表的是镜像文件的目录系统, 源文件路径和目标文件路径分属两个不同的文件系统.</p>\n<p>通过<code>WORKDIR</code>指定是镜像中的工作目录</p>\n<p>所以<code>COPY . .</code>的人话就是<code>将Dockerfile所在目录的全部分件复制到镜像中的工作目录下</code></p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h3 id=\"忽略特定内容\"><a href=\"#忽略特定内容\" class=\"headerlink\" title=\"忽略特定内容\"></a>忽略特定内容</h3><p>配置docker忽略的文件<code>.dockerignore</code>, 与<code>.gitignore</code>文件类似</p>\n<pre><code class=\"text\">node_modules/\n</code></pre>\n<h3 id=\"运行命令\"><a href=\"#运行命令\" class=\"headerlink\" title=\"运行命令\"></a>运行命令</h3><p>在部署docker镜像之后要执行的命令, 通常用来安装依赖等.</p>\n<pre><code class=\"text\">RUN npm install\nRUN apt install python\n...\n</code></pre>\n<blockquote>\n<p>配合运行命令, 可以在打包镜像时忽略依赖库文件, 而在运行镜像时进行安装, 如此便可以极大的减小镜像文件所占用的空间.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h3 id=\"设置环境变量\"><a href=\"#设置环境变量\" class=\"headerlink\" title=\"设置环境变量\"></a>设置环境变量</h3><p>直接在镜像环境中创建环境变量, 便可以直接在<code>shell</code>中进行使用.</p>\n<pre><code class=\"text\">ENV API_URL=https://some.url\n</code></pre>\n<h3 id=\"开放端口\"><a href=\"#开放端口\" class=\"headerlink\" title=\"开放端口\"></a>开放端口</h3><p>指定容器的监听端口, 似的外部请求可以通过该端口与程序建立连接.</p>\n<pre><code class=\"text\">EXPOSE 3000\n</code></pre>\n<blockquote>\n<p>该端口只是容器监听的端口, 而不是主机监听的端口. 在主机访问该端口对应的程序时需要设置端口映射.</p>\n<pre><code class=\"bash\">docker run -d -p 8080:3000 my_image\n</code></pre>\n<p>此时访问<code>127.0.0.1:8080</code>时就会映射到容器中监听3000端口的程序.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<h3 id=\"修改用户\"><a href=\"#修改用户\" class=\"headerlink\" title=\"修改用户\"></a>修改用户</h3><p>默认情况下, docker在运行容器时使用的是<code>root</code>用户, 也就包含了全部权限, 出于安全考虑, 可以为镜像指定特定的用户和组以做权限管理.</p>\n<pre><code class=\"text\">RUN addgroup app &amp;&amp; adduser -S -G app app\n</code></pre>\n<blockquote>\n<p>在基于该指令创建镜像时出错, 可能是基础镜像的问题, 修改命令后正常:</p>\n<pre><code class=\"text\">RUN addgroup app\nRUN adduser --system app\nRUN adduser app app\n</code></pre>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h3 id=\"启动指定项目\"><a href=\"#启动指定项目\" class=\"headerlink\" title=\"启动指定项目\"></a>启动指定项目</h3><p>通过<code>CMD</code>或<code>ENTRYPOINT</code>来指定镜像启动时的执行命令.</p>\n<pre><code class=\"text\">CMD npm start\nCMD [&quot;npm&quot;,&quot;start&quot;]\nENTRYPOINT npm start\nENTRYPOINT [&quot;npm&quot;, &quot;start&quot;]\n</code></pre>\n<blockquote>\n<ol>\n<li>使用[“npm”, “start”]可以避免额外启动一个shell进程</li>\n<li>CMD和ENTRYPOINT的区别在于通过docker启动时直接填写命令可以替换CMD指令</li>\n<li>RUN和CMD的区别在于RUN是在构建镜像时执行, CMD是在启动镜像时执行.</li>\n</ol>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h3 id=\"优化docker镜像构建流程\"><a href=\"#优化docker镜像构建流程\" class=\"headerlink\" title=\"优化docker镜像构建流程\"></a>优化docker镜像构建流程</h3><p>docker在构建镜像时会为<code>Dockerfile</code>中的每一行配置创建一个单独的<code>layer</code>, 在重新构建时, 如果上一层<code>layer</code>没有任何变化则会直接使用之前的内容.</p>\n<p>在之前的配置文件中, 通过<code>COPY . .</code>将文件复制到了镜像中, 然后<code>RUN npm install</code>.</p>\n<pre><code class=\"text\">COPY . .\nRUN npm install\n</code></pre>\n<p>如果这样配置, 在进行任何文件内容修改, 如修改了一行代码, 也会导致文件内容变动, docker就只能重建镜像的文件系统, 也就是<code>COPY . .</code>这一层, 而在安装依赖之前的层发生了变动, 依赖就会被重新安装.</p>\n<p>因为依赖文件通常单独储存, 以node项目为例, 项目依赖都储存在<code>package*.json</code>中, 所以可以进行优化:</p>\n<pre><code class=\"text\">COPY package*.json .\nRUN npm install\nCOPY . .\n</code></pre>\n<p>此时构建镜像之后, 随便修改一个文件, 然后重新构建, 可以看到构建记录显示:</p>\n<p><img src=\"/assets/img/img_202311162146456205.png\" alt=\"result\"></p>\n<p>由于<code>package*.json</code>文件没有变动, 直接通过缓存完成了复制依赖配置与安装依赖的步骤. 而构建速度也得到了极大的提升.</p>\n<p>因此, 在进行<code>Dockerfile</code>配置时, 不经常发生变动的内容应当优先配置, 而变动发生较多的内容则最后配置.</p>\n<h2 id=\"设置镜像标签\"><a href=\"#设置镜像标签\" class=\"headerlink\" title=\"设置镜像标签\"></a>设置镜像标签</h2><p>可以直接在构建镜像时直接设置标签:</p>\n<pre><code class=\"bash\">docker build -t image_name:tag_name .\n</code></pre>\n<p>为已有的镜像添加tag:</p>\n<pre><code class=\"bash\">docker image tag my_image:1 my_image:2\n</code></pre>\n<p>删除指定的标签:</p>\n<pre><code class=\"bash\">docker image remove my_image:2\n</code></pre>\n<blockquote>\n<p>如果镜像只有一个标签, 那么会直接删除镜像</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h2 id=\"打包和安装镜像\"><a href=\"#打包和安装镜像\" class=\"headerlink\" title=\"打包和安装镜像\"></a>打包和安装镜像</h2><p>除了通过Docker hub上传和加载镜像之外, 也可以直接将镜像进行打包, 并在其他的docker环境中载入.</p>\n<ul>\n<li><p>将指定的镜像文件打包:</p>\n<pre><code class=\"bash\">docker image save -o package.tar test_node:latest\n</code></pre>\n</li>\n<li><p>载入指定的镜像文件:</p>\n<pre><code class=\"bash\">docker image load -i package.tar\n</code></pre>\n</li>\n</ul>\n<h2 id=\"创建主机到容器的文件映射\"><a href=\"#创建主机到容器的文件映射\" class=\"headerlink\" title=\"创建主机到容器的文件映射\"></a>创建主机到容器的文件映射</h2><p>在运行容器时可以将项目文件夹映射到容器之中, 这样在修改项目源码时容器中的内容也会一同更新, 从而省去了重新构建镜像的操作</p>\n<pre><code class=\"bash\">docker run -d -p 8080:3000 -v $(pwd):/app my_image\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"安装docker\"><a href=\"#安装docker\" class=\"headerlink\" title=\"安装docker\"></a>安装docker</h2><p><a href=\"https://docs.docker.com/get-docker/\">Docker文档</a></p>\n<p>文档链接进入下载页面, 选择对应的系统下载安装即可.</p>\n<p>比较难受的是docker注册网站需要科学上网才能访问.</p>\n<p>安装并运行后, 终端执行以下命令查看是否成功:</p>\n<pre><code class=\"bash\">docker version\n</code></pre>\n<h2 id=\"理解Docker的IMAGE和CONTAINER\"><a href=\"#理解Docker的IMAGE和CONTAINER\" class=\"headerlink\" title=\"理解Docker的IMAGE和CONTAINER\"></a>理解Docker的IMAGE和CONTAINER</h2><ul>\n<li><code>Image</code>: 包含了一个简化的操作系统, 比如<code>ubuntu</code>, 第三方库, 项目文件 环境变量等内容;</li>\n<li><code>Container</code>: 一个独立封装的虚拟环境.</li>\n</ul>\n<h2 id=\"Docker-基础命令\"><a href=\"#Docker-基础命令\" class=\"headerlink\" title=\"Docker 基础命令\"></a>Docker 基础命令</h2><ul>\n<li><code>docker ps</code>: 显示所有正在运行的容器<ul>\n<li><code>docker ps -a</code>: 显示所有容器</li>\n</ul>\n</li>\n<li><code>docker start -i &lt;id | name&gt;</code>: 运行指定的容器, 可以是容器id或者容器别名. 如果使用id, 输入没有重名的前几位就可以, 别名则需要全名.</li>\n<li><code>docker run -it &lt;image&gt;</code>: 基于<code>image</code>在交互模式下创建新的<code>container</code></li>\n<li><code>docker run -d &lt;image&gt;</code>: 在后台运行image</li>\n<li><code>docker run -d -p &lt;host_port&gt;:&lt;container_port&gt; &lt;--name container_name&gt; &lt;image&gt;</code>:在后台运行image, 创建指定名称的container, 并创建主机到容器的端口映射.</li>\n<li><code>docker exec &lt;container_name&gt; &lt;linux_cmd&gt;&lt;</code>: 在正在运行的容器中执行指令.</li>\n<li><code>docker image ls</code>: 列出所有本地镜像</li>\n<li><code>docker image rm &lt;id | name&gt;</code>: 删除指定的镜像</li>\n<li><code>docker container prune</code>: 删除所有停止的容器</li>\n<li><code>docker image prune</code>: 删除所有未使用的镜像</li>\n<li><code>docker build -t &lt;image_name:tag&gt; &lt;path_to_Dockerfile&gt;</code>: 创建本地镜像</li>\n<li><code>docker cp &lt;source&gt; &lt;dist&gt;</code>: 在容器与主机之间进行文件复制, 容器路径需要使用<code>container:path</code>主机路径则直接指定路径即可.</li>\n</ul>\n<h2 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h2><h3 id=\"选择合适的基础镜像\"><a href=\"#选择合适的基础镜像\" class=\"headerlink\" title=\"选择合适的基础镜像\"></a>选择合适的基础镜像</h3><p>Docker的配置文件, 没有扩展名的文本文件. 直接在项目根目录下创建并编辑即可</p>\n<p>需要为项目确定一个基础镜像, 详情可以查看<a href=\"https://docs.docker.com/samples/\">官方文档</a></p>\n<p>在<code>Dockerfile</code>中指定镜像:</p>\n<pre><code class=\"text\">FROM node:14.16.0-alpine3.13\n</code></pre>\n<h3 id=\"复制文件到镜像文件系统\"><a href=\"#复制文件到镜像文件系统\" class=\"headerlink\" title=\"复制文件到镜像文件系统\"></a>复制文件到镜像文件系统</h3><p>通过<code>COPY</code>或者<code>ADD</code>命令可以将特定的文件内容放入docker镜像</p>\n<pre><code class=\"text\">COPY . /app\n</code></pre>\n<p>或者</p>\n<pre><code class=\"text\">WORKDIR /app\nCOPY . .\n</code></pre>\n<blockquote>\n<p>与shell的<code>cp</code>命令不同.</p>\n<p>在<code>Dockerfile</code>中, 使用COPY命令的第一个<code>.</code>代表的是配置文件所在的目录.</p>\n<p>而<code>/app</code>代表的是镜像文件的目录系统, 源文件路径和目标文件路径分属两个不同的文件系统.</p>\n<p>通过<code>WORKDIR</code>指定是镜像中的工作目录</p>\n<p>所以<code>COPY . .</code>的人话就是<code>将Dockerfile所在目录的全部分件复制到镜像中的工作目录下</code></p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h3 id=\"忽略特定内容\"><a href=\"#忽略特定内容\" class=\"headerlink\" title=\"忽略特定内容\"></a>忽略特定内容</h3><p>配置docker忽略的文件<code>.dockerignore</code>, 与<code>.gitignore</code>文件类似</p>\n<pre><code class=\"text\">node_modules/\n</code></pre>\n<h3 id=\"运行命令\"><a href=\"#运行命令\" class=\"headerlink\" title=\"运行命令\"></a>运行命令</h3><p>在部署docker镜像之后要执行的命令, 通常用来安装依赖等.</p>\n<pre><code class=\"text\">RUN npm install\nRUN apt install python\n...\n</code></pre>\n<blockquote>\n<p>配合运行命令, 可以在打包镜像时忽略依赖库文件, 而在运行镜像时进行安装, 如此便可以极大的减小镜像文件所占用的空间.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h3 id=\"设置环境变量\"><a href=\"#设置环境变量\" class=\"headerlink\" title=\"设置环境变量\"></a>设置环境变量</h3><p>直接在镜像环境中创建环境变量, 便可以直接在<code>shell</code>中进行使用.</p>\n<pre><code class=\"text\">ENV API_URL=https://some.url\n</code></pre>\n<h3 id=\"开放端口\"><a href=\"#开放端口\" class=\"headerlink\" title=\"开放端口\"></a>开放端口</h3><p>指定容器的监听端口, 似的外部请求可以通过该端口与程序建立连接.</p>\n<pre><code class=\"text\">EXPOSE 3000\n</code></pre>\n<blockquote>\n<p>该端口只是容器监听的端口, 而不是主机监听的端口. 在主机访问该端口对应的程序时需要设置端口映射.</p>\n<pre><code class=\"bash\">docker run -d -p 8080:3000 my_image\n</code></pre>\n<p>此时访问<code>127.0.0.1:8080</code>时就会映射到容器中监听3000端口的程序.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<h3 id=\"修改用户\"><a href=\"#修改用户\" class=\"headerlink\" title=\"修改用户\"></a>修改用户</h3><p>默认情况下, docker在运行容器时使用的是<code>root</code>用户, 也就包含了全部权限, 出于安全考虑, 可以为镜像指定特定的用户和组以做权限管理.</p>\n<pre><code class=\"text\">RUN addgroup app &amp;&amp; adduser -S -G app app\n</code></pre>\n<blockquote>\n<p>在基于该指令创建镜像时出错, 可能是基础镜像的问题, 修改命令后正常:</p>\n<pre><code class=\"text\">RUN addgroup app\nRUN adduser --system app\nRUN adduser app app\n</code></pre>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h3 id=\"启动指定项目\"><a href=\"#启动指定项目\" class=\"headerlink\" title=\"启动指定项目\"></a>启动指定项目</h3><p>通过<code>CMD</code>或<code>ENTRYPOINT</code>来指定镜像启动时的执行命令.</p>\n<pre><code class=\"text\">CMD npm start\nCMD [&quot;npm&quot;,&quot;start&quot;]\nENTRYPOINT npm start\nENTRYPOINT [&quot;npm&quot;, &quot;start&quot;]\n</code></pre>\n<blockquote>\n<ol>\n<li>使用[“npm”, “start”]可以避免额外启动一个shell进程</li>\n<li>CMD和ENTRYPOINT的区别在于通过docker启动时直接填写命令可以替换CMD指令</li>\n<li>RUN和CMD的区别在于RUN是在构建镜像时执行, CMD是在启动镜像时执行.</li>\n</ol>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h3 id=\"优化docker镜像构建流程\"><a href=\"#优化docker镜像构建流程\" class=\"headerlink\" title=\"优化docker镜像构建流程\"></a>优化docker镜像构建流程</h3><p>docker在构建镜像时会为<code>Dockerfile</code>中的每一行配置创建一个单独的<code>layer</code>, 在重新构建时, 如果上一层<code>layer</code>没有任何变化则会直接使用之前的内容.</p>\n<p>在之前的配置文件中, 通过<code>COPY . .</code>将文件复制到了镜像中, 然后<code>RUN npm install</code>.</p>\n<pre><code class=\"text\">COPY . .\nRUN npm install\n</code></pre>\n<p>如果这样配置, 在进行任何文件内容修改, 如修改了一行代码, 也会导致文件内容变动, docker就只能重建镜像的文件系统, 也就是<code>COPY . .</code>这一层, 而在安装依赖之前的层发生了变动, 依赖就会被重新安装.</p>\n<p>因为依赖文件通常单独储存, 以node项目为例, 项目依赖都储存在<code>package*.json</code>中, 所以可以进行优化:</p>\n<pre><code class=\"text\">COPY package*.json .\nRUN npm install\nCOPY . .\n</code></pre>\n<p>此时构建镜像之后, 随便修改一个文件, 然后重新构建, 可以看到构建记录显示:</p>\n<p><img src=\"/assets/img/img_202311162146456205.png\" alt=\"result\"></p>\n<p>由于<code>package*.json</code>文件没有变动, 直接通过缓存完成了复制依赖配置与安装依赖的步骤. 而构建速度也得到了极大的提升.</p>\n<p>因此, 在进行<code>Dockerfile</code>配置时, 不经常发生变动的内容应当优先配置, 而变动发生较多的内容则最后配置.</p>\n<h2 id=\"设置镜像标签\"><a href=\"#设置镜像标签\" class=\"headerlink\" title=\"设置镜像标签\"></a>设置镜像标签</h2><p>可以直接在构建镜像时直接设置标签:</p>\n<pre><code class=\"bash\">docker build -t image_name:tag_name .\n</code></pre>\n<p>为已有的镜像添加tag:</p>\n<pre><code class=\"bash\">docker image tag my_image:1 my_image:2\n</code></pre>\n<p>删除指定的标签:</p>\n<pre><code class=\"bash\">docker image remove my_image:2\n</code></pre>\n<blockquote>\n<p>如果镜像只有一个标签, 那么会直接删除镜像</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h2 id=\"打包和安装镜像\"><a href=\"#打包和安装镜像\" class=\"headerlink\" title=\"打包和安装镜像\"></a>打包和安装镜像</h2><p>除了通过Docker hub上传和加载镜像之外, 也可以直接将镜像进行打包, 并在其他的docker环境中载入.</p>\n<ul>\n<li><p>将指定的镜像文件打包:</p>\n<pre><code class=\"bash\">docker image save -o package.tar test_node:latest\n</code></pre>\n</li>\n<li><p>载入指定的镜像文件:</p>\n<pre><code class=\"bash\">docker image load -i package.tar\n</code></pre>\n</li>\n</ul>\n<h2 id=\"创建主机到容器的文件映射\"><a href=\"#创建主机到容器的文件映射\" class=\"headerlink\" title=\"创建主机到容器的文件映射\"></a>创建主机到容器的文件映射</h2><p>在运行容器时可以将项目文件夹映射到容器之中, 这样在修改项目源码时容器中的内容也会一同更新, 从而省去了重新构建镜像的操作</p>\n<pre><code class=\"bash\">docker run -d -p 8080:3000 -v $(pwd):/app my_image\n</code></pre>\n"},{"title":"常用Linux命令","date":"2023-11-16T10:43:52.000Z","_content":"\n## 基础命令\n\n* `cd`: 修改文件夹\n* `ls`: 列出当前文件夹下的内容, 可以使用参数:\n  * `-a`: 显示隐藏文件\n  * `-l`: 显示详情\n  * `-1`: 每行一个\n* `pwd`: 显示当前文件夹完整路径\n* `cp`: 复制文件, `cp src dist`\n* `mv`: 移动或重命名文件\n* `rm`: 删除文件或文件夹, 常用参数\n  * `-r`或`-rf`: 递归, 在处理文件夹时使用, 表示自动遍历子文件夹\n\n## 文件操作\n\n* `cat`: 连接文件, 也可用于显示单个文件的内容\n  \n  ```bash\n  cat text.txt\n  cat text1.txt > text2.txt\n  cat text1.txt text2.txt\n  cat text1.txt text2.txt > new.txt\n  ```\n\n  > `>` 用于修改输出源, 默认为`stdout`, 即显示器.\n  >\n  > 通过`> text2.txt`即可以将文件内容输出到新的文件之中.\n  >\n  > 包含输出结果的命令都可以与 `>` 连用, 比如:\n  >\n  > `echo something > file.txt`\n  >\n  {: .prompt-tip}\n\n  > `>` 会覆盖目标文件, 如果只是希望添加新内容, 则应该使用`>>`\n  >\n  > ```bash\n  > echo \"new line\" >> file.txt\n  > ```\n  >\n  {: .prompt-warning}\n\n* `more`: 显示长文件内容, 通过空格翻页, 回车载入新行, 但只能下翻.\n* `less`: 同样显示长文件内容, 可以上下翻页, 需要单独安装: ```apt install less```\n* `head`: 显示前n行内容: ```head -n 10 filename```\n* `tail`: 显示最后n行内容: ```tail -n 10 filename```\n\n## 文件搜索\n\n* `grep`: global reg expression, 正则搜索命令. 区分大小写, 可以与`-i`连用忽略大小写\n\n  ```bash\n  grep hello file.txt\n  grep -i hello file.txt\n  grep -i hello fi*\n  grep -i -r hello .\n  grep -ir helllo .\n  ```\n\n* `find`: 查找指定文件, 如果不指定任何参数, 则默认列出当前文件夹和子文件夹中的内容.\n  * `-type d`: 仅查找文件夹\n  * `-type f`: 仅查找文件\n\n  ```bash\n  find ~/code -type f -name \"*.py\"\n  ```\n\n## 命令连用\n\n* `;`: 分割多条命令, 一次性执行.\n\n  ```bash\n  mkdir temp; cd temp; echo done\n  ```\n\n* `&&`: 当某一条指令执行失败时自动结束.\n\n  ```bash\n  mkdir temp && cd temp && echo done\n  ```\n\n* `||`: 当上一条执行失败时执行下一条指令.\n\n  ```bash\n  mkdir temp || echo \"failed to create temporary directory\"\n  ```\n\n* `|`: 将上一条指令的输出作为下一条指令的输入\n  \n  ```bash\n  ls -l /etc | less\n  ls -l /etc | head\n  ls -l /etc | grep -i init\n  ```\n\n* `\\`: 连接指令太长的时候用来换行.\n\n## 进程管理\n\n* `ps`: 显示当前正在运行的所有进程\n* `&`: 在后台执行某项命令, 如`sleep 100 &`\n* `kill [pid]`: 结束某一进程\n\n## 环境变量\n\n* `printenv`: 打印全部环境变量. 也可以指定要显示的环境变量, 如`printenv PATH`, 也可以使用`echo $PATH`来显示环境变量.\n\n用户环境变量保存在`~/.bashrc`文件中, 可以向环境变量中添加一些自定义数据或者变量, 便可以在任意位置直接使用. 也可以对一些常用命令和参数的组合设置别名.\n\n```bash\necho TEST_VAR=AAA >> .bashrc\necho $TEST_VAR\necho \"alias rmd='rm -rf'\" >> .bashrc \n```\n\n> 添加的环境变量需要重启shell会话才会生效\n> 也可以通过命令重新加载: `source ~/.bashrc`\n>\n{: .prompt-tip}\n","source":"_posts/others/linux-basic-commands.md","raw":"---\ntitle: 常用Linux命令\ndate: 2023-11-16 18:43:52 +0800\ncategories: [笔记, docker]\ntags: [docker, linux, shell]\n---\n\n## 基础命令\n\n* `cd`: 修改文件夹\n* `ls`: 列出当前文件夹下的内容, 可以使用参数:\n  * `-a`: 显示隐藏文件\n  * `-l`: 显示详情\n  * `-1`: 每行一个\n* `pwd`: 显示当前文件夹完整路径\n* `cp`: 复制文件, `cp src dist`\n* `mv`: 移动或重命名文件\n* `rm`: 删除文件或文件夹, 常用参数\n  * `-r`或`-rf`: 递归, 在处理文件夹时使用, 表示自动遍历子文件夹\n\n## 文件操作\n\n* `cat`: 连接文件, 也可用于显示单个文件的内容\n  \n  ```bash\n  cat text.txt\n  cat text1.txt > text2.txt\n  cat text1.txt text2.txt\n  cat text1.txt text2.txt > new.txt\n  ```\n\n  > `>` 用于修改输出源, 默认为`stdout`, 即显示器.\n  >\n  > 通过`> text2.txt`即可以将文件内容输出到新的文件之中.\n  >\n  > 包含输出结果的命令都可以与 `>` 连用, 比如:\n  >\n  > `echo something > file.txt`\n  >\n  {: .prompt-tip}\n\n  > `>` 会覆盖目标文件, 如果只是希望添加新内容, 则应该使用`>>`\n  >\n  > ```bash\n  > echo \"new line\" >> file.txt\n  > ```\n  >\n  {: .prompt-warning}\n\n* `more`: 显示长文件内容, 通过空格翻页, 回车载入新行, 但只能下翻.\n* `less`: 同样显示长文件内容, 可以上下翻页, 需要单独安装: ```apt install less```\n* `head`: 显示前n行内容: ```head -n 10 filename```\n* `tail`: 显示最后n行内容: ```tail -n 10 filename```\n\n## 文件搜索\n\n* `grep`: global reg expression, 正则搜索命令. 区分大小写, 可以与`-i`连用忽略大小写\n\n  ```bash\n  grep hello file.txt\n  grep -i hello file.txt\n  grep -i hello fi*\n  grep -i -r hello .\n  grep -ir helllo .\n  ```\n\n* `find`: 查找指定文件, 如果不指定任何参数, 则默认列出当前文件夹和子文件夹中的内容.\n  * `-type d`: 仅查找文件夹\n  * `-type f`: 仅查找文件\n\n  ```bash\n  find ~/code -type f -name \"*.py\"\n  ```\n\n## 命令连用\n\n* `;`: 分割多条命令, 一次性执行.\n\n  ```bash\n  mkdir temp; cd temp; echo done\n  ```\n\n* `&&`: 当某一条指令执行失败时自动结束.\n\n  ```bash\n  mkdir temp && cd temp && echo done\n  ```\n\n* `||`: 当上一条执行失败时执行下一条指令.\n\n  ```bash\n  mkdir temp || echo \"failed to create temporary directory\"\n  ```\n\n* `|`: 将上一条指令的输出作为下一条指令的输入\n  \n  ```bash\n  ls -l /etc | less\n  ls -l /etc | head\n  ls -l /etc | grep -i init\n  ```\n\n* `\\`: 连接指令太长的时候用来换行.\n\n## 进程管理\n\n* `ps`: 显示当前正在运行的所有进程\n* `&`: 在后台执行某项命令, 如`sleep 100 &`\n* `kill [pid]`: 结束某一进程\n\n## 环境变量\n\n* `printenv`: 打印全部环境变量. 也可以指定要显示的环境变量, 如`printenv PATH`, 也可以使用`echo $PATH`来显示环境变量.\n\n用户环境变量保存在`~/.bashrc`文件中, 可以向环境变量中添加一些自定义数据或者变量, 便可以在任意位置直接使用. 也可以对一些常用命令和参数的组合设置别名.\n\n```bash\necho TEST_VAR=AAA >> .bashrc\necho $TEST_VAR\necho \"alias rmd='rm -rf'\" >> .bashrc \n```\n\n> 添加的环境变量需要重启shell会话才会生效\n> 也可以通过命令重新加载: `source ~/.bashrc`\n>\n{: .prompt-tip}\n","slug":"others-linux-basic-commands","published":1,"updated":"2023-12-13T08:41:08.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5uw0006i3erhxy2df2d","content":"<h2 id=\"基础命令\"><a href=\"#基础命令\" class=\"headerlink\" title=\"基础命令\"></a>基础命令</h2><ul>\n<li><code>cd</code>: 修改文件夹</li>\n<li><code>ls</code>: 列出当前文件夹下的内容, 可以使用参数:<ul>\n<li><code>-a</code>: 显示隐藏文件</li>\n<li><code>-l</code>: 显示详情</li>\n<li><code>-1</code>: 每行一个</li>\n</ul>\n</li>\n<li><code>pwd</code>: 显示当前文件夹完整路径</li>\n<li><code>cp</code>: 复制文件, <code>cp src dist</code></li>\n<li><code>mv</code>: 移动或重命名文件</li>\n<li><code>rm</code>: 删除文件或文件夹, 常用参数<ul>\n<li><code>-r</code>或<code>-rf</code>: 递归, 在处理文件夹时使用, 表示自动遍历子文件夹</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><ul>\n<li><p><code>cat</code>: 连接文件, 也可用于显示单个文件的内容</p>\n<pre><code class=\"bash\">cat text.txt\ncat text1.txt &gt; text2.txt\ncat text1.txt text2.txt\ncat text1.txt text2.txt &gt; new.txt\n</code></pre>\n<blockquote>\n<p><code>&gt;</code> 用于修改输出源, 默认为<code>stdout</code>, 即显示器.</p>\n<p>通过<code>&gt; text2.txt</code>即可以将文件内容输出到新的文件之中.</p>\n<p>包含输出结果的命令都可以与 <code>&gt;</code> 连用, 比如:</p>\n<p><code>echo something &gt; file.txt</code></p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<blockquote>\n<p><code>&gt;</code> 会覆盖目标文件, 如果只是希望添加新内容, 则应该使用<code>&gt;&gt;</code></p>\n<pre><code class=\"bash\">echo &quot;new line&quot; &gt;&gt; file.txt\n</code></pre>\n</blockquote>\n<p>{: .prompt-warning}</p>\n</li>\n<li><p><code>more</code>: 显示长文件内容, 通过空格翻页, 回车载入新行, 但只能下翻.</p>\n</li>\n<li><p><code>less</code>: 同样显示长文件内容, 可以上下翻页, 需要单独安装: <code>apt install less</code></p>\n</li>\n<li><p><code>head</code>: 显示前n行内容: <code>head -n 10 filename</code></p>\n</li>\n<li><p><code>tail</code>: 显示最后n行内容: <code>tail -n 10 filename</code></p>\n</li>\n</ul>\n<h2 id=\"文件搜索\"><a href=\"#文件搜索\" class=\"headerlink\" title=\"文件搜索\"></a>文件搜索</h2><ul>\n<li><p><code>grep</code>: global reg expression, 正则搜索命令. 区分大小写, 可以与<code>-i</code>连用忽略大小写</p>\n<pre><code class=\"bash\">grep hello file.txt\ngrep -i hello file.txt\ngrep -i hello fi*\ngrep -i -r hello .\ngrep -ir helllo .\n</code></pre>\n</li>\n<li><p><code>find</code>: 查找指定文件, 如果不指定任何参数, 则默认列出当前文件夹和子文件夹中的内容.</p>\n<ul>\n<li><code>-type d</code>: 仅查找文件夹</li>\n<li><code>-type f</code>: 仅查找文件</li>\n</ul>\n<pre><code class=\"bash\">find ~/code -type f -name &quot;*.py&quot;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"命令连用\"><a href=\"#命令连用\" class=\"headerlink\" title=\"命令连用\"></a>命令连用</h2><ul>\n<li><p><code>;</code>: 分割多条命令, 一次性执行.</p>\n<pre><code class=\"bash\">mkdir temp; cd temp; echo done\n</code></pre>\n</li>\n<li><p><code>&amp;&amp;</code>: 当某一条指令执行失败时自动结束.</p>\n<pre><code class=\"bash\">mkdir temp &amp;&amp; cd temp &amp;&amp; echo done\n</code></pre>\n</li>\n<li><p><code>||</code>: 当上一条执行失败时执行下一条指令.</p>\n<pre><code class=\"bash\">mkdir temp || echo &quot;failed to create temporary directory&quot;\n</code></pre>\n</li>\n<li><p><code>|</code>: 将上一条指令的输出作为下一条指令的输入</p>\n<pre><code class=\"bash\">ls -l /etc | less\nls -l /etc | head\nls -l /etc | grep -i init\n</code></pre>\n</li>\n<li><p><code>\\</code>: 连接指令太长的时候用来换行.</p>\n</li>\n</ul>\n<h2 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h2><ul>\n<li><code>ps</code>: 显示当前正在运行的所有进程</li>\n<li><code>&amp;</code>: 在后台执行某项命令, 如<code>sleep 100 &amp;</code></li>\n<li><code>kill [pid]</code>: 结束某一进程</li>\n</ul>\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><ul>\n<li><code>printenv</code>: 打印全部环境变量. 也可以指定要显示的环境变量, 如<code>printenv PATH</code>, 也可以使用<code>echo $PATH</code>来显示环境变量.</li>\n</ul>\n<p>用户环境变量保存在<code>~/.bashrc</code>文件中, 可以向环境变量中添加一些自定义数据或者变量, 便可以在任意位置直接使用. 也可以对一些常用命令和参数的组合设置别名.</p>\n<pre><code class=\"bash\">echo TEST_VAR=AAA &gt;&gt; .bashrc\necho $TEST_VAR\necho &quot;alias rmd=&#39;rm -rf&#39;&quot; &gt;&gt; .bashrc \n</code></pre>\n<blockquote>\n<p>添加的环境变量需要重启shell会话才会生效<br>也可以通过命令重新加载: <code>source ~/.bashrc</code></p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"基础命令\"><a href=\"#基础命令\" class=\"headerlink\" title=\"基础命令\"></a>基础命令</h2><ul>\n<li><code>cd</code>: 修改文件夹</li>\n<li><code>ls</code>: 列出当前文件夹下的内容, 可以使用参数:<ul>\n<li><code>-a</code>: 显示隐藏文件</li>\n<li><code>-l</code>: 显示详情</li>\n<li><code>-1</code>: 每行一个</li>\n</ul>\n</li>\n<li><code>pwd</code>: 显示当前文件夹完整路径</li>\n<li><code>cp</code>: 复制文件, <code>cp src dist</code></li>\n<li><code>mv</code>: 移动或重命名文件</li>\n<li><code>rm</code>: 删除文件或文件夹, 常用参数<ul>\n<li><code>-r</code>或<code>-rf</code>: 递归, 在处理文件夹时使用, 表示自动遍历子文件夹</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><ul>\n<li><p><code>cat</code>: 连接文件, 也可用于显示单个文件的内容</p>\n<pre><code class=\"bash\">cat text.txt\ncat text1.txt &gt; text2.txt\ncat text1.txt text2.txt\ncat text1.txt text2.txt &gt; new.txt\n</code></pre>\n<blockquote>\n<p><code>&gt;</code> 用于修改输出源, 默认为<code>stdout</code>, 即显示器.</p>\n<p>通过<code>&gt; text2.txt</code>即可以将文件内容输出到新的文件之中.</p>\n<p>包含输出结果的命令都可以与 <code>&gt;</code> 连用, 比如:</p>\n<p><code>echo something &gt; file.txt</code></p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<blockquote>\n<p><code>&gt;</code> 会覆盖目标文件, 如果只是希望添加新内容, 则应该使用<code>&gt;&gt;</code></p>\n<pre><code class=\"bash\">echo &quot;new line&quot; &gt;&gt; file.txt\n</code></pre>\n</blockquote>\n<p>{: .prompt-warning}</p>\n</li>\n<li><p><code>more</code>: 显示长文件内容, 通过空格翻页, 回车载入新行, 但只能下翻.</p>\n</li>\n<li><p><code>less</code>: 同样显示长文件内容, 可以上下翻页, 需要单独安装: <code>apt install less</code></p>\n</li>\n<li><p><code>head</code>: 显示前n行内容: <code>head -n 10 filename</code></p>\n</li>\n<li><p><code>tail</code>: 显示最后n行内容: <code>tail -n 10 filename</code></p>\n</li>\n</ul>\n<h2 id=\"文件搜索\"><a href=\"#文件搜索\" class=\"headerlink\" title=\"文件搜索\"></a>文件搜索</h2><ul>\n<li><p><code>grep</code>: global reg expression, 正则搜索命令. 区分大小写, 可以与<code>-i</code>连用忽略大小写</p>\n<pre><code class=\"bash\">grep hello file.txt\ngrep -i hello file.txt\ngrep -i hello fi*\ngrep -i -r hello .\ngrep -ir helllo .\n</code></pre>\n</li>\n<li><p><code>find</code>: 查找指定文件, 如果不指定任何参数, 则默认列出当前文件夹和子文件夹中的内容.</p>\n<ul>\n<li><code>-type d</code>: 仅查找文件夹</li>\n<li><code>-type f</code>: 仅查找文件</li>\n</ul>\n<pre><code class=\"bash\">find ~/code -type f -name &quot;*.py&quot;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"命令连用\"><a href=\"#命令连用\" class=\"headerlink\" title=\"命令连用\"></a>命令连用</h2><ul>\n<li><p><code>;</code>: 分割多条命令, 一次性执行.</p>\n<pre><code class=\"bash\">mkdir temp; cd temp; echo done\n</code></pre>\n</li>\n<li><p><code>&amp;&amp;</code>: 当某一条指令执行失败时自动结束.</p>\n<pre><code class=\"bash\">mkdir temp &amp;&amp; cd temp &amp;&amp; echo done\n</code></pre>\n</li>\n<li><p><code>||</code>: 当上一条执行失败时执行下一条指令.</p>\n<pre><code class=\"bash\">mkdir temp || echo &quot;failed to create temporary directory&quot;\n</code></pre>\n</li>\n<li><p><code>|</code>: 将上一条指令的输出作为下一条指令的输入</p>\n<pre><code class=\"bash\">ls -l /etc | less\nls -l /etc | head\nls -l /etc | grep -i init\n</code></pre>\n</li>\n<li><p><code>\\</code>: 连接指令太长的时候用来换行.</p>\n</li>\n</ul>\n<h2 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h2><ul>\n<li><code>ps</code>: 显示当前正在运行的所有进程</li>\n<li><code>&amp;</code>: 在后台执行某项命令, 如<code>sleep 100 &amp;</code></li>\n<li><code>kill [pid]</code>: 结束某一进程</li>\n</ul>\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><ul>\n<li><code>printenv</code>: 打印全部环境变量. 也可以指定要显示的环境变量, 如<code>printenv PATH</code>, 也可以使用<code>echo $PATH</code>来显示环境变量.</li>\n</ul>\n<p>用户环境变量保存在<code>~/.bashrc</code>文件中, 可以向环境变量中添加一些自定义数据或者变量, 便可以在任意位置直接使用. 也可以对一些常用命令和参数的组合设置别名.</p>\n<pre><code class=\"bash\">echo TEST_VAR=AAA &gt;&gt; .bashrc\necho $TEST_VAR\necho &quot;alias rmd=&#39;rm -rf&#39;&quot; &gt;&gt; .bashrc \n</code></pre>\n<blockquote>\n<p>添加的环境变量需要重启shell会话才会生效<br>也可以通过命令重新加载: <code>source ~/.bashrc</code></p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n"},{"title":"在vscode中设置pylint","date":"2023-11-19T14:09:10.000Z","_content":"\n## 设置全局配置\n\n在vscode中打开`settings.json`, 加入全局配置:\n\n```python\n{\n    \"pylint.args\": [\n        # 通过`--disable`参数标记在全局禁用的规则\n        \"--disable=C0116\", # missing-function-docstring / C0116\n        \"--disable=C0114\", # missing-module-docstring / C0114\n        \"--disable=C0115\", # missing-class-docstring / C0115\n        \"--disable=C0415\", # import-outside-toplevel / C0415\n        \"--disable=R1710\", # inconsistent-return-statements / R1710\n        \"--disable=R0901\", # too-many-ancestors / R0901\n        # `--rcfile`参数用来指定项目独立的配置文件\n        # 此处代表工作区根目录下的`.pylintrc`文件\n        \"--rcfile=${workspaceFolder}/.pylintrc\"\n    ]\n}\n```\n\n这里加入了几个比较烦人的验证, docstring是应该编写的东西, 但有些简单功能甚至单行代码的函数也让写docstring就有些烦人了. 另外如`R1710`验证, 可以看一下下面的代码:\n\n```python\ndef func(num):\n    if num > 0:\n        return True\n```\n\n如果没有禁用R1710,那么就必须在if外面再写一个`return False`. 代码规范是好事, 但有些脱了裤子放屁的强制性规范不要也罢.\n\n## 生成配置文件\n\n在项目根目录下运行命令来生成默认的配置文件:\n\n```bash\npylint --generate-rcfile > .pylintrc\n```\n\n> 建议把`.pylintrc`加入到`.gitignore`文件中\n>\n{: .prompt-tip}\n\n在该文件仲可以加入允许和禁用的检查策略, 或者配置插件\n\n```text\ndisable=raw-checker-failed,\n        bad-inline-option,\n        ...\n\nload-plugins=pylint_django        \n```\n\n[pylint官方配置文档](https://pylint.pycqa.org/en/latest/user_guide/configuration/all-options.html#)\n","source":"_posts/others/pylint-config-in-vscode.md","raw":"---\ntitle: 在vscode中设置pylint\ndate: 2023-11-19 22:09:10 +0800\ncategories: [速查, 配置]\ntags: [pylint, python]\n---\n\n## 设置全局配置\n\n在vscode中打开`settings.json`, 加入全局配置:\n\n```python\n{\n    \"pylint.args\": [\n        # 通过`--disable`参数标记在全局禁用的规则\n        \"--disable=C0116\", # missing-function-docstring / C0116\n        \"--disable=C0114\", # missing-module-docstring / C0114\n        \"--disable=C0115\", # missing-class-docstring / C0115\n        \"--disable=C0415\", # import-outside-toplevel / C0415\n        \"--disable=R1710\", # inconsistent-return-statements / R1710\n        \"--disable=R0901\", # too-many-ancestors / R0901\n        # `--rcfile`参数用来指定项目独立的配置文件\n        # 此处代表工作区根目录下的`.pylintrc`文件\n        \"--rcfile=${workspaceFolder}/.pylintrc\"\n    ]\n}\n```\n\n这里加入了几个比较烦人的验证, docstring是应该编写的东西, 但有些简单功能甚至单行代码的函数也让写docstring就有些烦人了. 另外如`R1710`验证, 可以看一下下面的代码:\n\n```python\ndef func(num):\n    if num > 0:\n        return True\n```\n\n如果没有禁用R1710,那么就必须在if外面再写一个`return False`. 代码规范是好事, 但有些脱了裤子放屁的强制性规范不要也罢.\n\n## 生成配置文件\n\n在项目根目录下运行命令来生成默认的配置文件:\n\n```bash\npylint --generate-rcfile > .pylintrc\n```\n\n> 建议把`.pylintrc`加入到`.gitignore`文件中\n>\n{: .prompt-tip}\n\n在该文件仲可以加入允许和禁用的检查策略, 或者配置插件\n\n```text\ndisable=raw-checker-failed,\n        bad-inline-option,\n        ...\n\nload-plugins=pylint_django        \n```\n\n[pylint官方配置文档](https://pylint.pycqa.org/en/latest/user_guide/configuration/all-options.html#)\n","slug":"others-pylint-config-in-vscode","published":1,"updated":"2023-12-13T08:41:08.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5uw0009i3er2xbtcrxl","content":"<h2 id=\"设置全局配置\"><a href=\"#设置全局配置\" class=\"headerlink\" title=\"设置全局配置\"></a>设置全局配置</h2><p>在vscode中打开<code>settings.json</code>, 加入全局配置:</p>\n<pre><code class=\"python\">&#123;\n    &quot;pylint.args&quot;: [\n        # 通过`--disable`参数标记在全局禁用的规则\n        &quot;--disable=C0116&quot;, # missing-function-docstring / C0116\n        &quot;--disable=C0114&quot;, # missing-module-docstring / C0114\n        &quot;--disable=C0115&quot;, # missing-class-docstring / C0115\n        &quot;--disable=C0415&quot;, # import-outside-toplevel / C0415\n        &quot;--disable=R1710&quot;, # inconsistent-return-statements / R1710\n        &quot;--disable=R0901&quot;, # too-many-ancestors / R0901\n        # `--rcfile`参数用来指定项目独立的配置文件\n        # 此处代表工作区根目录下的`.pylintrc`文件\n        &quot;--rcfile=$&#123;workspaceFolder&#125;/.pylintrc&quot;\n    ]\n&#125;\n</code></pre>\n<p>这里加入了几个比较烦人的验证, docstring是应该编写的东西, 但有些简单功能甚至单行代码的函数也让写docstring就有些烦人了. 另外如<code>R1710</code>验证, 可以看一下下面的代码:</p>\n<pre><code class=\"python\">def func(num):\n    if num &gt; 0:\n        return True\n</code></pre>\n<p>如果没有禁用R1710,那么就必须在if外面再写一个<code>return False</code>. 代码规范是好事, 但有些脱了裤子放屁的强制性规范不要也罢.</p>\n<h2 id=\"生成配置文件\"><a href=\"#生成配置文件\" class=\"headerlink\" title=\"生成配置文件\"></a>生成配置文件</h2><p>在项目根目录下运行命令来生成默认的配置文件:</p>\n<pre><code class=\"bash\">pylint --generate-rcfile &gt; .pylintrc\n</code></pre>\n<blockquote>\n<p>建议把<code>.pylintrc</code>加入到<code>.gitignore</code>文件中</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<p>在该文件仲可以加入允许和禁用的检查策略, 或者配置插件</p>\n<pre><code class=\"text\">disable=raw-checker-failed,\n        bad-inline-option,\n        ...\n\nload-plugins=pylint_django        \n</code></pre>\n<p><a href=\"https://pylint.pycqa.org/en/latest/user_guide/configuration/all-options.html#\">pylint官方配置文档</a></p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"设置全局配置\"><a href=\"#设置全局配置\" class=\"headerlink\" title=\"设置全局配置\"></a>设置全局配置</h2><p>在vscode中打开<code>settings.json</code>, 加入全局配置:</p>\n<pre><code class=\"python\">&#123;\n    &quot;pylint.args&quot;: [\n        # 通过`--disable`参数标记在全局禁用的规则\n        &quot;--disable=C0116&quot;, # missing-function-docstring / C0116\n        &quot;--disable=C0114&quot;, # missing-module-docstring / C0114\n        &quot;--disable=C0115&quot;, # missing-class-docstring / C0115\n        &quot;--disable=C0415&quot;, # import-outside-toplevel / C0415\n        &quot;--disable=R1710&quot;, # inconsistent-return-statements / R1710\n        &quot;--disable=R0901&quot;, # too-many-ancestors / R0901\n        # `--rcfile`参数用来指定项目独立的配置文件\n        # 此处代表工作区根目录下的`.pylintrc`文件\n        &quot;--rcfile=$&#123;workspaceFolder&#125;/.pylintrc&quot;\n    ]\n&#125;\n</code></pre>\n<p>这里加入了几个比较烦人的验证, docstring是应该编写的东西, 但有些简单功能甚至单行代码的函数也让写docstring就有些烦人了. 另外如<code>R1710</code>验证, 可以看一下下面的代码:</p>\n<pre><code class=\"python\">def func(num):\n    if num &gt; 0:\n        return True\n</code></pre>\n<p>如果没有禁用R1710,那么就必须在if外面再写一个<code>return False</code>. 代码规范是好事, 但有些脱了裤子放屁的强制性规范不要也罢.</p>\n<h2 id=\"生成配置文件\"><a href=\"#生成配置文件\" class=\"headerlink\" title=\"生成配置文件\"></a>生成配置文件</h2><p>在项目根目录下运行命令来生成默认的配置文件:</p>\n<pre><code class=\"bash\">pylint --generate-rcfile &gt; .pylintrc\n</code></pre>\n<blockquote>\n<p>建议把<code>.pylintrc</code>加入到<code>.gitignore</code>文件中</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<p>在该文件仲可以加入允许和禁用的检查策略, 或者配置插件</p>\n<pre><code class=\"text\">disable=raw-checker-failed,\n        bad-inline-option,\n        ...\n\nload-plugins=pylint_django        \n</code></pre>\n<p><a href=\"https://pylint.pycqa.org/en/latest/user_guide/configuration/all-options.html#\">pylint官方配置文档</a></p>\n"},{"title":"pylint提示django模型类没有成员","date":"2023-12-13T08:41:08.351Z","_content":"\n在使用Django orm模型类时调用`objects` 成员的方法, 如:\n\n```python\nquery = Character.objects.filter(pk__lt=10)\n```\n\n由于`Character`继承自django的Model类, 而本身没有objects成员变量, 便会导致pylint提示代码出错\n\n**解决方案:**\n\n安装`pylint-django`插件\n\n```bash\npipenv install pylint-django\n```\n\n在`settings.json`配置文件中添加:\n\n```json\n\"pylint.args\": [\n        \"--load-plugins=pylint_django\"\n    ],\n```\n","source":"_posts/others/pylint-django-vscode-no-member-in-models.md","raw":"---\ntitle: pylint提示django模型类没有成员\ndate: 2023-11-11 14:08:51 +08000\ncategories: [速查, 异常]\ntags: [django, pylint, vscode]\n---\n\n在使用Django orm模型类时调用`objects` 成员的方法, 如:\n\n```python\nquery = Character.objects.filter(pk__lt=10)\n```\n\n由于`Character`继承自django的Model类, 而本身没有objects成员变量, 便会导致pylint提示代码出错\n\n**解决方案:**\n\n安装`pylint-django`插件\n\n```bash\npipenv install pylint-django\n```\n\n在`settings.json`配置文件中添加:\n\n```json\n\"pylint.args\": [\n        \"--load-plugins=pylint_django\"\n    ],\n```\n","slug":"others-pylint-django-vscode-no-member-in-models","published":1,"updated":"2023-12-13T08:41:08.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5ux000ai3erbfkj385b","content":"<p>在使用Django orm模型类时调用<code>objects</code> 成员的方法, 如:</p>\n<pre><code class=\"python\">query = Character.objects.filter(pk__lt=10)\n</code></pre>\n<p>由于<code>Character</code>继承自django的Model类, 而本身没有objects成员变量, 便会导致pylint提示代码出错</p>\n<p><strong>解决方案:</strong></p>\n<p>安装<code>pylint-django</code>插件</p>\n<pre><code class=\"bash\">pipenv install pylint-django\n</code></pre>\n<p>在<code>settings.json</code>配置文件中添加:</p>\n<pre><code class=\"json\">&quot;pylint.args&quot;: [\n        &quot;--load-plugins=pylint_django&quot;\n    ],\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>在使用Django orm模型类时调用<code>objects</code> 成员的方法, 如:</p>\n<pre><code class=\"python\">query = Character.objects.filter(pk__lt=10)\n</code></pre>\n<p>由于<code>Character</code>继承自django的Model类, 而本身没有objects成员变量, 便会导致pylint提示代码出错</p>\n<p><strong>解决方案:</strong></p>\n<p>安装<code>pylint-django</code>插件</p>\n<pre><code class=\"bash\">pipenv install pylint-django\n</code></pre>\n<p>在<code>settings.json</code>配置文件中添加:</p>\n<pre><code class=\"json\">&quot;pylint.args&quot;: [\n        &quot;--load-plugins=pylint_django&quot;\n    ],\n</code></pre>\n"},{"title":"Jekyll创建静态博客","date":"2023-12-13T08:41:08.350Z","_content":"\n## 安装依赖包\n\n1. [Ruby](https://www.ruby-lang.org/en/downloads/)\n2. [RubyGems](https://rubygems.org/pages/download)\n3. [GCC](https://gcc.gnu.org/install/)和[Make](https://www.gnu.org/software/make/)\n\n具体安装引导参见[官方文档](https://jekyllrb.com/docs/installation/)\n\n## 安装jekyll\n\n```bash\n   gem install jekyll bundler\n```\n\n> 在安装jekyll时遇到了ruby版本问题, 执行了一下重装命令, 通过brew升级即可\n>\n> ```bash\n> brew install ruby\n> ```\n\n## 创建Jekyll网站\n\n可以是一个已经存在的文件夹, 通过`git clone`创建的文件夹同样可以创建jekyll项目\n\n```bash\n    jekyll new my_site\n```\n\n实话实说, 这一步运行速度感人...\n\n## 进入jekyll目录\n\n```bash\n    cd my_site\n```\n\n## 启动本地服务\n\n```bash\n    bundle exec jekyll serve\n```\n","source":"_posts/others/jekyll-quickstart.md","raw":"---\ntitle: Jekyll创建静态博客\ndate: 2023-11-11 14:02:00 +08000\ncategories: [笔记, jekyll]\ntags: [jekyll]\n---\n\n## 安装依赖包\n\n1. [Ruby](https://www.ruby-lang.org/en/downloads/)\n2. [RubyGems](https://rubygems.org/pages/download)\n3. [GCC](https://gcc.gnu.org/install/)和[Make](https://www.gnu.org/software/make/)\n\n具体安装引导参见[官方文档](https://jekyllrb.com/docs/installation/)\n\n## 安装jekyll\n\n```bash\n   gem install jekyll bundler\n```\n\n> 在安装jekyll时遇到了ruby版本问题, 执行了一下重装命令, 通过brew升级即可\n>\n> ```bash\n> brew install ruby\n> ```\n\n## 创建Jekyll网站\n\n可以是一个已经存在的文件夹, 通过`git clone`创建的文件夹同样可以创建jekyll项目\n\n```bash\n    jekyll new my_site\n```\n\n实话实说, 这一步运行速度感人...\n\n## 进入jekyll目录\n\n```bash\n    cd my_site\n```\n\n## 启动本地服务\n\n```bash\n    bundle exec jekyll serve\n```\n","slug":"others-jekyll-quickstart","published":1,"updated":"2023-12-13T08:41:08.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5ux000di3er7oi7cu97","content":"<h2 id=\"安装依赖包\"><a href=\"#安装依赖包\" class=\"headerlink\" title=\"安装依赖包\"></a>安装依赖包</h2><ol>\n<li><a href=\"https://www.ruby-lang.org/en/downloads/\">Ruby</a></li>\n<li><a href=\"https://rubygems.org/pages/download\">RubyGems</a></li>\n<li><a href=\"https://gcc.gnu.org/install/\">GCC</a>和<a href=\"https://www.gnu.org/software/make/\">Make</a></li>\n</ol>\n<p>具体安装引导参见<a href=\"https://jekyllrb.com/docs/installation/\">官方文档</a></p>\n<h2 id=\"安装jekyll\"><a href=\"#安装jekyll\" class=\"headerlink\" title=\"安装jekyll\"></a>安装jekyll</h2><pre><code class=\"bash\">   gem install jekyll bundler\n</code></pre>\n<blockquote>\n<p>在安装jekyll时遇到了ruby版本问题, 执行了一下重装命令, 通过brew升级即可</p>\n<pre><code class=\"bash\">brew install ruby\n</code></pre>\n</blockquote>\n<h2 id=\"创建Jekyll网站\"><a href=\"#创建Jekyll网站\" class=\"headerlink\" title=\"创建Jekyll网站\"></a>创建Jekyll网站</h2><p>可以是一个已经存在的文件夹, 通过<code>git clone</code>创建的文件夹同样可以创建jekyll项目</p>\n<pre><code class=\"bash\">    jekyll new my_site\n</code></pre>\n<p>实话实说, 这一步运行速度感人…</p>\n<h2 id=\"进入jekyll目录\"><a href=\"#进入jekyll目录\" class=\"headerlink\" title=\"进入jekyll目录\"></a>进入jekyll目录</h2><pre><code class=\"bash\">    cd my_site\n</code></pre>\n<h2 id=\"启动本地服务\"><a href=\"#启动本地服务\" class=\"headerlink\" title=\"启动本地服务\"></a>启动本地服务</h2><pre><code class=\"bash\">    bundle exec jekyll serve\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"安装依赖包\"><a href=\"#安装依赖包\" class=\"headerlink\" title=\"安装依赖包\"></a>安装依赖包</h2><ol>\n<li><a href=\"https://www.ruby-lang.org/en/downloads/\">Ruby</a></li>\n<li><a href=\"https://rubygems.org/pages/download\">RubyGems</a></li>\n<li><a href=\"https://gcc.gnu.org/install/\">GCC</a>和<a href=\"https://www.gnu.org/software/make/\">Make</a></li>\n</ol>\n<p>具体安装引导参见<a href=\"https://jekyllrb.com/docs/installation/\">官方文档</a></p>\n<h2 id=\"安装jekyll\"><a href=\"#安装jekyll\" class=\"headerlink\" title=\"安装jekyll\"></a>安装jekyll</h2><pre><code class=\"bash\">   gem install jekyll bundler\n</code></pre>\n<blockquote>\n<p>在安装jekyll时遇到了ruby版本问题, 执行了一下重装命令, 通过brew升级即可</p>\n<pre><code class=\"bash\">brew install ruby\n</code></pre>\n</blockquote>\n<h2 id=\"创建Jekyll网站\"><a href=\"#创建Jekyll网站\" class=\"headerlink\" title=\"创建Jekyll网站\"></a>创建Jekyll网站</h2><p>可以是一个已经存在的文件夹, 通过<code>git clone</code>创建的文件夹同样可以创建jekyll项目</p>\n<pre><code class=\"bash\">    jekyll new my_site\n</code></pre>\n<p>实话实说, 这一步运行速度感人…</p>\n<h2 id=\"进入jekyll目录\"><a href=\"#进入jekyll目录\" class=\"headerlink\" title=\"进入jekyll目录\"></a>进入jekyll目录</h2><pre><code class=\"bash\">    cd my_site\n</code></pre>\n<h2 id=\"启动本地服务\"><a href=\"#启动本地服务\" class=\"headerlink\" title=\"启动本地服务\"></a>启动本地服务</h2><pre><code class=\"bash\">    bundle exec jekyll serve\n</code></pre>\n"},{"title":"数据库学习笔记","date":"2023-11-14T18:52:57.000Z","_content":"\n## MySQL 基本语法\n\n### SELECT\n\n```sql\nSELECT *\nFROM MOCK_DATA\nWHERE points>100\nORDER BY points desc\nLIMIT 100\n```\n\n#### JOIN\n\n`INNER JOIN` 根据两个表的关联字段查询, 得到一张包含全部字段的表, 也可以指定要查询的字段. `INNER` 关键字可以省略, 直接写成`JOIN`\n\n连接多个表使用多个 `join ... on ...` 语句即可.\n\n```sql\nSELECT *\nFROM mock_orders o\nJOIN mock_user_profile u\nON u.id = o.user_id\n```\n\n`self joinn`, 通常用在一个表中包含一个字段是表中另外一条记录的主键时使用. 比如一个人员信息表, 每个人有独立的id, 同时有一个字段记录父亲的id等等.\n\n```sql\nSELECT \n    t1.id as user_id, \n    t1.name as user_name, \n    t2.name as faher\nFROM user_info t1\nJOIN user_info t2\nON t1.fater_id = t2.id\n```\n\n#### OUTER JOIN\n\n外联查询, 包含左外联`LEFT OUTER JOIN`和右外联`RIGHT OUTER JOIN`两种, `OUTER`关键字可以省略\n\n```sql\nSELECT *\nFROM mock_user_profile u\nLEFT JOIN mock_orders o\n    on u.id = o.user_id\n```\n\n左外联的意思是, 无论关联条件是否满足, 左边的表, 即主表, `FROM`关键字后边的表, 上例中的`u`, 数据全部显示, 不符合条件的数据字段空置\n右外联则是链接表, `JOIN`关键字后边的表, 数据全部显示.\n\n#### USING\n\n如果两个表包含同名字段, 可以使用`USING`关键字进行链接, 省略`ON`子句, 相当于指定两个表的某个字段相等\n\n```sql\nSELECT * \nFROM users\nJOIN user_profile USING (id)\n```\n\n#### CROSS JOIN\n\n把两个表的所有数据进行交叉匹配, 比较少用, 在类似于创建组合的时候会用到, 比如用所有的尺码型号匹配所有的颜色.\n\n当有5种尺码, 3种颜色, 就会有15条插叙年数据.\n\n```sql\nSELECT *\nFROM sizes\nCROSS JOIN colors\n```\n\n#### UNION\n\n将两个查询的数据上下合并到同一个表里, 要求字段数量必须相同, 类型可以不同.\n\n```sql\nSELECT u.first_name, u.points\nFROM mock_user_profile u\nUNION\nSELECT c.id, c.title\nFROM store_collection c\n```\n\n### INSERT INTO\n\n在不指定插入列的情况下, 数据的数量必须与表定义相同.\n\n`DEFAULT`: 代表默认值, 如对自增主键来说, 默认值为 +1\n`NULL`: 字段空值\n\n```sql\nINSERT INTO store_collection\nVALUE (DEFAULT,'new collection', NULL)\n```\n\n或者指定要插入数据的字段名, 省略的字段必须存在默认值, 同时`VALUES`关键字可以一次加入多条数据.\n\n```sql\nINSERT INTO store_collection (title)\nVALUES  ('new collection title1'),\n        ('new collection title2'),\n        ('new collection title3')\n```\n\n也可以将某个表中的数据整体插入到另一个表中, 常用来进行过期数据归档\n\n```sql\nINSERT INTO store_collection_archived\nSELECT * FROM store_collection WHERE store_collection.id < 10\n```\n\n### CREATE TABLE AS\n\n通过子查询创建新表, 可以用于数据表的备份, 归档, 也可以将查询的结果集独立保存等.\n\n```sql\nCREATE TABLE collection_archived AS \n    SELECT * from store_collection\n```\n\n### UPDATE\n\n`SET`子句中, 多个值之间用`,`隔开\n`WHERE`子句中, 多个条件之间用`AND`隔开\n\n```sql\nUPDATE store_product\nSET title='update title', unit_price=299.99\nWHERE id=1000;\n```\n\n也可以利用查询子句动态判断查询条件, 一个稍微复杂的更新例子\n\n订单表保存订单的基本信息, 订单项表保存了每个订单包含的产品和购买数量.\n\n根据订单号, 查询到具体的产品, 并根据订单数量更新产品的库存数据.\n\n```sql\nUPDATE store_product\nSET inventory = inventory - (\n        SELECT oi.quantity\n        FROM store_order o\n        JOIN store_orderitem oi\n        WHERE o.id=oi.order_id and o.id=357\n    )\nWHERE id in\n    (SELECT oi.product_id\n    FROM store_order o\n    JOIN store_orderitem oi\n    WHERE o.id=oi.order_id and o.id=357\n    );\n```\n\n> 作为假想需求和练习代码, 只是在逻辑上可以执行, 并非真实解决方案.\n>\n{: .prompt-info}\n\n> 实际运行中可能会出错, 因为订单包含的产品可能不止一个, 但是MySQL默认执行`SafeUpdate`, 一次仅能更新一条数据. 可以根据不同的IDE进行设置.\n>\n{: .prompt-tip}\n\n### DELETE\n\n```sql\nDELETE FROM store_product\nWHERE id > 2000\n```\n\n## 统计函数\n\nMySQL提供了一下函数用来方便的进行数据统计\n\n```sql\nSELECT\n    MAX(unit_price),                --最大值\n    MIN(unit_price),                --最小值\n    AVG(unit_price),                --平均值\n    SUM(unit_price * inventory),    --总和\n    COUNT(description),             --总数, 仅统计非空值\n    COUNT(*)                        --总数, 统计总行书\nFROM store_product\nWHERE unit_price > 50;\n```\n\n### GROUP BY\n\n配合统计函数, 根据特定字段进行分组\n\n```sql\nSELECT collection_id, SUM(unit_price * inventory), COUNT(id)\nFROM store_product\nGROUP BY collection_id\n```\n\n> 计算每个分类的产品总数和总值\n>\n{: .prompt-info}\n\n### HAVING\n\n作用于WHERE子句类似, 区别在于`HAVING`子句用来在分组结束之后进行条件判断\n\n```sql\nSELECT collection_id, SUM(unit_price * inventory), COUNT(id) as product_count\nFROM store_product\nWHERE unit_price > 20\nGROUP BY collection_id\nHAVING product_count > 200\n```\n\n> 人话: 在单价大于20的产品里, 统计各个分类的产品总值和产品数量, 看看有没有数量大于200的\n>\n{: .prompt-info}\n\n## 子查询\n\n可以将一个查询语句的结果作为参数传递给另外一个查询的表达式\n\n```sql\nSELECT\n    id, title, unit_price\nFROM store_product\nWHERE unit_price > (\n        SELECT MAX(unit_price)\n        FROM store_product\n        WHERE title REGEXP 'coffe'\n    );\n```\n\n> 人话: 列出比价格最高的咖啡还贵的产品的id,名字和价格.\n>\n{: .prompt-info}\n\n```sql\nSELECT *\nFROM store_product\nWHERE id in (\n        SELECT DISTINCT product_id\n        FROM store_orderitem\n    )\n```\n\n> 人话: 找到所有被下过订单的产品\n>\n{: .prompt-info}\n\n```sql\nSELECT *\nFROM store_customer\nWHERE id in (\n        SELECT o.customer_id\n        FROM store_order o\n        JOIN store_orderitem oi\n        ON o.id = oi.order_id\n        WHERE oi.product_id = 616\n    )\n```\n\n> 人话: 所有曾经买过id为 `616` 的产品的用户信息\n>\n{: .prompt-info}\n","source":"_posts/others/note-for-learn-mysql.md","raw":"---\ntitle: 数据库学习笔记\ndate: 2023-11-15 02:52:57 +0800\ncategories: [笔记, 数据库]\ntags: [Database, MySQL]\n---\n\n## MySQL 基本语法\n\n### SELECT\n\n```sql\nSELECT *\nFROM MOCK_DATA\nWHERE points>100\nORDER BY points desc\nLIMIT 100\n```\n\n#### JOIN\n\n`INNER JOIN` 根据两个表的关联字段查询, 得到一张包含全部字段的表, 也可以指定要查询的字段. `INNER` 关键字可以省略, 直接写成`JOIN`\n\n连接多个表使用多个 `join ... on ...` 语句即可.\n\n```sql\nSELECT *\nFROM mock_orders o\nJOIN mock_user_profile u\nON u.id = o.user_id\n```\n\n`self joinn`, 通常用在一个表中包含一个字段是表中另外一条记录的主键时使用. 比如一个人员信息表, 每个人有独立的id, 同时有一个字段记录父亲的id等等.\n\n```sql\nSELECT \n    t1.id as user_id, \n    t1.name as user_name, \n    t2.name as faher\nFROM user_info t1\nJOIN user_info t2\nON t1.fater_id = t2.id\n```\n\n#### OUTER JOIN\n\n外联查询, 包含左外联`LEFT OUTER JOIN`和右外联`RIGHT OUTER JOIN`两种, `OUTER`关键字可以省略\n\n```sql\nSELECT *\nFROM mock_user_profile u\nLEFT JOIN mock_orders o\n    on u.id = o.user_id\n```\n\n左外联的意思是, 无论关联条件是否满足, 左边的表, 即主表, `FROM`关键字后边的表, 上例中的`u`, 数据全部显示, 不符合条件的数据字段空置\n右外联则是链接表, `JOIN`关键字后边的表, 数据全部显示.\n\n#### USING\n\n如果两个表包含同名字段, 可以使用`USING`关键字进行链接, 省略`ON`子句, 相当于指定两个表的某个字段相等\n\n```sql\nSELECT * \nFROM users\nJOIN user_profile USING (id)\n```\n\n#### CROSS JOIN\n\n把两个表的所有数据进行交叉匹配, 比较少用, 在类似于创建组合的时候会用到, 比如用所有的尺码型号匹配所有的颜色.\n\n当有5种尺码, 3种颜色, 就会有15条插叙年数据.\n\n```sql\nSELECT *\nFROM sizes\nCROSS JOIN colors\n```\n\n#### UNION\n\n将两个查询的数据上下合并到同一个表里, 要求字段数量必须相同, 类型可以不同.\n\n```sql\nSELECT u.first_name, u.points\nFROM mock_user_profile u\nUNION\nSELECT c.id, c.title\nFROM store_collection c\n```\n\n### INSERT INTO\n\n在不指定插入列的情况下, 数据的数量必须与表定义相同.\n\n`DEFAULT`: 代表默认值, 如对自增主键来说, 默认值为 +1\n`NULL`: 字段空值\n\n```sql\nINSERT INTO store_collection\nVALUE (DEFAULT,'new collection', NULL)\n```\n\n或者指定要插入数据的字段名, 省略的字段必须存在默认值, 同时`VALUES`关键字可以一次加入多条数据.\n\n```sql\nINSERT INTO store_collection (title)\nVALUES  ('new collection title1'),\n        ('new collection title2'),\n        ('new collection title3')\n```\n\n也可以将某个表中的数据整体插入到另一个表中, 常用来进行过期数据归档\n\n```sql\nINSERT INTO store_collection_archived\nSELECT * FROM store_collection WHERE store_collection.id < 10\n```\n\n### CREATE TABLE AS\n\n通过子查询创建新表, 可以用于数据表的备份, 归档, 也可以将查询的结果集独立保存等.\n\n```sql\nCREATE TABLE collection_archived AS \n    SELECT * from store_collection\n```\n\n### UPDATE\n\n`SET`子句中, 多个值之间用`,`隔开\n`WHERE`子句中, 多个条件之间用`AND`隔开\n\n```sql\nUPDATE store_product\nSET title='update title', unit_price=299.99\nWHERE id=1000;\n```\n\n也可以利用查询子句动态判断查询条件, 一个稍微复杂的更新例子\n\n订单表保存订单的基本信息, 订单项表保存了每个订单包含的产品和购买数量.\n\n根据订单号, 查询到具体的产品, 并根据订单数量更新产品的库存数据.\n\n```sql\nUPDATE store_product\nSET inventory = inventory - (\n        SELECT oi.quantity\n        FROM store_order o\n        JOIN store_orderitem oi\n        WHERE o.id=oi.order_id and o.id=357\n    )\nWHERE id in\n    (SELECT oi.product_id\n    FROM store_order o\n    JOIN store_orderitem oi\n    WHERE o.id=oi.order_id and o.id=357\n    );\n```\n\n> 作为假想需求和练习代码, 只是在逻辑上可以执行, 并非真实解决方案.\n>\n{: .prompt-info}\n\n> 实际运行中可能会出错, 因为订单包含的产品可能不止一个, 但是MySQL默认执行`SafeUpdate`, 一次仅能更新一条数据. 可以根据不同的IDE进行设置.\n>\n{: .prompt-tip}\n\n### DELETE\n\n```sql\nDELETE FROM store_product\nWHERE id > 2000\n```\n\n## 统计函数\n\nMySQL提供了一下函数用来方便的进行数据统计\n\n```sql\nSELECT\n    MAX(unit_price),                --最大值\n    MIN(unit_price),                --最小值\n    AVG(unit_price),                --平均值\n    SUM(unit_price * inventory),    --总和\n    COUNT(description),             --总数, 仅统计非空值\n    COUNT(*)                        --总数, 统计总行书\nFROM store_product\nWHERE unit_price > 50;\n```\n\n### GROUP BY\n\n配合统计函数, 根据特定字段进行分组\n\n```sql\nSELECT collection_id, SUM(unit_price * inventory), COUNT(id)\nFROM store_product\nGROUP BY collection_id\n```\n\n> 计算每个分类的产品总数和总值\n>\n{: .prompt-info}\n\n### HAVING\n\n作用于WHERE子句类似, 区别在于`HAVING`子句用来在分组结束之后进行条件判断\n\n```sql\nSELECT collection_id, SUM(unit_price * inventory), COUNT(id) as product_count\nFROM store_product\nWHERE unit_price > 20\nGROUP BY collection_id\nHAVING product_count > 200\n```\n\n> 人话: 在单价大于20的产品里, 统计各个分类的产品总值和产品数量, 看看有没有数量大于200的\n>\n{: .prompt-info}\n\n## 子查询\n\n可以将一个查询语句的结果作为参数传递给另外一个查询的表达式\n\n```sql\nSELECT\n    id, title, unit_price\nFROM store_product\nWHERE unit_price > (\n        SELECT MAX(unit_price)\n        FROM store_product\n        WHERE title REGEXP 'coffe'\n    );\n```\n\n> 人话: 列出比价格最高的咖啡还贵的产品的id,名字和价格.\n>\n{: .prompt-info}\n\n```sql\nSELECT *\nFROM store_product\nWHERE id in (\n        SELECT DISTINCT product_id\n        FROM store_orderitem\n    )\n```\n\n> 人话: 找到所有被下过订单的产品\n>\n{: .prompt-info}\n\n```sql\nSELECT *\nFROM store_customer\nWHERE id in (\n        SELECT o.customer_id\n        FROM store_order o\n        JOIN store_orderitem oi\n        ON o.id = oi.order_id\n        WHERE oi.product_id = 616\n    )\n```\n\n> 人话: 所有曾经买过id为 `616` 的产品的用户信息\n>\n{: .prompt-info}\n","slug":"others-note-for-learn-mysql","published":1,"updated":"2023-12-13T08:41:08.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5ux000ei3ercxxn5wnr","content":"<h2 id=\"MySQL-基本语法\"><a href=\"#MySQL-基本语法\" class=\"headerlink\" title=\"MySQL 基本语法\"></a>MySQL 基本语法</h2><h3 id=\"SELECT\"><a href=\"#SELECT\" class=\"headerlink\" title=\"SELECT\"></a>SELECT</h3><pre><code class=\"sql\">SELECT *\nFROM MOCK_DATA\nWHERE points&gt;100\nORDER BY points desc\nLIMIT 100\n</code></pre>\n<h4 id=\"JOIN\"><a href=\"#JOIN\" class=\"headerlink\" title=\"JOIN\"></a>JOIN</h4><p><code>INNER JOIN</code> 根据两个表的关联字段查询, 得到一张包含全部字段的表, 也可以指定要查询的字段. <code>INNER</code> 关键字可以省略, 直接写成<code>JOIN</code></p>\n<p>连接多个表使用多个 <code>join ... on ...</code> 语句即可.</p>\n<pre><code class=\"sql\">SELECT *\nFROM mock_orders o\nJOIN mock_user_profile u\nON u.id = o.user_id\n</code></pre>\n<p><code>self joinn</code>, 通常用在一个表中包含一个字段是表中另外一条记录的主键时使用. 比如一个人员信息表, 每个人有独立的id, 同时有一个字段记录父亲的id等等.</p>\n<pre><code class=\"sql\">SELECT \n    t1.id as user_id, \n    t1.name as user_name, \n    t2.name as faher\nFROM user_info t1\nJOIN user_info t2\nON t1.fater_id = t2.id\n</code></pre>\n<h4 id=\"OUTER-JOIN\"><a href=\"#OUTER-JOIN\" class=\"headerlink\" title=\"OUTER JOIN\"></a>OUTER JOIN</h4><p>外联查询, 包含左外联<code>LEFT OUTER JOIN</code>和右外联<code>RIGHT OUTER JOIN</code>两种, <code>OUTER</code>关键字可以省略</p>\n<pre><code class=\"sql\">SELECT *\nFROM mock_user_profile u\nLEFT JOIN mock_orders o\n    on u.id = o.user_id\n</code></pre>\n<p>左外联的意思是, 无论关联条件是否满足, 左边的表, 即主表, <code>FROM</code>关键字后边的表, 上例中的<code>u</code>, 数据全部显示, 不符合条件的数据字段空置<br>右外联则是链接表, <code>JOIN</code>关键字后边的表, 数据全部显示.</p>\n<h4 id=\"USING\"><a href=\"#USING\" class=\"headerlink\" title=\"USING\"></a>USING</h4><p>如果两个表包含同名字段, 可以使用<code>USING</code>关键字进行链接, 省略<code>ON</code>子句, 相当于指定两个表的某个字段相等</p>\n<pre><code class=\"sql\">SELECT * \nFROM users\nJOIN user_profile USING (id)\n</code></pre>\n<h4 id=\"CROSS-JOIN\"><a href=\"#CROSS-JOIN\" class=\"headerlink\" title=\"CROSS JOIN\"></a>CROSS JOIN</h4><p>把两个表的所有数据进行交叉匹配, 比较少用, 在类似于创建组合的时候会用到, 比如用所有的尺码型号匹配所有的颜色.</p>\n<p>当有5种尺码, 3种颜色, 就会有15条插叙年数据.</p>\n<pre><code class=\"sql\">SELECT *\nFROM sizes\nCROSS JOIN colors\n</code></pre>\n<h4 id=\"UNION\"><a href=\"#UNION\" class=\"headerlink\" title=\"UNION\"></a>UNION</h4><p>将两个查询的数据上下合并到同一个表里, 要求字段数量必须相同, 类型可以不同.</p>\n<pre><code class=\"sql\">SELECT u.first_name, u.points\nFROM mock_user_profile u\nUNION\nSELECT c.id, c.title\nFROM store_collection c\n</code></pre>\n<h3 id=\"INSERT-INTO\"><a href=\"#INSERT-INTO\" class=\"headerlink\" title=\"INSERT INTO\"></a>INSERT INTO</h3><p>在不指定插入列的情况下, 数据的数量必须与表定义相同.</p>\n<p><code>DEFAULT</code>: 代表默认值, 如对自增主键来说, 默认值为 +1<br><code>NULL</code>: 字段空值</p>\n<pre><code class=\"sql\">INSERT INTO store_collection\nVALUE (DEFAULT,&#39;new collection&#39;, NULL)\n</code></pre>\n<p>或者指定要插入数据的字段名, 省略的字段必须存在默认值, 同时<code>VALUES</code>关键字可以一次加入多条数据.</p>\n<pre><code class=\"sql\">INSERT INTO store_collection (title)\nVALUES  (&#39;new collection title1&#39;),\n        (&#39;new collection title2&#39;),\n        (&#39;new collection title3&#39;)\n</code></pre>\n<p>也可以将某个表中的数据整体插入到另一个表中, 常用来进行过期数据归档</p>\n<pre><code class=\"sql\">INSERT INTO store_collection_archived\nSELECT * FROM store_collection WHERE store_collection.id &lt; 10\n</code></pre>\n<h3 id=\"CREATE-TABLE-AS\"><a href=\"#CREATE-TABLE-AS\" class=\"headerlink\" title=\"CREATE TABLE AS\"></a>CREATE TABLE AS</h3><p>通过子查询创建新表, 可以用于数据表的备份, 归档, 也可以将查询的结果集独立保存等.</p>\n<pre><code class=\"sql\">CREATE TABLE collection_archived AS \n    SELECT * from store_collection\n</code></pre>\n<h3 id=\"UPDATE\"><a href=\"#UPDATE\" class=\"headerlink\" title=\"UPDATE\"></a>UPDATE</h3><p><code>SET</code>子句中, 多个值之间用<code>,</code>隔开<br><code>WHERE</code>子句中, 多个条件之间用<code>AND</code>隔开</p>\n<pre><code class=\"sql\">UPDATE store_product\nSET title=&#39;update title&#39;, unit_price=299.99\nWHERE id=1000;\n</code></pre>\n<p>也可以利用查询子句动态判断查询条件, 一个稍微复杂的更新例子</p>\n<p>订单表保存订单的基本信息, 订单项表保存了每个订单包含的产品和购买数量.</p>\n<p>根据订单号, 查询到具体的产品, 并根据订单数量更新产品的库存数据.</p>\n<pre><code class=\"sql\">UPDATE store_product\nSET inventory = inventory - (\n        SELECT oi.quantity\n        FROM store_order o\n        JOIN store_orderitem oi\n        WHERE o.id=oi.order_id and o.id=357\n    )\nWHERE id in\n    (SELECT oi.product_id\n    FROM store_order o\n    JOIN store_orderitem oi\n    WHERE o.id=oi.order_id and o.id=357\n    );\n</code></pre>\n<blockquote>\n<p>作为假想需求和练习代码, 只是在逻辑上可以执行, 并非真实解决方案.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<blockquote>\n<p>实际运行中可能会出错, 因为订单包含的产品可能不止一个, 但是MySQL默认执行<code>SafeUpdate</code>, 一次仅能更新一条数据. 可以根据不同的IDE进行设置.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h3 id=\"DELETE\"><a href=\"#DELETE\" class=\"headerlink\" title=\"DELETE\"></a>DELETE</h3><pre><code class=\"sql\">DELETE FROM store_product\nWHERE id &gt; 2000\n</code></pre>\n<h2 id=\"统计函数\"><a href=\"#统计函数\" class=\"headerlink\" title=\"统计函数\"></a>统计函数</h2><p>MySQL提供了一下函数用来方便的进行数据统计</p>\n<pre><code class=\"sql\">SELECT\n    MAX(unit_price),                --最大值\n    MIN(unit_price),                --最小值\n    AVG(unit_price),                --平均值\n    SUM(unit_price * inventory),    --总和\n    COUNT(description),             --总数, 仅统计非空值\n    COUNT(*)                        --总数, 统计总行书\nFROM store_product\nWHERE unit_price &gt; 50;\n</code></pre>\n<h3 id=\"GROUP-BY\"><a href=\"#GROUP-BY\" class=\"headerlink\" title=\"GROUP BY\"></a>GROUP BY</h3><p>配合统计函数, 根据特定字段进行分组</p>\n<pre><code class=\"sql\">SELECT collection_id, SUM(unit_price * inventory), COUNT(id)\nFROM store_product\nGROUP BY collection_id\n</code></pre>\n<blockquote>\n<p>计算每个分类的产品总数和总值</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<h3 id=\"HAVING\"><a href=\"#HAVING\" class=\"headerlink\" title=\"HAVING\"></a>HAVING</h3><p>作用于WHERE子句类似, 区别在于<code>HAVING</code>子句用来在分组结束之后进行条件判断</p>\n<pre><code class=\"sql\">SELECT collection_id, SUM(unit_price * inventory), COUNT(id) as product_count\nFROM store_product\nWHERE unit_price &gt; 20\nGROUP BY collection_id\nHAVING product_count &gt; 200\n</code></pre>\n<blockquote>\n<p>人话: 在单价大于20的产品里, 统计各个分类的产品总值和产品数量, 看看有没有数量大于200的</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<h2 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2><p>可以将一个查询语句的结果作为参数传递给另外一个查询的表达式</p>\n<pre><code class=\"sql\">SELECT\n    id, title, unit_price\nFROM store_product\nWHERE unit_price &gt; (\n        SELECT MAX(unit_price)\n        FROM store_product\n        WHERE title REGEXP &#39;coffe&#39;\n    );\n</code></pre>\n<blockquote>\n<p>人话: 列出比价格最高的咖啡还贵的产品的id,名字和价格.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<pre><code class=\"sql\">SELECT *\nFROM store_product\nWHERE id in (\n        SELECT DISTINCT product_id\n        FROM store_orderitem\n    )\n</code></pre>\n<blockquote>\n<p>人话: 找到所有被下过订单的产品</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<pre><code class=\"sql\">SELECT *\nFROM store_customer\nWHERE id in (\n        SELECT o.customer_id\n        FROM store_order o\n        JOIN store_orderitem oi\n        ON o.id = oi.order_id\n        WHERE oi.product_id = 616\n    )\n</code></pre>\n<blockquote>\n<p>人话: 所有曾经买过id为 <code>616</code> 的产品的用户信息</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"MySQL-基本语法\"><a href=\"#MySQL-基本语法\" class=\"headerlink\" title=\"MySQL 基本语法\"></a>MySQL 基本语法</h2><h3 id=\"SELECT\"><a href=\"#SELECT\" class=\"headerlink\" title=\"SELECT\"></a>SELECT</h3><pre><code class=\"sql\">SELECT *\nFROM MOCK_DATA\nWHERE points&gt;100\nORDER BY points desc\nLIMIT 100\n</code></pre>\n<h4 id=\"JOIN\"><a href=\"#JOIN\" class=\"headerlink\" title=\"JOIN\"></a>JOIN</h4><p><code>INNER JOIN</code> 根据两个表的关联字段查询, 得到一张包含全部字段的表, 也可以指定要查询的字段. <code>INNER</code> 关键字可以省略, 直接写成<code>JOIN</code></p>\n<p>连接多个表使用多个 <code>join ... on ...</code> 语句即可.</p>\n<pre><code class=\"sql\">SELECT *\nFROM mock_orders o\nJOIN mock_user_profile u\nON u.id = o.user_id\n</code></pre>\n<p><code>self joinn</code>, 通常用在一个表中包含一个字段是表中另外一条记录的主键时使用. 比如一个人员信息表, 每个人有独立的id, 同时有一个字段记录父亲的id等等.</p>\n<pre><code class=\"sql\">SELECT \n    t1.id as user_id, \n    t1.name as user_name, \n    t2.name as faher\nFROM user_info t1\nJOIN user_info t2\nON t1.fater_id = t2.id\n</code></pre>\n<h4 id=\"OUTER-JOIN\"><a href=\"#OUTER-JOIN\" class=\"headerlink\" title=\"OUTER JOIN\"></a>OUTER JOIN</h4><p>外联查询, 包含左外联<code>LEFT OUTER JOIN</code>和右外联<code>RIGHT OUTER JOIN</code>两种, <code>OUTER</code>关键字可以省略</p>\n<pre><code class=\"sql\">SELECT *\nFROM mock_user_profile u\nLEFT JOIN mock_orders o\n    on u.id = o.user_id\n</code></pre>\n<p>左外联的意思是, 无论关联条件是否满足, 左边的表, 即主表, <code>FROM</code>关键字后边的表, 上例中的<code>u</code>, 数据全部显示, 不符合条件的数据字段空置<br>右外联则是链接表, <code>JOIN</code>关键字后边的表, 数据全部显示.</p>\n<h4 id=\"USING\"><a href=\"#USING\" class=\"headerlink\" title=\"USING\"></a>USING</h4><p>如果两个表包含同名字段, 可以使用<code>USING</code>关键字进行链接, 省略<code>ON</code>子句, 相当于指定两个表的某个字段相等</p>\n<pre><code class=\"sql\">SELECT * \nFROM users\nJOIN user_profile USING (id)\n</code></pre>\n<h4 id=\"CROSS-JOIN\"><a href=\"#CROSS-JOIN\" class=\"headerlink\" title=\"CROSS JOIN\"></a>CROSS JOIN</h4><p>把两个表的所有数据进行交叉匹配, 比较少用, 在类似于创建组合的时候会用到, 比如用所有的尺码型号匹配所有的颜色.</p>\n<p>当有5种尺码, 3种颜色, 就会有15条插叙年数据.</p>\n<pre><code class=\"sql\">SELECT *\nFROM sizes\nCROSS JOIN colors\n</code></pre>\n<h4 id=\"UNION\"><a href=\"#UNION\" class=\"headerlink\" title=\"UNION\"></a>UNION</h4><p>将两个查询的数据上下合并到同一个表里, 要求字段数量必须相同, 类型可以不同.</p>\n<pre><code class=\"sql\">SELECT u.first_name, u.points\nFROM mock_user_profile u\nUNION\nSELECT c.id, c.title\nFROM store_collection c\n</code></pre>\n<h3 id=\"INSERT-INTO\"><a href=\"#INSERT-INTO\" class=\"headerlink\" title=\"INSERT INTO\"></a>INSERT INTO</h3><p>在不指定插入列的情况下, 数据的数量必须与表定义相同.</p>\n<p><code>DEFAULT</code>: 代表默认值, 如对自增主键来说, 默认值为 +1<br><code>NULL</code>: 字段空值</p>\n<pre><code class=\"sql\">INSERT INTO store_collection\nVALUE (DEFAULT,&#39;new collection&#39;, NULL)\n</code></pre>\n<p>或者指定要插入数据的字段名, 省略的字段必须存在默认值, 同时<code>VALUES</code>关键字可以一次加入多条数据.</p>\n<pre><code class=\"sql\">INSERT INTO store_collection (title)\nVALUES  (&#39;new collection title1&#39;),\n        (&#39;new collection title2&#39;),\n        (&#39;new collection title3&#39;)\n</code></pre>\n<p>也可以将某个表中的数据整体插入到另一个表中, 常用来进行过期数据归档</p>\n<pre><code class=\"sql\">INSERT INTO store_collection_archived\nSELECT * FROM store_collection WHERE store_collection.id &lt; 10\n</code></pre>\n<h3 id=\"CREATE-TABLE-AS\"><a href=\"#CREATE-TABLE-AS\" class=\"headerlink\" title=\"CREATE TABLE AS\"></a>CREATE TABLE AS</h3><p>通过子查询创建新表, 可以用于数据表的备份, 归档, 也可以将查询的结果集独立保存等.</p>\n<pre><code class=\"sql\">CREATE TABLE collection_archived AS \n    SELECT * from store_collection\n</code></pre>\n<h3 id=\"UPDATE\"><a href=\"#UPDATE\" class=\"headerlink\" title=\"UPDATE\"></a>UPDATE</h3><p><code>SET</code>子句中, 多个值之间用<code>,</code>隔开<br><code>WHERE</code>子句中, 多个条件之间用<code>AND</code>隔开</p>\n<pre><code class=\"sql\">UPDATE store_product\nSET title=&#39;update title&#39;, unit_price=299.99\nWHERE id=1000;\n</code></pre>\n<p>也可以利用查询子句动态判断查询条件, 一个稍微复杂的更新例子</p>\n<p>订单表保存订单的基本信息, 订单项表保存了每个订单包含的产品和购买数量.</p>\n<p>根据订单号, 查询到具体的产品, 并根据订单数量更新产品的库存数据.</p>\n<pre><code class=\"sql\">UPDATE store_product\nSET inventory = inventory - (\n        SELECT oi.quantity\n        FROM store_order o\n        JOIN store_orderitem oi\n        WHERE o.id=oi.order_id and o.id=357\n    )\nWHERE id in\n    (SELECT oi.product_id\n    FROM store_order o\n    JOIN store_orderitem oi\n    WHERE o.id=oi.order_id and o.id=357\n    );\n</code></pre>\n<blockquote>\n<p>作为假想需求和练习代码, 只是在逻辑上可以执行, 并非真实解决方案.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<blockquote>\n<p>实际运行中可能会出错, 因为订单包含的产品可能不止一个, 但是MySQL默认执行<code>SafeUpdate</code>, 一次仅能更新一条数据. 可以根据不同的IDE进行设置.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h3 id=\"DELETE\"><a href=\"#DELETE\" class=\"headerlink\" title=\"DELETE\"></a>DELETE</h3><pre><code class=\"sql\">DELETE FROM store_product\nWHERE id &gt; 2000\n</code></pre>\n<h2 id=\"统计函数\"><a href=\"#统计函数\" class=\"headerlink\" title=\"统计函数\"></a>统计函数</h2><p>MySQL提供了一下函数用来方便的进行数据统计</p>\n<pre><code class=\"sql\">SELECT\n    MAX(unit_price),                --最大值\n    MIN(unit_price),                --最小值\n    AVG(unit_price),                --平均值\n    SUM(unit_price * inventory),    --总和\n    COUNT(description),             --总数, 仅统计非空值\n    COUNT(*)                        --总数, 统计总行书\nFROM store_product\nWHERE unit_price &gt; 50;\n</code></pre>\n<h3 id=\"GROUP-BY\"><a href=\"#GROUP-BY\" class=\"headerlink\" title=\"GROUP BY\"></a>GROUP BY</h3><p>配合统计函数, 根据特定字段进行分组</p>\n<pre><code class=\"sql\">SELECT collection_id, SUM(unit_price * inventory), COUNT(id)\nFROM store_product\nGROUP BY collection_id\n</code></pre>\n<blockquote>\n<p>计算每个分类的产品总数和总值</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<h3 id=\"HAVING\"><a href=\"#HAVING\" class=\"headerlink\" title=\"HAVING\"></a>HAVING</h3><p>作用于WHERE子句类似, 区别在于<code>HAVING</code>子句用来在分组结束之后进行条件判断</p>\n<pre><code class=\"sql\">SELECT collection_id, SUM(unit_price * inventory), COUNT(id) as product_count\nFROM store_product\nWHERE unit_price &gt; 20\nGROUP BY collection_id\nHAVING product_count &gt; 200\n</code></pre>\n<blockquote>\n<p>人话: 在单价大于20的产品里, 统计各个分类的产品总值和产品数量, 看看有没有数量大于200的</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<h2 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2><p>可以将一个查询语句的结果作为参数传递给另外一个查询的表达式</p>\n<pre><code class=\"sql\">SELECT\n    id, title, unit_price\nFROM store_product\nWHERE unit_price &gt; (\n        SELECT MAX(unit_price)\n        FROM store_product\n        WHERE title REGEXP &#39;coffe&#39;\n    );\n</code></pre>\n<blockquote>\n<p>人话: 列出比价格最高的咖啡还贵的产品的id,名字和价格.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<pre><code class=\"sql\">SELECT *\nFROM store_product\nWHERE id in (\n        SELECT DISTINCT product_id\n        FROM store_orderitem\n    )\n</code></pre>\n<blockquote>\n<p>人话: 找到所有被下过订单的产品</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<pre><code class=\"sql\">SELECT *\nFROM store_customer\nWHERE id in (\n        SELECT o.customer_id\n        FROM store_order o\n        JOIN store_orderitem oi\n        ON o.id = oi.order_id\n        WHERE oi.product_id = 616\n    )\n</code></pre>\n<blockquote>\n<p>人话: 所有曾经买过id为 <code>616</code> 的产品的用户信息</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n"},{"title":"Pipenv 安装 mysqlclient出错","date":"2023-12-13T08:41:08.351Z","_content":"\n在使用`pipenv install mysqlclient`时报错:\n\n```bash\nRuntimeError: Failed to lock Pipfile.lock!\n```\n\n本来以为是mysqlclient或者pipenv的问题, 反复尝试无果, 又随便找了几个其他的包尝试安装, 包括`requests`,`pydoc`等\n\n发现依然会出现同样的问题,但是像`django`等一些包就安装很顺利\n\n最后找到一些解决方案, 需要安装一个名为`pkg-connfig`的包,\n\n```zsh\nsudo apt-get install pkg-config\n```\n\n但是Mac 并不支持`apt-get`\n\n于是只能换一种思路, 使用`brew`来安装`pkg-config`\n\n经尝试\n\n```zsh\nbrew install pkg-config\n```\n\n运行完成之后`mysqlclient`便可以通过pipenv正常安装了\n\n> PS: brew安装:\n>\n> ```bash\n> /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n> ```\n","source":"_posts/others/runtime-error-failed-to-lock-pipfile.md","raw":"---\ntitle: Pipenv 安装 mysqlclient出错\ndate: 2023-11-11 14:11:02 +08000\ncategories: [速查, 异常]\ntags: [django, pip, pipenv, mysql, exception]\n---\n\n在使用`pipenv install mysqlclient`时报错:\n\n```bash\nRuntimeError: Failed to lock Pipfile.lock!\n```\n\n本来以为是mysqlclient或者pipenv的问题, 反复尝试无果, 又随便找了几个其他的包尝试安装, 包括`requests`,`pydoc`等\n\n发现依然会出现同样的问题,但是像`django`等一些包就安装很顺利\n\n最后找到一些解决方案, 需要安装一个名为`pkg-connfig`的包,\n\n```zsh\nsudo apt-get install pkg-config\n```\n\n但是Mac 并不支持`apt-get`\n\n于是只能换一种思路, 使用`brew`来安装`pkg-config`\n\n经尝试\n\n```zsh\nbrew install pkg-config\n```\n\n运行完成之后`mysqlclient`便可以通过pipenv正常安装了\n\n> PS: brew安装:\n>\n> ```bash\n> /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n> ```\n","slug":"others-runtime-error-failed-to-lock-pipfile","published":1,"updated":"2023-12-13T08:41:08.352Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5uy000hi3erdfd14os0","content":"<p>在使用<code>pipenv install mysqlclient</code>时报错:</p>\n<pre><code class=\"bash\">RuntimeError: Failed to lock Pipfile.lock!\n</code></pre>\n<p>本来以为是mysqlclient或者pipenv的问题, 反复尝试无果, 又随便找了几个其他的包尝试安装, 包括<code>requests</code>,<code>pydoc</code>等</p>\n<p>发现依然会出现同样的问题,但是像<code>django</code>等一些包就安装很顺利</p>\n<p>最后找到一些解决方案, 需要安装一个名为<code>pkg-connfig</code>的包,</p>\n<pre><code class=\"zsh\">sudo apt-get install pkg-config\n</code></pre>\n<p>但是Mac 并不支持<code>apt-get</code></p>\n<p>于是只能换一种思路, 使用<code>brew</code>来安装<code>pkg-config</code></p>\n<p>经尝试</p>\n<pre><code class=\"zsh\">brew install pkg-config\n</code></pre>\n<p>运行完成之后<code>mysqlclient</code>便可以通过pipenv正常安装了</p>\n<blockquote>\n<p>PS: brew安装:</p>\n<pre><code class=\"bash\">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;\n</code></pre>\n</blockquote>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>在使用<code>pipenv install mysqlclient</code>时报错:</p>\n<pre><code class=\"bash\">RuntimeError: Failed to lock Pipfile.lock!\n</code></pre>\n<p>本来以为是mysqlclient或者pipenv的问题, 反复尝试无果, 又随便找了几个其他的包尝试安装, 包括<code>requests</code>,<code>pydoc</code>等</p>\n<p>发现依然会出现同样的问题,但是像<code>django</code>等一些包就安装很顺利</p>\n<p>最后找到一些解决方案, 需要安装一个名为<code>pkg-connfig</code>的包,</p>\n<pre><code class=\"zsh\">sudo apt-get install pkg-config\n</code></pre>\n<p>但是Mac 并不支持<code>apt-get</code></p>\n<p>于是只能换一种思路, 使用<code>brew</code>来安装<code>pkg-config</code></p>\n<p>经尝试</p>\n<pre><code class=\"zsh\">brew install pkg-config\n</code></pre>\n<p>运行完成之后<code>mysqlclient</code>便可以通过pipenv正常安装了</p>\n<blockquote>\n<p>PS: brew安装:</p>\n<pre><code class=\"bash\">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;\n</code></pre>\n</blockquote>\n"},{"title":"常用开源库整理(持续更新...)","date":"2023-11-14T10:37:23.000Z","pin":true,"image":"/assets/img/img_202311141802036688.png","_content":"\n## Python开源框架\n\n### [django](https://www.djangoproject.com)\n\n![django logo](/assets/img/48223734b31de65181a4a38de6d8ac54.png)\n\n功能强大的主流python服务端开发框架, 即可以基于MTV(Model-Templates-View)模式进行完整站点开发, 也可以用于开发RESTful API.\n[官方文档](https://docs.djangoproject.com/en/4.2/)\n\n![sep](/assets/img/separator_1.png)\n\n#### [mysqlclient](https://github.com/PyMySQL/mysqlclient)\n\npython访问mysql数据库的支持库, 基于mysql的django项目需要安装\n\n![sep](/assets/img/separator_1.png)\n\n#### [django-rest-framework](https://github.com/encode/django-rest-framework/tree/master)\n\n![dsf-logo](https://www.django-rest-framework.org/img/logo.png)\n\n基于django进行RESTful API开发的必备框架, 可以极大的提升开发效率\n\n[官方文档](https://www.django-rest-framework.org)\n\n![sep](/assets/img/separator_1.png)\n\n#### [django filter](https://github.com/carltongibson/django-filter)\n\n可以动态的读取URL参数, 并修改Django的Queryset来实现数据筛选\n\n[官方文档](https://django-filter.readthedocs.io/en/main/)\n\n![sep](/assets/img/separator_1.png)\n\n#### [drf nested routers](https://github.com/alanjds/drf-nested-routers)\n\n依赖于Django和Django REST Framework, 快速创建嵌套格式的RESTAPI, 如\n\n```text\nGET store/products: 产品清单\nGET store/products/1: 产品1的详情\nGET store/products/2/reviews: 产品2的评论清单\nGET store/products/2/reviews/3: 产品2的第3条评论\n```\n\n没有独立的文档页面, Github抽风时可以访问[Gitee镜像](https://gitee.com/mirrors_alanjds/drf-nested-routers)\n\n![sep](/assets/img/separator_3.png)\n\n## 测试与调试\n\n### [django-debug-toolbar](https://github.com/jazzband/django-debug-toolbar)\n\n一款可重用app, 通过简单配置实现对接口的调试, 可以方便的查看变量, SQL语句, 静态资源, 模板等一系列相关资源.\n\n![preview](/assets/img/img_202311141520211655.png)\n__django-debug-toolbar边栏预览__\n\n[官方文档](https://django-debug-toolbar.readthedocs.io/en/latest/)\n\n由[Jazzband](https://github.com/jazzband) python社区提供, 除了ddt之外, 该社区还提供了大量其他高价值的开源python框架, 如\n\n* [django-redis](https://github.com/jazzband/django-redis): redis缓存管理后台\n* [django-oauth-toolkit](https://github.com/jazzband/django-oauth-toolkit): 用于Django项目OAuth2认证的工具\n* [djangorestframework-simplejwt](https://github.com/jazzband/djangorestframework-simplejwt): Drango REST Framework的JWT(Json Web Token)插件\n\n![sep](/assets/img/separator_1.png)\n\n### [pytest](https://github.com/pytest-dev/pytest)\n\n强大的Python单元测试框架, 比python自带的unittest更为简单易用, 同时拥有大量的测试插件以满足不同场景的测试需求, 如:\n\n* [pytest-django](https://github.com/pytest-dev/pytest-django): 用于测试Django项目\n* [pytest-html](https://github.com/pytest-dev/pytest-html): 用于生成HTML测试报告\n* [pytest-flask](https://github.com/pytest-dev/pytest-flask): 用于测试flask项目\n* [pytest-selenium](https://github.com/pytest-dev/pytest-selenium): 用于结合selenium自动化脚本运行pytest\n\n![sep](/assets/img/separator_1.png)\n\n### [pytest-cov](https://github.com/pytest-dev/pytest-cov)\n\n用于生成代码测试覆盖率报告.\n\n[官方文档](https://pytest-cov.readthedocs.io/en/latest/)\n\n![sep](/assets/img/separator_1.png)\n\n### [pytest-django](https://github.com/pytest-dev/pytest-django)\n\n基于pytest的django测试框架, 可以方便的编写自动化接口测试.\n\n[官方文档](https://pytest-django.readthedocs.io/en/latest/)\n\n![sep](/assets/img/separator_1.png)\n\n### [tox](https://github.com/tox-dev/tox)\n\n提供自动化的虚拟环境测试, 依赖测试, 单元测试, 持续集成测试等.\n\n[官方文档](https://tox.wiki/en/latest/index.html)\n\n![sep](/assets/img/separator_1.png)\n\n### [locust](https://github.com/locustio/locust)\n\n性能测试, 压力测试的开源框架, 通过python代码定义用户行为模拟数百万用户操作, 并给出对应的分析报告.\n![screenshot](https://www.locust.io/static/img/screenshot_2.13.1.png)\n\n[官方文档](https://docs.locust.io/en/stable/)\n\n![sep](/assets/img/separator_1.png)\n\n### [django-silk](https://github.com/jazzband/django-silk)\n\n一个Django数据分析工具, 可以记录接口的调用, 返回时间, 产生的数据查询数量等用于分析.\n\n![preview](https://raw.githubusercontent.com/jazzband/django-silk/master/screenshots/1.png)\n\n由于没有独立的文档页, 如果Github抽风可以访问[Gitee镜像](https://gitee.com/mirrors_jazzband/django-silk)\n\n![sep](/assets/img/separator_3.png)\n\n## 在线工具\n\n### [https://mockaroo.com](https://mockaroo.com)\n\n一款免费的在线数据生成工具, 可以根据表结构随机生成数据, 提供CSV, SQL等多种格式的下载. 注册账户后还可以使用创建项目, 保存表结构等功能, 方便后续使用.\n\n![sep](/assets/img/separator_1.png)\n\n### [https://realfavicongenerator.net](https://realfavicongenerator.net)\n\n站点的favicon生成器, 通过一张图片生成一套跨平台的通用图片集\n\n![sep](/assets/img/separator_1.png)\n\n### [draw.io](http://draw.io)\n\n免费的在线绘图软件, 可以绘制各类常用图, 包括流程图, 线框图, ER图, 结构图等等.\n\n也可以[获取桌面版](http://get.draw.io)\n\n![preview](/assets/img/img_202311151738162426.png)\n\n![sep](/assets/img/separator_1.png)\n\n### [https://www.lucidchart.com](https://www.lucidchart.com/)\n\n同样是一款在线绘图工具, 目前没有桌面版app, 相较draw.io来说有更好的UI, 在分享与协作方面功能更强, 也可以基于ER图导出DDL等.\n\n但高级功能需要付费使用, 价格大概是Figma的一半, 如果仅有绘图需求ddraw.io基本足够使用\n\n### [pixso](https://pixso.cn)\n\n基本上复制了Figma模式和功能的国产设计软件, 包含了Figma和FigJam的核心功能, 目前还是免费试用.\n\n在桌面应用上的流畅性相较Figma而言有差距, 社区资源也相对较少, 但足够满足使用需求.\n\n![sep](/assets/img/separator_1.png)\n\n### [cssgradient.io](https://cssgradient.io)\n\n在线生成渐变效果的css工具.\n\n同时还有专门的插画, 阴影编辑工具.\n\n![sep](/assets/img/separator_1.png)\n\n### [www.fontsquirrel.com](https://www.fontsquirrel.com)\n\n字体站, 可以找到大量的免费开源字体, 同时可以将字体压缩为web字体.\n\n![sep](/assets/img/separator_1.png)\n\n### [typescale.com](https://typescale.com)\n\n响应式站点的相对字体大小单位计算站点. 快速得到准确的rem数值.\n\n![sep](/assets/img/separator_1.png)\n\n### [bennettfeely.com](http://bennettfeely.com)\n\n在线切图工具, 可以把图片切成所需要的形状.\n\n![sep](/assets/img/separator_1.png)\n\n### [cssspritestool.com](http://cssspritestool.com)\n\ncss图片合集在线制作工具\n\n![sep](/assets/img/separator_1.png)\n\n### [responsivebreakpoints.com](http://responsivebreakpoints.com)\n\n响应式图片集在线生成工具\n\n![sep](/assets/img/separator_1.png)\n\n### [cloudconvert.com](https://cloudconvert.com)\n\n文件格式在线转换工具\n\n![sep](/assets/img/separator_1.png)\n\n### [svgbackgrounds.com](http://svgbackgrounds.com)\n\nsvg背景图生成网站\n\n![sep](/assets/img/separator_1.png)\n\n### [cubic-bezier.com/](https://cubic-bezier.com/)\n\ncss动画函数曲线生成器.\n\n![sep](/assets/img/separator_1.png)\n\n### [animate.style](http://animate.style)\n\ncss动画样式库\n\n![sep](/assets/img/separator_1.png)\n\n### [yesno.wtf](https://yesno.wtf)\n\n一个简单的api测试站点, 调用`/api`得到一个json对象的数据, 包含一个随机的yes,no,maybe结果以及一个gif动图地址...从动图的尿性来说...wtf域名选的很贴切...\n\n![sep](/assets/img/separator_1.png)\n\n### [brandcolors.net](https://brandcolors.net/)\n\n品牌色板, 各类品牌的配色方案集合.\n\n### [colors.muz.li](https://colors.muz.li/)\n\n根据上传的图片自动分析出对应的配色方案与色板文件, 相当nice!!!\n\n![sep](/assets/img/separator_1.png)\n\n### [color.hailpixel.com](https://color.hailpixel.com/)\n\n快速创建色板的在线工具, 简单上手到无以复加...\n\n### [zhongguose.com](https://zhongguose.com/)\n\n中国风配色查询网站, 访问速度快, 颜色也很舒服.\n","source":"_posts/others/python-valuable-opensource-libraries-collection.md","raw":"---\ntitle: 常用开源库整理(持续更新...)\ndate: 2023-11-14 18:37:23 +0800\ncategories: [速查, 工具]\ntags: [python, django, opensource]\npin: true\nimage: /assets/img/img_202311141802036688.png\n---\n\n## Python开源框架\n\n### [django](https://www.djangoproject.com)\n\n![django logo](/assets/img/48223734b31de65181a4a38de6d8ac54.png)\n\n功能强大的主流python服务端开发框架, 即可以基于MTV(Model-Templates-View)模式进行完整站点开发, 也可以用于开发RESTful API.\n[官方文档](https://docs.djangoproject.com/en/4.2/)\n\n![sep](/assets/img/separator_1.png)\n\n#### [mysqlclient](https://github.com/PyMySQL/mysqlclient)\n\npython访问mysql数据库的支持库, 基于mysql的django项目需要安装\n\n![sep](/assets/img/separator_1.png)\n\n#### [django-rest-framework](https://github.com/encode/django-rest-framework/tree/master)\n\n![dsf-logo](https://www.django-rest-framework.org/img/logo.png)\n\n基于django进行RESTful API开发的必备框架, 可以极大的提升开发效率\n\n[官方文档](https://www.django-rest-framework.org)\n\n![sep](/assets/img/separator_1.png)\n\n#### [django filter](https://github.com/carltongibson/django-filter)\n\n可以动态的读取URL参数, 并修改Django的Queryset来实现数据筛选\n\n[官方文档](https://django-filter.readthedocs.io/en/main/)\n\n![sep](/assets/img/separator_1.png)\n\n#### [drf nested routers](https://github.com/alanjds/drf-nested-routers)\n\n依赖于Django和Django REST Framework, 快速创建嵌套格式的RESTAPI, 如\n\n```text\nGET store/products: 产品清单\nGET store/products/1: 产品1的详情\nGET store/products/2/reviews: 产品2的评论清单\nGET store/products/2/reviews/3: 产品2的第3条评论\n```\n\n没有独立的文档页面, Github抽风时可以访问[Gitee镜像](https://gitee.com/mirrors_alanjds/drf-nested-routers)\n\n![sep](/assets/img/separator_3.png)\n\n## 测试与调试\n\n### [django-debug-toolbar](https://github.com/jazzband/django-debug-toolbar)\n\n一款可重用app, 通过简单配置实现对接口的调试, 可以方便的查看变量, SQL语句, 静态资源, 模板等一系列相关资源.\n\n![preview](/assets/img/img_202311141520211655.png)\n__django-debug-toolbar边栏预览__\n\n[官方文档](https://django-debug-toolbar.readthedocs.io/en/latest/)\n\n由[Jazzband](https://github.com/jazzband) python社区提供, 除了ddt之外, 该社区还提供了大量其他高价值的开源python框架, 如\n\n* [django-redis](https://github.com/jazzband/django-redis): redis缓存管理后台\n* [django-oauth-toolkit](https://github.com/jazzband/django-oauth-toolkit): 用于Django项目OAuth2认证的工具\n* [djangorestframework-simplejwt](https://github.com/jazzband/djangorestframework-simplejwt): Drango REST Framework的JWT(Json Web Token)插件\n\n![sep](/assets/img/separator_1.png)\n\n### [pytest](https://github.com/pytest-dev/pytest)\n\n强大的Python单元测试框架, 比python自带的unittest更为简单易用, 同时拥有大量的测试插件以满足不同场景的测试需求, 如:\n\n* [pytest-django](https://github.com/pytest-dev/pytest-django): 用于测试Django项目\n* [pytest-html](https://github.com/pytest-dev/pytest-html): 用于生成HTML测试报告\n* [pytest-flask](https://github.com/pytest-dev/pytest-flask): 用于测试flask项目\n* [pytest-selenium](https://github.com/pytest-dev/pytest-selenium): 用于结合selenium自动化脚本运行pytest\n\n![sep](/assets/img/separator_1.png)\n\n### [pytest-cov](https://github.com/pytest-dev/pytest-cov)\n\n用于生成代码测试覆盖率报告.\n\n[官方文档](https://pytest-cov.readthedocs.io/en/latest/)\n\n![sep](/assets/img/separator_1.png)\n\n### [pytest-django](https://github.com/pytest-dev/pytest-django)\n\n基于pytest的django测试框架, 可以方便的编写自动化接口测试.\n\n[官方文档](https://pytest-django.readthedocs.io/en/latest/)\n\n![sep](/assets/img/separator_1.png)\n\n### [tox](https://github.com/tox-dev/tox)\n\n提供自动化的虚拟环境测试, 依赖测试, 单元测试, 持续集成测试等.\n\n[官方文档](https://tox.wiki/en/latest/index.html)\n\n![sep](/assets/img/separator_1.png)\n\n### [locust](https://github.com/locustio/locust)\n\n性能测试, 压力测试的开源框架, 通过python代码定义用户行为模拟数百万用户操作, 并给出对应的分析报告.\n![screenshot](https://www.locust.io/static/img/screenshot_2.13.1.png)\n\n[官方文档](https://docs.locust.io/en/stable/)\n\n![sep](/assets/img/separator_1.png)\n\n### [django-silk](https://github.com/jazzband/django-silk)\n\n一个Django数据分析工具, 可以记录接口的调用, 返回时间, 产生的数据查询数量等用于分析.\n\n![preview](https://raw.githubusercontent.com/jazzband/django-silk/master/screenshots/1.png)\n\n由于没有独立的文档页, 如果Github抽风可以访问[Gitee镜像](https://gitee.com/mirrors_jazzband/django-silk)\n\n![sep](/assets/img/separator_3.png)\n\n## 在线工具\n\n### [https://mockaroo.com](https://mockaroo.com)\n\n一款免费的在线数据生成工具, 可以根据表结构随机生成数据, 提供CSV, SQL等多种格式的下载. 注册账户后还可以使用创建项目, 保存表结构等功能, 方便后续使用.\n\n![sep](/assets/img/separator_1.png)\n\n### [https://realfavicongenerator.net](https://realfavicongenerator.net)\n\n站点的favicon生成器, 通过一张图片生成一套跨平台的通用图片集\n\n![sep](/assets/img/separator_1.png)\n\n### [draw.io](http://draw.io)\n\n免费的在线绘图软件, 可以绘制各类常用图, 包括流程图, 线框图, ER图, 结构图等等.\n\n也可以[获取桌面版](http://get.draw.io)\n\n![preview](/assets/img/img_202311151738162426.png)\n\n![sep](/assets/img/separator_1.png)\n\n### [https://www.lucidchart.com](https://www.lucidchart.com/)\n\n同样是一款在线绘图工具, 目前没有桌面版app, 相较draw.io来说有更好的UI, 在分享与协作方面功能更强, 也可以基于ER图导出DDL等.\n\n但高级功能需要付费使用, 价格大概是Figma的一半, 如果仅有绘图需求ddraw.io基本足够使用\n\n### [pixso](https://pixso.cn)\n\n基本上复制了Figma模式和功能的国产设计软件, 包含了Figma和FigJam的核心功能, 目前还是免费试用.\n\n在桌面应用上的流畅性相较Figma而言有差距, 社区资源也相对较少, 但足够满足使用需求.\n\n![sep](/assets/img/separator_1.png)\n\n### [cssgradient.io](https://cssgradient.io)\n\n在线生成渐变效果的css工具.\n\n同时还有专门的插画, 阴影编辑工具.\n\n![sep](/assets/img/separator_1.png)\n\n### [www.fontsquirrel.com](https://www.fontsquirrel.com)\n\n字体站, 可以找到大量的免费开源字体, 同时可以将字体压缩为web字体.\n\n![sep](/assets/img/separator_1.png)\n\n### [typescale.com](https://typescale.com)\n\n响应式站点的相对字体大小单位计算站点. 快速得到准确的rem数值.\n\n![sep](/assets/img/separator_1.png)\n\n### [bennettfeely.com](http://bennettfeely.com)\n\n在线切图工具, 可以把图片切成所需要的形状.\n\n![sep](/assets/img/separator_1.png)\n\n### [cssspritestool.com](http://cssspritestool.com)\n\ncss图片合集在线制作工具\n\n![sep](/assets/img/separator_1.png)\n\n### [responsivebreakpoints.com](http://responsivebreakpoints.com)\n\n响应式图片集在线生成工具\n\n![sep](/assets/img/separator_1.png)\n\n### [cloudconvert.com](https://cloudconvert.com)\n\n文件格式在线转换工具\n\n![sep](/assets/img/separator_1.png)\n\n### [svgbackgrounds.com](http://svgbackgrounds.com)\n\nsvg背景图生成网站\n\n![sep](/assets/img/separator_1.png)\n\n### [cubic-bezier.com/](https://cubic-bezier.com/)\n\ncss动画函数曲线生成器.\n\n![sep](/assets/img/separator_1.png)\n\n### [animate.style](http://animate.style)\n\ncss动画样式库\n\n![sep](/assets/img/separator_1.png)\n\n### [yesno.wtf](https://yesno.wtf)\n\n一个简单的api测试站点, 调用`/api`得到一个json对象的数据, 包含一个随机的yes,no,maybe结果以及一个gif动图地址...从动图的尿性来说...wtf域名选的很贴切...\n\n![sep](/assets/img/separator_1.png)\n\n### [brandcolors.net](https://brandcolors.net/)\n\n品牌色板, 各类品牌的配色方案集合.\n\n### [colors.muz.li](https://colors.muz.li/)\n\n根据上传的图片自动分析出对应的配色方案与色板文件, 相当nice!!!\n\n![sep](/assets/img/separator_1.png)\n\n### [color.hailpixel.com](https://color.hailpixel.com/)\n\n快速创建色板的在线工具, 简单上手到无以复加...\n\n### [zhongguose.com](https://zhongguose.com/)\n\n中国风配色查询网站, 访问速度快, 颜色也很舒服.\n","slug":"others-python-valuable-opensource-libraries-collection","published":1,"updated":"2023-12-13T08:41:08.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5uy000ji3er1gb9cd8p","content":"<h2 id=\"Python开源框架\"><a href=\"#Python开源框架\" class=\"headerlink\" title=\"Python开源框架\"></a>Python开源框架</h2><h3 id=\"django\"><a href=\"#django\" class=\"headerlink\" title=\"django\"></a><a href=\"https://www.djangoproject.com/\">django</a></h3><p><img src=\"/assets/img/48223734b31de65181a4a38de6d8ac54.png\" alt=\"django logo\"></p>\n<p>功能强大的主流python服务端开发框架, 即可以基于MTV(Model-Templates-View)模式进行完整站点开发, 也可以用于开发RESTful API.<br><a href=\"https://docs.djangoproject.com/en/4.2/\">官方文档</a></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h4 id=\"mysqlclient\"><a href=\"#mysqlclient\" class=\"headerlink\" title=\"mysqlclient\"></a><a href=\"https://github.com/PyMySQL/mysqlclient\">mysqlclient</a></h4><p>python访问mysql数据库的支持库, 基于mysql的django项目需要安装</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h4 id=\"django-rest-framework\"><a href=\"#django-rest-framework\" class=\"headerlink\" title=\"django-rest-framework\"></a><a href=\"https://github.com/encode/django-rest-framework/tree/master\">django-rest-framework</a></h4><p><img src=\"https://www.django-rest-framework.org/img/logo.png\" alt=\"dsf-logo\"></p>\n<p>基于django进行RESTful API开发的必备框架, 可以极大的提升开发效率</p>\n<p><a href=\"https://www.django-rest-framework.org/\">官方文档</a></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h4 id=\"django-filter\"><a href=\"#django-filter\" class=\"headerlink\" title=\"django filter\"></a><a href=\"https://github.com/carltongibson/django-filter\">django filter</a></h4><p>可以动态的读取URL参数, 并修改Django的Queryset来实现数据筛选</p>\n<p><a href=\"https://django-filter.readthedocs.io/en/main/\">官方文档</a></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h4 id=\"drf-nested-routers\"><a href=\"#drf-nested-routers\" class=\"headerlink\" title=\"drf nested routers\"></a><a href=\"https://github.com/alanjds/drf-nested-routers\">drf nested routers</a></h4><p>依赖于Django和Django REST Framework, 快速创建嵌套格式的RESTAPI, 如</p>\n<pre><code class=\"text\">GET store/products: 产品清单\nGET store/products/1: 产品1的详情\nGET store/products/2/reviews: 产品2的评论清单\nGET store/products/2/reviews/3: 产品2的第3条评论\n</code></pre>\n<p>没有独立的文档页面, Github抽风时可以访问<a href=\"https://gitee.com/mirrors_alanjds/drf-nested-routers\">Gitee镜像</a></p>\n<p><img src=\"/assets/img/separator_3.png\" alt=\"sep\"></p>\n<h2 id=\"测试与调试\"><a href=\"#测试与调试\" class=\"headerlink\" title=\"测试与调试\"></a>测试与调试</h2><h3 id=\"django-debug-toolbar\"><a href=\"#django-debug-toolbar\" class=\"headerlink\" title=\"django-debug-toolbar\"></a><a href=\"https://github.com/jazzband/django-debug-toolbar\">django-debug-toolbar</a></h3><p>一款可重用app, 通过简单配置实现对接口的调试, 可以方便的查看变量, SQL语句, 静态资源, 模板等一系列相关资源.</p>\n<p><img src=\"/assets/img/img_202311141520211655.png\" alt=\"preview\"><br><strong>django-debug-toolbar边栏预览</strong></p>\n<p><a href=\"https://django-debug-toolbar.readthedocs.io/en/latest/\">官方文档</a></p>\n<p>由<a href=\"https://github.com/jazzband\">Jazzband</a> python社区提供, 除了ddt之外, 该社区还提供了大量其他高价值的开源python框架, 如</p>\n<ul>\n<li><a href=\"https://github.com/jazzband/django-redis\">django-redis</a>: redis缓存管理后台</li>\n<li><a href=\"https://github.com/jazzband/django-oauth-toolkit\">django-oauth-toolkit</a>: 用于Django项目OAuth2认证的工具</li>\n<li><a href=\"https://github.com/jazzband/djangorestframework-simplejwt\">djangorestframework-simplejwt</a>: Drango REST Framework的JWT(Json Web Token)插件</li>\n</ul>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"pytest\"><a href=\"#pytest\" class=\"headerlink\" title=\"pytest\"></a><a href=\"https://github.com/pytest-dev/pytest\">pytest</a></h3><p>强大的Python单元测试框架, 比python自带的unittest更为简单易用, 同时拥有大量的测试插件以满足不同场景的测试需求, 如:</p>\n<ul>\n<li><a href=\"https://github.com/pytest-dev/pytest-django\">pytest-django</a>: 用于测试Django项目</li>\n<li><a href=\"https://github.com/pytest-dev/pytest-html\">pytest-html</a>: 用于生成HTML测试报告</li>\n<li><a href=\"https://github.com/pytest-dev/pytest-flask\">pytest-flask</a>: 用于测试flask项目</li>\n<li><a href=\"https://github.com/pytest-dev/pytest-selenium\">pytest-selenium</a>: 用于结合selenium自动化脚本运行pytest</li>\n</ul>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"pytest-cov\"><a href=\"#pytest-cov\" class=\"headerlink\" title=\"pytest-cov\"></a><a href=\"https://github.com/pytest-dev/pytest-cov\">pytest-cov</a></h3><p>用于生成代码测试覆盖率报告.</p>\n<p><a href=\"https://pytest-cov.readthedocs.io/en/latest/\">官方文档</a></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"pytest-django\"><a href=\"#pytest-django\" class=\"headerlink\" title=\"pytest-django\"></a><a href=\"https://github.com/pytest-dev/pytest-django\">pytest-django</a></h3><p>基于pytest的django测试框架, 可以方便的编写自动化接口测试.</p>\n<p><a href=\"https://pytest-django.readthedocs.io/en/latest/\">官方文档</a></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"tox\"><a href=\"#tox\" class=\"headerlink\" title=\"tox\"></a><a href=\"https://github.com/tox-dev/tox\">tox</a></h3><p>提供自动化的虚拟环境测试, 依赖测试, 单元测试, 持续集成测试等.</p>\n<p><a href=\"https://tox.wiki/en/latest/index.html\">官方文档</a></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"locust\"><a href=\"#locust\" class=\"headerlink\" title=\"locust\"></a><a href=\"https://github.com/locustio/locust\">locust</a></h3><p>性能测试, 压力测试的开源框架, 通过python代码定义用户行为模拟数百万用户操作, 并给出对应的分析报告.<br><img src=\"https://www.locust.io/static/img/screenshot_2.13.1.png\" alt=\"screenshot\"></p>\n<p><a href=\"https://docs.locust.io/en/stable/\">官方文档</a></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"django-silk\"><a href=\"#django-silk\" class=\"headerlink\" title=\"django-silk\"></a><a href=\"https://github.com/jazzband/django-silk\">django-silk</a></h3><p>一个Django数据分析工具, 可以记录接口的调用, 返回时间, 产生的数据查询数量等用于分析.</p>\n<p><img src=\"https://raw.githubusercontent.com/jazzband/django-silk/master/screenshots/1.png\" alt=\"preview\"></p>\n<p>由于没有独立的文档页, 如果Github抽风可以访问<a href=\"https://gitee.com/mirrors_jazzband/django-silk\">Gitee镜像</a></p>\n<p><img src=\"/assets/img/separator_3.png\" alt=\"sep\"></p>\n<h2 id=\"在线工具\"><a href=\"#在线工具\" class=\"headerlink\" title=\"在线工具\"></a>在线工具</h2><h3 id=\"https-mockaroo-com\"><a href=\"#https-mockaroo-com\" class=\"headerlink\" title=\"https://mockaroo.com\"></a><a href=\"https://mockaroo.com/\">https://mockaroo.com</a></h3><p>一款免费的在线数据生成工具, 可以根据表结构随机生成数据, 提供CSV, SQL等多种格式的下载. 注册账户后还可以使用创建项目, 保存表结构等功能, 方便后续使用.</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"https-realfavicongenerator-net\"><a href=\"#https-realfavicongenerator-net\" class=\"headerlink\" title=\"https://realfavicongenerator.net\"></a><a href=\"https://realfavicongenerator.net/\">https://realfavicongenerator.net</a></h3><p>站点的favicon生成器, 通过一张图片生成一套跨平台的通用图片集</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"draw-io\"><a href=\"#draw-io\" class=\"headerlink\" title=\"draw.io\"></a><a href=\"http://draw.io/\">draw.io</a></h3><p>免费的在线绘图软件, 可以绘制各类常用图, 包括流程图, 线框图, ER图, 结构图等等.</p>\n<p>也可以<a href=\"http://get.draw.io/\">获取桌面版</a></p>\n<p><img src=\"/assets/img/img_202311151738162426.png\" alt=\"preview\"></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"https-www-lucidchart-com\"><a href=\"#https-www-lucidchart-com\" class=\"headerlink\" title=\"https://www.lucidchart.com\"></a><a href=\"https://www.lucidchart.com/\">https://www.lucidchart.com</a></h3><p>同样是一款在线绘图工具, 目前没有桌面版app, 相较draw.io来说有更好的UI, 在分享与协作方面功能更强, 也可以基于ER图导出DDL等.</p>\n<p>但高级功能需要付费使用, 价格大概是Figma的一半, 如果仅有绘图需求ddraw.io基本足够使用</p>\n<h3 id=\"pixso\"><a href=\"#pixso\" class=\"headerlink\" title=\"pixso\"></a><a href=\"https://pixso.cn/\">pixso</a></h3><p>基本上复制了Figma模式和功能的国产设计软件, 包含了Figma和FigJam的核心功能, 目前还是免费试用.</p>\n<p>在桌面应用上的流畅性相较Figma而言有差距, 社区资源也相对较少, 但足够满足使用需求.</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"cssgradient-io\"><a href=\"#cssgradient-io\" class=\"headerlink\" title=\"cssgradient.io\"></a><a href=\"https://cssgradient.io/\">cssgradient.io</a></h3><p>在线生成渐变效果的css工具.</p>\n<p>同时还有专门的插画, 阴影编辑工具.</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"www-fontsquirrel-com\"><a href=\"#www-fontsquirrel-com\" class=\"headerlink\" title=\"www.fontsquirrel.com\"></a><a href=\"https://www.fontsquirrel.com/\">www.fontsquirrel.com</a></h3><p>字体站, 可以找到大量的免费开源字体, 同时可以将字体压缩为web字体.</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"typescale-com\"><a href=\"#typescale-com\" class=\"headerlink\" title=\"typescale.com\"></a><a href=\"https://typescale.com/\">typescale.com</a></h3><p>响应式站点的相对字体大小单位计算站点. 快速得到准确的rem数值.</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"bennettfeely-com\"><a href=\"#bennettfeely-com\" class=\"headerlink\" title=\"bennettfeely.com\"></a><a href=\"http://bennettfeely.com/\">bennettfeely.com</a></h3><p>在线切图工具, 可以把图片切成所需要的形状.</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"cssspritestool-com\"><a href=\"#cssspritestool-com\" class=\"headerlink\" title=\"cssspritestool.com\"></a><a href=\"http://cssspritestool.com/\">cssspritestool.com</a></h3><p>css图片合集在线制作工具</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"responsivebreakpoints-com\"><a href=\"#responsivebreakpoints-com\" class=\"headerlink\" title=\"responsivebreakpoints.com\"></a><a href=\"http://responsivebreakpoints.com/\">responsivebreakpoints.com</a></h3><p>响应式图片集在线生成工具</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"cloudconvert-com\"><a href=\"#cloudconvert-com\" class=\"headerlink\" title=\"cloudconvert.com\"></a><a href=\"https://cloudconvert.com/\">cloudconvert.com</a></h3><p>文件格式在线转换工具</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"svgbackgrounds-com\"><a href=\"#svgbackgrounds-com\" class=\"headerlink\" title=\"svgbackgrounds.com\"></a><a href=\"http://svgbackgrounds.com/\">svgbackgrounds.com</a></h3><p>svg背景图生成网站</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"cubic-bezier-com\"><a href=\"#cubic-bezier-com\" class=\"headerlink\" title=\"cubic-bezier.com&#x2F;\"></a><a href=\"https://cubic-bezier.com/\">cubic-bezier.com&#x2F;</a></h3><p>css动画函数曲线生成器.</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"animate-style\"><a href=\"#animate-style\" class=\"headerlink\" title=\"animate.style\"></a><a href=\"http://animate.style/\">animate.style</a></h3><p>css动画样式库</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"yesno-wtf\"><a href=\"#yesno-wtf\" class=\"headerlink\" title=\"yesno.wtf\"></a><a href=\"https://yesno.wtf/\">yesno.wtf</a></h3><p>一个简单的api测试站点, 调用<code>/api</code>得到一个json对象的数据, 包含一个随机的yes,no,maybe结果以及一个gif动图地址…从动图的尿性来说…wtf域名选的很贴切…</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"brandcolors-net\"><a href=\"#brandcolors-net\" class=\"headerlink\" title=\"brandcolors.net\"></a><a href=\"https://brandcolors.net/\">brandcolors.net</a></h3><p>品牌色板, 各类品牌的配色方案集合.</p>\n<h3 id=\"colors-muz-li\"><a href=\"#colors-muz-li\" class=\"headerlink\" title=\"colors.muz.li\"></a><a href=\"https://colors.muz.li/\">colors.muz.li</a></h3><p>根据上传的图片自动分析出对应的配色方案与色板文件, 相当nice!!!</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"color-hailpixel-com\"><a href=\"#color-hailpixel-com\" class=\"headerlink\" title=\"color.hailpixel.com\"></a><a href=\"https://color.hailpixel.com/\">color.hailpixel.com</a></h3><p>快速创建色板的在线工具, 简单上手到无以复加…</p>\n<h3 id=\"zhongguose-com\"><a href=\"#zhongguose-com\" class=\"headerlink\" title=\"zhongguose.com\"></a><a href=\"https://zhongguose.com/\">zhongguose.com</a></h3><p>中国风配色查询网站, 访问速度快, 颜色也很舒服.</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"Python开源框架\"><a href=\"#Python开源框架\" class=\"headerlink\" title=\"Python开源框架\"></a>Python开源框架</h2><h3 id=\"django\"><a href=\"#django\" class=\"headerlink\" title=\"django\"></a><a href=\"https://www.djangoproject.com/\">django</a></h3><p><img src=\"/assets/img/48223734b31de65181a4a38de6d8ac54.png\" alt=\"django logo\"></p>\n<p>功能强大的主流python服务端开发框架, 即可以基于MTV(Model-Templates-View)模式进行完整站点开发, 也可以用于开发RESTful API.<br><a href=\"https://docs.djangoproject.com/en/4.2/\">官方文档</a></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h4 id=\"mysqlclient\"><a href=\"#mysqlclient\" class=\"headerlink\" title=\"mysqlclient\"></a><a href=\"https://github.com/PyMySQL/mysqlclient\">mysqlclient</a></h4><p>python访问mysql数据库的支持库, 基于mysql的django项目需要安装</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h4 id=\"django-rest-framework\"><a href=\"#django-rest-framework\" class=\"headerlink\" title=\"django-rest-framework\"></a><a href=\"https://github.com/encode/django-rest-framework/tree/master\">django-rest-framework</a></h4><p><img src=\"https://www.django-rest-framework.org/img/logo.png\" alt=\"dsf-logo\"></p>\n<p>基于django进行RESTful API开发的必备框架, 可以极大的提升开发效率</p>\n<p><a href=\"https://www.django-rest-framework.org/\">官方文档</a></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h4 id=\"django-filter\"><a href=\"#django-filter\" class=\"headerlink\" title=\"django filter\"></a><a href=\"https://github.com/carltongibson/django-filter\">django filter</a></h4><p>可以动态的读取URL参数, 并修改Django的Queryset来实现数据筛选</p>\n<p><a href=\"https://django-filter.readthedocs.io/en/main/\">官方文档</a></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h4 id=\"drf-nested-routers\"><a href=\"#drf-nested-routers\" class=\"headerlink\" title=\"drf nested routers\"></a><a href=\"https://github.com/alanjds/drf-nested-routers\">drf nested routers</a></h4><p>依赖于Django和Django REST Framework, 快速创建嵌套格式的RESTAPI, 如</p>\n<pre><code class=\"text\">GET store/products: 产品清单\nGET store/products/1: 产品1的详情\nGET store/products/2/reviews: 产品2的评论清单\nGET store/products/2/reviews/3: 产品2的第3条评论\n</code></pre>\n<p>没有独立的文档页面, Github抽风时可以访问<a href=\"https://gitee.com/mirrors_alanjds/drf-nested-routers\">Gitee镜像</a></p>\n<p><img src=\"/assets/img/separator_3.png\" alt=\"sep\"></p>\n<h2 id=\"测试与调试\"><a href=\"#测试与调试\" class=\"headerlink\" title=\"测试与调试\"></a>测试与调试</h2><h3 id=\"django-debug-toolbar\"><a href=\"#django-debug-toolbar\" class=\"headerlink\" title=\"django-debug-toolbar\"></a><a href=\"https://github.com/jazzband/django-debug-toolbar\">django-debug-toolbar</a></h3><p>一款可重用app, 通过简单配置实现对接口的调试, 可以方便的查看变量, SQL语句, 静态资源, 模板等一系列相关资源.</p>\n<p><img src=\"/assets/img/img_202311141520211655.png\" alt=\"preview\"><br><strong>django-debug-toolbar边栏预览</strong></p>\n<p><a href=\"https://django-debug-toolbar.readthedocs.io/en/latest/\">官方文档</a></p>\n<p>由<a href=\"https://github.com/jazzband\">Jazzband</a> python社区提供, 除了ddt之外, 该社区还提供了大量其他高价值的开源python框架, 如</p>\n<ul>\n<li><a href=\"https://github.com/jazzband/django-redis\">django-redis</a>: redis缓存管理后台</li>\n<li><a href=\"https://github.com/jazzband/django-oauth-toolkit\">django-oauth-toolkit</a>: 用于Django项目OAuth2认证的工具</li>\n<li><a href=\"https://github.com/jazzband/djangorestframework-simplejwt\">djangorestframework-simplejwt</a>: Drango REST Framework的JWT(Json Web Token)插件</li>\n</ul>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"pytest\"><a href=\"#pytest\" class=\"headerlink\" title=\"pytest\"></a><a href=\"https://github.com/pytest-dev/pytest\">pytest</a></h3><p>强大的Python单元测试框架, 比python自带的unittest更为简单易用, 同时拥有大量的测试插件以满足不同场景的测试需求, 如:</p>\n<ul>\n<li><a href=\"https://github.com/pytest-dev/pytest-django\">pytest-django</a>: 用于测试Django项目</li>\n<li><a href=\"https://github.com/pytest-dev/pytest-html\">pytest-html</a>: 用于生成HTML测试报告</li>\n<li><a href=\"https://github.com/pytest-dev/pytest-flask\">pytest-flask</a>: 用于测试flask项目</li>\n<li><a href=\"https://github.com/pytest-dev/pytest-selenium\">pytest-selenium</a>: 用于结合selenium自动化脚本运行pytest</li>\n</ul>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"pytest-cov\"><a href=\"#pytest-cov\" class=\"headerlink\" title=\"pytest-cov\"></a><a href=\"https://github.com/pytest-dev/pytest-cov\">pytest-cov</a></h3><p>用于生成代码测试覆盖率报告.</p>\n<p><a href=\"https://pytest-cov.readthedocs.io/en/latest/\">官方文档</a></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"pytest-django\"><a href=\"#pytest-django\" class=\"headerlink\" title=\"pytest-django\"></a><a href=\"https://github.com/pytest-dev/pytest-django\">pytest-django</a></h3><p>基于pytest的django测试框架, 可以方便的编写自动化接口测试.</p>\n<p><a href=\"https://pytest-django.readthedocs.io/en/latest/\">官方文档</a></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"tox\"><a href=\"#tox\" class=\"headerlink\" title=\"tox\"></a><a href=\"https://github.com/tox-dev/tox\">tox</a></h3><p>提供自动化的虚拟环境测试, 依赖测试, 单元测试, 持续集成测试等.</p>\n<p><a href=\"https://tox.wiki/en/latest/index.html\">官方文档</a></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"locust\"><a href=\"#locust\" class=\"headerlink\" title=\"locust\"></a><a href=\"https://github.com/locustio/locust\">locust</a></h3><p>性能测试, 压力测试的开源框架, 通过python代码定义用户行为模拟数百万用户操作, 并给出对应的分析报告.<br><img src=\"https://www.locust.io/static/img/screenshot_2.13.1.png\" alt=\"screenshot\"></p>\n<p><a href=\"https://docs.locust.io/en/stable/\">官方文档</a></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"django-silk\"><a href=\"#django-silk\" class=\"headerlink\" title=\"django-silk\"></a><a href=\"https://github.com/jazzband/django-silk\">django-silk</a></h3><p>一个Django数据分析工具, 可以记录接口的调用, 返回时间, 产生的数据查询数量等用于分析.</p>\n<p><img src=\"https://raw.githubusercontent.com/jazzband/django-silk/master/screenshots/1.png\" alt=\"preview\"></p>\n<p>由于没有独立的文档页, 如果Github抽风可以访问<a href=\"https://gitee.com/mirrors_jazzband/django-silk\">Gitee镜像</a></p>\n<p><img src=\"/assets/img/separator_3.png\" alt=\"sep\"></p>\n<h2 id=\"在线工具\"><a href=\"#在线工具\" class=\"headerlink\" title=\"在线工具\"></a>在线工具</h2><h3 id=\"https-mockaroo-com\"><a href=\"#https-mockaroo-com\" class=\"headerlink\" title=\"https://mockaroo.com\"></a><a href=\"https://mockaroo.com/\">https://mockaroo.com</a></h3><p>一款免费的在线数据生成工具, 可以根据表结构随机生成数据, 提供CSV, SQL等多种格式的下载. 注册账户后还可以使用创建项目, 保存表结构等功能, 方便后续使用.</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"https-realfavicongenerator-net\"><a href=\"#https-realfavicongenerator-net\" class=\"headerlink\" title=\"https://realfavicongenerator.net\"></a><a href=\"https://realfavicongenerator.net/\">https://realfavicongenerator.net</a></h3><p>站点的favicon生成器, 通过一张图片生成一套跨平台的通用图片集</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"draw-io\"><a href=\"#draw-io\" class=\"headerlink\" title=\"draw.io\"></a><a href=\"http://draw.io/\">draw.io</a></h3><p>免费的在线绘图软件, 可以绘制各类常用图, 包括流程图, 线框图, ER图, 结构图等等.</p>\n<p>也可以<a href=\"http://get.draw.io/\">获取桌面版</a></p>\n<p><img src=\"/assets/img/img_202311151738162426.png\" alt=\"preview\"></p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"https-www-lucidchart-com\"><a href=\"#https-www-lucidchart-com\" class=\"headerlink\" title=\"https://www.lucidchart.com\"></a><a href=\"https://www.lucidchart.com/\">https://www.lucidchart.com</a></h3><p>同样是一款在线绘图工具, 目前没有桌面版app, 相较draw.io来说有更好的UI, 在分享与协作方面功能更强, 也可以基于ER图导出DDL等.</p>\n<p>但高级功能需要付费使用, 价格大概是Figma的一半, 如果仅有绘图需求ddraw.io基本足够使用</p>\n<h3 id=\"pixso\"><a href=\"#pixso\" class=\"headerlink\" title=\"pixso\"></a><a href=\"https://pixso.cn/\">pixso</a></h3><p>基本上复制了Figma模式和功能的国产设计软件, 包含了Figma和FigJam的核心功能, 目前还是免费试用.</p>\n<p>在桌面应用上的流畅性相较Figma而言有差距, 社区资源也相对较少, 但足够满足使用需求.</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"cssgradient-io\"><a href=\"#cssgradient-io\" class=\"headerlink\" title=\"cssgradient.io\"></a><a href=\"https://cssgradient.io/\">cssgradient.io</a></h3><p>在线生成渐变效果的css工具.</p>\n<p>同时还有专门的插画, 阴影编辑工具.</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"www-fontsquirrel-com\"><a href=\"#www-fontsquirrel-com\" class=\"headerlink\" title=\"www.fontsquirrel.com\"></a><a href=\"https://www.fontsquirrel.com/\">www.fontsquirrel.com</a></h3><p>字体站, 可以找到大量的免费开源字体, 同时可以将字体压缩为web字体.</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"typescale-com\"><a href=\"#typescale-com\" class=\"headerlink\" title=\"typescale.com\"></a><a href=\"https://typescale.com/\">typescale.com</a></h3><p>响应式站点的相对字体大小单位计算站点. 快速得到准确的rem数值.</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"bennettfeely-com\"><a href=\"#bennettfeely-com\" class=\"headerlink\" title=\"bennettfeely.com\"></a><a href=\"http://bennettfeely.com/\">bennettfeely.com</a></h3><p>在线切图工具, 可以把图片切成所需要的形状.</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"cssspritestool-com\"><a href=\"#cssspritestool-com\" class=\"headerlink\" title=\"cssspritestool.com\"></a><a href=\"http://cssspritestool.com/\">cssspritestool.com</a></h3><p>css图片合集在线制作工具</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"responsivebreakpoints-com\"><a href=\"#responsivebreakpoints-com\" class=\"headerlink\" title=\"responsivebreakpoints.com\"></a><a href=\"http://responsivebreakpoints.com/\">responsivebreakpoints.com</a></h3><p>响应式图片集在线生成工具</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"cloudconvert-com\"><a href=\"#cloudconvert-com\" class=\"headerlink\" title=\"cloudconvert.com\"></a><a href=\"https://cloudconvert.com/\">cloudconvert.com</a></h3><p>文件格式在线转换工具</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"svgbackgrounds-com\"><a href=\"#svgbackgrounds-com\" class=\"headerlink\" title=\"svgbackgrounds.com\"></a><a href=\"http://svgbackgrounds.com/\">svgbackgrounds.com</a></h3><p>svg背景图生成网站</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"cubic-bezier-com\"><a href=\"#cubic-bezier-com\" class=\"headerlink\" title=\"cubic-bezier.com&#x2F;\"></a><a href=\"https://cubic-bezier.com/\">cubic-bezier.com&#x2F;</a></h3><p>css动画函数曲线生成器.</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"animate-style\"><a href=\"#animate-style\" class=\"headerlink\" title=\"animate.style\"></a><a href=\"http://animate.style/\">animate.style</a></h3><p>css动画样式库</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"yesno-wtf\"><a href=\"#yesno-wtf\" class=\"headerlink\" title=\"yesno.wtf\"></a><a href=\"https://yesno.wtf/\">yesno.wtf</a></h3><p>一个简单的api测试站点, 调用<code>/api</code>得到一个json对象的数据, 包含一个随机的yes,no,maybe结果以及一个gif动图地址…从动图的尿性来说…wtf域名选的很贴切…</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"brandcolors-net\"><a href=\"#brandcolors-net\" class=\"headerlink\" title=\"brandcolors.net\"></a><a href=\"https://brandcolors.net/\">brandcolors.net</a></h3><p>品牌色板, 各类品牌的配色方案集合.</p>\n<h3 id=\"colors-muz-li\"><a href=\"#colors-muz-li\" class=\"headerlink\" title=\"colors.muz.li\"></a><a href=\"https://colors.muz.li/\">colors.muz.li</a></h3><p>根据上传的图片自动分析出对应的配色方案与色板文件, 相当nice!!!</p>\n<p><img src=\"/assets/img/separator_1.png\" alt=\"sep\"></p>\n<h3 id=\"color-hailpixel-com\"><a href=\"#color-hailpixel-com\" class=\"headerlink\" title=\"color.hailpixel.com\"></a><a href=\"https://color.hailpixel.com/\">color.hailpixel.com</a></h3><p>快速创建色板的在线工具, 简单上手到无以复加…</p>\n<h3 id=\"zhongguose-com\"><a href=\"#zhongguose-com\" class=\"headerlink\" title=\"zhongguose.com\"></a><a href=\"https://zhongguose.com/\">zhongguose.com</a></h3><p>中国风配色查询网站, 访问速度快, 颜色也很舒服.</p>\n"},{"title":"1. 第一个Django项目","date":"2023-12-13T08:41:08.345Z","image":"/assets/img/48223734b31de65181a4a38de6d8ac54.png","_content":"\n## 前期准备\n\n[Django在线文档](https://docs.djangoproject.com/en/4.2/)\n\n下载pipenv\n\n```pip install pipenv```\n\n下载: [vscode](https://code.visualstudio.com)\n\nVS Code必备插件:\n\n* python\n\n* pylint\n\n  > 在vscode中会出现某些生成代码存在格式问题, 如import未在文件头等, 可以通过注释解决, 如:\n  >\n  > ```pylint: disable=C0415```\n\n* autopep8\n\n## 创建项目\n\n```dash\nmkdir project\ncd project \n\npipenv install django\npipenv shell\n\ndjango-admin startproject projectname .\n```\n\n## 创建 Django app\n\n```bash\npython manage.py startapp app\npython manage.py runserver\n```\n\n在`settings.py`文件中添加创建的app\n\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    # 'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'playground'\n]\n```\n\n## 编写一个View\n\n在创建的app中找到`views.py`文件\n\n```python\nfrom django.shortcuts import render\nfrom django.http import HttpResponse\n\n# Create your views here.\ndef say_hello(request):\n    return HttpResponse('hello world')\n```\n\n在app目录下创建`urls.py`文件\n\n```python\n# 这是app内部的urls配置\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('hello/', views.say_hello)\n]\n```\n\n在项目的`urls.py`文件中配置子程序的url\n\n```python\nfrom django.contrib import admin\n# 需要包含其他的配置文件,添加 `include` 引用\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    # 配置子app的路由\n    path('playground/', include('playground.urls'))\n]\n\n```\n\n## 使用模板\n\n在app目录中创建一个模板目录 `templates`\n\n创建一个html文件, 比如`hello.html`, 编辑代码\n\n```html\n<h1>hello {{ name }}</h1>\n```\n\n修改`app/views.py`的代码\n\n```python\nfrom django.shortcuts import render\nfrom django.http import HttpResponse\n\n# Create your views here.\ndef say_hello(request):\n    return render(request, 'hello.html' , {'name': 'Nestor'})\n\n```\n\n## 使用Django debug toolbar进行调试\n\n文档:[https://django-debug-toolbar.readthedocs.io/en/latest/](https://django-debug-toolbar.readthedocs.io/en/latest/)\n\n```zsh\npipenv install django-debug-toolbar\n```\n\n1. 在`settings.py`文件中添加调试工具相关配置\n\n   ```python\n   INSTALLED_APPS = [\n       # ...\n       \"debug_toolbar\",\n       # ...\n   ]\n   \n   MIDDLEWARE = [\n       # ...\n       \"debug_toolbar.middleware.DebugToolbarMiddleware\",\n       # ...\n   ]\n   \n   # 直接添加在`settings.py`文件中 \n   INTERNAL_IPS = [\n       # ...\n       \"127.0.0.1\",\n       # ...\n   ]\n   ```\n\n2. 在`urls.py`配置文件中添加debug路由\n\n   ```python\n   from django.urls import include, path\n   \n   urlpatterns = [\n       # ...\n       path(\"__debug__/\", include(\"debug_toolbar.urls\")),\n   ]\n   ```\n","source":"_posts/django/1-first-django-project.md","raw":"---\ntitle: 1. 第一个Django项目\ndate: 2023-11-5 01:23:36 +08000\ncategories: [笔记, Django]\ntags: [python, django, backend]\nimage: /assets/img/48223734b31de65181a4a38de6d8ac54.png\n---\n\n## 前期准备\n\n[Django在线文档](https://docs.djangoproject.com/en/4.2/)\n\n下载pipenv\n\n```pip install pipenv```\n\n下载: [vscode](https://code.visualstudio.com)\n\nVS Code必备插件:\n\n* python\n\n* pylint\n\n  > 在vscode中会出现某些生成代码存在格式问题, 如import未在文件头等, 可以通过注释解决, 如:\n  >\n  > ```pylint: disable=C0415```\n\n* autopep8\n\n## 创建项目\n\n```dash\nmkdir project\ncd project \n\npipenv install django\npipenv shell\n\ndjango-admin startproject projectname .\n```\n\n## 创建 Django app\n\n```bash\npython manage.py startapp app\npython manage.py runserver\n```\n\n在`settings.py`文件中添加创建的app\n\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    # 'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'playground'\n]\n```\n\n## 编写一个View\n\n在创建的app中找到`views.py`文件\n\n```python\nfrom django.shortcuts import render\nfrom django.http import HttpResponse\n\n# Create your views here.\ndef say_hello(request):\n    return HttpResponse('hello world')\n```\n\n在app目录下创建`urls.py`文件\n\n```python\n# 这是app内部的urls配置\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('hello/', views.say_hello)\n]\n```\n\n在项目的`urls.py`文件中配置子程序的url\n\n```python\nfrom django.contrib import admin\n# 需要包含其他的配置文件,添加 `include` 引用\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    # 配置子app的路由\n    path('playground/', include('playground.urls'))\n]\n\n```\n\n## 使用模板\n\n在app目录中创建一个模板目录 `templates`\n\n创建一个html文件, 比如`hello.html`, 编辑代码\n\n```html\n<h1>hello {{ name }}</h1>\n```\n\n修改`app/views.py`的代码\n\n```python\nfrom django.shortcuts import render\nfrom django.http import HttpResponse\n\n# Create your views here.\ndef say_hello(request):\n    return render(request, 'hello.html' , {'name': 'Nestor'})\n\n```\n\n## 使用Django debug toolbar进行调试\n\n文档:[https://django-debug-toolbar.readthedocs.io/en/latest/](https://django-debug-toolbar.readthedocs.io/en/latest/)\n\n```zsh\npipenv install django-debug-toolbar\n```\n\n1. 在`settings.py`文件中添加调试工具相关配置\n\n   ```python\n   INSTALLED_APPS = [\n       # ...\n       \"debug_toolbar\",\n       # ...\n   ]\n   \n   MIDDLEWARE = [\n       # ...\n       \"debug_toolbar.middleware.DebugToolbarMiddleware\",\n       # ...\n   ]\n   \n   # 直接添加在`settings.py`文件中 \n   INTERNAL_IPS = [\n       # ...\n       \"127.0.0.1\",\n       # ...\n   ]\n   ```\n\n2. 在`urls.py`配置文件中添加debug路由\n\n   ```python\n   from django.urls import include, path\n   \n   urlpatterns = [\n       # ...\n       path(\"__debug__/\", include(\"debug_toolbar.urls\")),\n   ]\n   ```\n","slug":"django-1-first-django-project","published":1,"updated":"2023-12-13T08:41:08.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5uz000ni3erd6voc7xp","content":"<h2 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h2><p><a href=\"https://docs.djangoproject.com/en/4.2/\">Django在线文档</a></p>\n<p>下载pipenv</p>\n<p><code>pip install pipenv</code></p>\n<p>下载: <a href=\"https://code.visualstudio.com/\">vscode</a></p>\n<p>VS Code必备插件:</p>\n<ul>\n<li><p>python</p>\n</li>\n<li><p>pylint</p>\n<blockquote>\n<p>在vscode中会出现某些生成代码存在格式问题, 如import未在文件头等, 可以通过注释解决, 如:</p>\n<p><code>pylint: disable=C0415</code></p>\n</blockquote>\n</li>\n<li><p>autopep8</p>\n</li>\n</ul>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><pre><code class=\"dash\">mkdir project\ncd project \n\npipenv install django\npipenv shell\n\ndjango-admin startproject projectname .\n</code></pre>\n<h2 id=\"创建-Django-app\"><a href=\"#创建-Django-app\" class=\"headerlink\" title=\"创建 Django app\"></a>创建 Django app</h2><pre><code class=\"bash\">python manage.py startapp app\npython manage.py runserver\n</code></pre>\n<p>在<code>settings.py</code>文件中添加创建的app</p>\n<pre><code class=\"python\">INSTALLED_APPS = [\n    &#39;django.contrib.admin&#39;,\n    &#39;django.contrib.auth&#39;,\n    &#39;django.contrib.contenttypes&#39;,\n    # &#39;django.contrib.sessions&#39;,\n    &#39;django.contrib.messages&#39;,\n    &#39;django.contrib.staticfiles&#39;,\n    &#39;playground&#39;\n]\n</code></pre>\n<h2 id=\"编写一个View\"><a href=\"#编写一个View\" class=\"headerlink\" title=\"编写一个View\"></a>编写一个View</h2><p>在创建的app中找到<code>views.py</code>文件</p>\n<pre><code class=\"python\">from django.shortcuts import render\nfrom django.http import HttpResponse\n\n# Create your views here.\ndef say_hello(request):\n    return HttpResponse(&#39;hello world&#39;)\n</code></pre>\n<p>在app目录下创建<code>urls.py</code>文件</p>\n<pre><code class=\"python\"># 这是app内部的urls配置\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path(&#39;hello/&#39;, views.say_hello)\n]\n</code></pre>\n<p>在项目的<code>urls.py</code>文件中配置子程序的url</p>\n<pre><code class=\"python\">from django.contrib import admin\n# 需要包含其他的配置文件,添加 `include` 引用\nfrom django.urls import path, include\n\nurlpatterns = [\n    path(&#39;admin/&#39;, admin.site.urls),\n    # 配置子app的路由\n    path(&#39;playground/&#39;, include(&#39;playground.urls&#39;))\n]\n</code></pre>\n<h2 id=\"使用模板\"><a href=\"#使用模板\" class=\"headerlink\" title=\"使用模板\"></a>使用模板</h2><p>在app目录中创建一个模板目录 <code>templates</code></p>\n<p>创建一个html文件, 比如<code>hello.html</code>, 编辑代码</p>\n<pre><code class=\"html\">&lt;h1&gt;hello &#123;&#123; name &#125;&#125;&lt;/h1&gt;\n</code></pre>\n<p>修改<code>app/views.py</code>的代码</p>\n<pre><code class=\"python\">from django.shortcuts import render\nfrom django.http import HttpResponse\n\n# Create your views here.\ndef say_hello(request):\n    return render(request, &#39;hello.html&#39; , &#123;&#39;name&#39;: &#39;Nestor&#39;&#125;)\n</code></pre>\n<h2 id=\"使用Django-debug-toolbar进行调试\"><a href=\"#使用Django-debug-toolbar进行调试\" class=\"headerlink\" title=\"使用Django debug toolbar进行调试\"></a>使用Django debug toolbar进行调试</h2><p>文档:<a href=\"https://django-debug-toolbar.readthedocs.io/en/latest/\">https://django-debug-toolbar.readthedocs.io/en/latest/</a></p>\n<pre><code class=\"zsh\">pipenv install django-debug-toolbar\n</code></pre>\n<ol>\n<li><p>在<code>settings.py</code>文件中添加调试工具相关配置</p>\n<pre><code class=\"python\">INSTALLED_APPS = [\n    # ...\n    &quot;debug_toolbar&quot;,\n    # ...\n]\n\nMIDDLEWARE = [\n    # ...\n    &quot;debug_toolbar.middleware.DebugToolbarMiddleware&quot;,\n    # ...\n]\n\n# 直接添加在`settings.py`文件中 \nINTERNAL_IPS = [\n    # ...\n    &quot;127.0.0.1&quot;,\n    # ...\n]\n</code></pre>\n</li>\n<li><p>在<code>urls.py</code>配置文件中添加debug路由</p>\n<pre><code class=\"python\">from django.urls import include, path\n\nurlpatterns = [\n    # ...\n    path(&quot;__debug__/&quot;, include(&quot;debug_toolbar.urls&quot;)),\n]\n</code></pre>\n</li>\n</ol>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h2><p><a href=\"https://docs.djangoproject.com/en/4.2/\">Django在线文档</a></p>\n<p>下载pipenv</p>\n<p><code>pip install pipenv</code></p>\n<p>下载: <a href=\"https://code.visualstudio.com/\">vscode</a></p>\n<p>VS Code必备插件:</p>\n<ul>\n<li><p>python</p>\n</li>\n<li><p>pylint</p>\n<blockquote>\n<p>在vscode中会出现某些生成代码存在格式问题, 如import未在文件头等, 可以通过注释解决, 如:</p>\n<p><code>pylint: disable=C0415</code></p>\n</blockquote>\n</li>\n<li><p>autopep8</p>\n</li>\n</ul>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><pre><code class=\"dash\">mkdir project\ncd project \n\npipenv install django\npipenv shell\n\ndjango-admin startproject projectname .\n</code></pre>\n<h2 id=\"创建-Django-app\"><a href=\"#创建-Django-app\" class=\"headerlink\" title=\"创建 Django app\"></a>创建 Django app</h2><pre><code class=\"bash\">python manage.py startapp app\npython manage.py runserver\n</code></pre>\n<p>在<code>settings.py</code>文件中添加创建的app</p>\n<pre><code class=\"python\">INSTALLED_APPS = [\n    &#39;django.contrib.admin&#39;,\n    &#39;django.contrib.auth&#39;,\n    &#39;django.contrib.contenttypes&#39;,\n    # &#39;django.contrib.sessions&#39;,\n    &#39;django.contrib.messages&#39;,\n    &#39;django.contrib.staticfiles&#39;,\n    &#39;playground&#39;\n]\n</code></pre>\n<h2 id=\"编写一个View\"><a href=\"#编写一个View\" class=\"headerlink\" title=\"编写一个View\"></a>编写一个View</h2><p>在创建的app中找到<code>views.py</code>文件</p>\n<pre><code class=\"python\">from django.shortcuts import render\nfrom django.http import HttpResponse\n\n# Create your views here.\ndef say_hello(request):\n    return HttpResponse(&#39;hello world&#39;)\n</code></pre>\n<p>在app目录下创建<code>urls.py</code>文件</p>\n<pre><code class=\"python\"># 这是app内部的urls配置\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path(&#39;hello/&#39;, views.say_hello)\n]\n</code></pre>\n<p>在项目的<code>urls.py</code>文件中配置子程序的url</p>\n<pre><code class=\"python\">from django.contrib import admin\n# 需要包含其他的配置文件,添加 `include` 引用\nfrom django.urls import path, include\n\nurlpatterns = [\n    path(&#39;admin/&#39;, admin.site.urls),\n    # 配置子app的路由\n    path(&#39;playground/&#39;, include(&#39;playground.urls&#39;))\n]\n</code></pre>\n<h2 id=\"使用模板\"><a href=\"#使用模板\" class=\"headerlink\" title=\"使用模板\"></a>使用模板</h2><p>在app目录中创建一个模板目录 <code>templates</code></p>\n<p>创建一个html文件, 比如<code>hello.html</code>, 编辑代码</p>\n<pre><code class=\"html\">&lt;h1&gt;hello &#123;&#123; name &#125;&#125;&lt;/h1&gt;\n</code></pre>\n<p>修改<code>app/views.py</code>的代码</p>\n<pre><code class=\"python\">from django.shortcuts import render\nfrom django.http import HttpResponse\n\n# Create your views here.\ndef say_hello(request):\n    return render(request, &#39;hello.html&#39; , &#123;&#39;name&#39;: &#39;Nestor&#39;&#125;)\n</code></pre>\n<h2 id=\"使用Django-debug-toolbar进行调试\"><a href=\"#使用Django-debug-toolbar进行调试\" class=\"headerlink\" title=\"使用Django debug toolbar进行调试\"></a>使用Django debug toolbar进行调试</h2><p>文档:<a href=\"https://django-debug-toolbar.readthedocs.io/en/latest/\">https://django-debug-toolbar.readthedocs.io/en/latest/</a></p>\n<pre><code class=\"zsh\">pipenv install django-debug-toolbar\n</code></pre>\n<ol>\n<li><p>在<code>settings.py</code>文件中添加调试工具相关配置</p>\n<pre><code class=\"python\">INSTALLED_APPS = [\n    # ...\n    &quot;debug_toolbar&quot;,\n    # ...\n]\n\nMIDDLEWARE = [\n    # ...\n    &quot;debug_toolbar.middleware.DebugToolbarMiddleware&quot;,\n    # ...\n]\n\n# 直接添加在`settings.py`文件中 \nINTERNAL_IPS = [\n    # ...\n    &quot;127.0.0.1&quot;,\n    # ...\n]\n</code></pre>\n</li>\n<li><p>在<code>urls.py</code>配置文件中添加debug路由</p>\n<pre><code class=\"python\">from django.urls import include, path\n\nurlpatterns = [\n    # ...\n    path(&quot;__debug__/&quot;, include(&quot;debug_toolbar.urls&quot;)),\n]\n</code></pre>\n</li>\n</ol>\n"},{"title":"10. 使用Django开发RESTFUL API","date":"2023-12-13T08:41:08.345Z","image":"https://www.django-rest-framework.org/img/logo.png","_content":"\nREST(Representational State Transfer), 一套客户端与服务器进行交互的规则\n\n## Resources\n\n可以理解为能够通过URL访问的对象, 比如`Product`, `Collection`等.\n\n比如:\n\n```url\nhttp://your.url/products\nhttp://your.url/products/1\nhttp://your.url/products/1/reviews\nhttp://your.url/products/1/reviews/1\n...\n```\n\n当客户端访问这些URL的时候, 后台会根据请求的URL以`HTML`, `XML`, `JSON`等呈现形式返回对应的数据.\n\n## HTTP method\n\n`GET`: 获取数据\n`POST`: 创建数据\n`PUT`: 更新数据\n`PATCH`: 部分更新\n`DELETE`: 删除数据\n\n例如创建一个Product, 可以发送:\n\n```text\nPOST /products\n\n    {\n        \"title\": \"new product\",\n        \"price\": 0.99,\n        ...\n    }\n```\n\n更新某个Product的数据, 则可以发送:\n\n```text\nPATCH /products/1\n\n    {\n        \"price\": 1.99,\n        ...\n    }\n```\n\n## 安装 djangorestframework\n\n```bash\npipenv install djangorestframework\n```\n\n配置app, 在`project/settings.py`文件中, 添加`INSTALLED_APP`配置:\n\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'rest_framework',\n]\n```\n\n## 创建 API Views\n\n以 `store` app为例, 在 `store/views.py` 文件中创建方法:\n\n```python\nfrom django.shortcuts import render\nfrom django.http import HttpResponse\n\n\ndef product_list(request):\n    return HttpResponse(\"ok\")\n\n```\n\n同时修改 `store/urls.py` 文件:\n\n```python\nfrom django.urls import path, include\nfrom . import views\n\nurlpatterns = [\n    path('', views.index),\n    path('products/', views.product_list)\n]\n```\n\n最后在 `project/urls.py` 中加入app的对应配置:\n\n```python\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('store/', include('store.urls'))\n]\n```\n\n此时, 通过浏览器访问 `http://127.0.0.1:8000/store/products/` 如果显示`ok`, 那么变代表创建成功了.\n\n## 使用 djangorestframework\n\n[官方文档](https://www.django-rest-framework.org)\n\nDjango的View通过`HttpRequest`和`HttpResponse`接收和返回请求, 但是这两个对象更多的是基于Django自身的`MTV`模式而设计的.\n\n为了更好的使用REST API, 需要通过`djangorestframework`所封装的`Request`和`Response`对象进行替换.\n\n修改`store/views.py`文件\n\n```python\nfrom django.shortcuts import render\nfrom rest_framework.decorators import api_view\nfrom rest_framework.response import Response\n\n@api_view()  # 该装饰器替换默认的request对象为djangorestframework的request对象\ndef product_list(request):\n    # 使用djangorestframwork的Response返回数据\n    return Response(\"ok\")\n```\n\n此时, 如果通过浏览器调用URL, 便会显示API的运行结果页面, 如下图所示\n![result](/assets/img/img_202311112248208661.png)\n__运行结果__\n\n但如果通过非浏览器调用, 就仅仅只会获得返回的json数据.\n\n### 根据ID获取对应的对象\n\n按照REST的规则, 获取全部对象的url是`GET products/`, 而获取指定id对象的url便应该是`GET products/id`.\n\n在`store/views.py`新建视图方法:\n\n```python\n# store/views.py\n@api_view()\ndef product_detail(request, product_id):\n    return Response(\"ok\")\n```\n\n同时更新配置文件:\n\n```python\n# store/urls.py\nfrom django.urls import path, include\nfrom . import views\n\nurlpatterns = [\n    path('', views.index),\n    path('products/', views.product_list),\n    path('products/<int:product_id>/', views.product_detail)\n]\n```\n\n> 视图方法中的形参名称`product_id`与路由配置中的形参名称必须相同, `<int:product_id>`限定了参数形式必须为int类型, 如果传入其他类型的参数则会跳转至404页面.\n{: .prompt-tip }\n","source":"_posts/django/10-using-restful-api-in-django.md","raw":"---\ntitle: 10. 使用Django开发RESTFUL API\ndate: 2023-11-11 16:08:45 +08000\ncategories: [笔记, Django]\ntags: [python, django, backend, REST]\nimage: https://www.django-rest-framework.org/img/logo.png\n---\n\nREST(Representational State Transfer), 一套客户端与服务器进行交互的规则\n\n## Resources\n\n可以理解为能够通过URL访问的对象, 比如`Product`, `Collection`等.\n\n比如:\n\n```url\nhttp://your.url/products\nhttp://your.url/products/1\nhttp://your.url/products/1/reviews\nhttp://your.url/products/1/reviews/1\n...\n```\n\n当客户端访问这些URL的时候, 后台会根据请求的URL以`HTML`, `XML`, `JSON`等呈现形式返回对应的数据.\n\n## HTTP method\n\n`GET`: 获取数据\n`POST`: 创建数据\n`PUT`: 更新数据\n`PATCH`: 部分更新\n`DELETE`: 删除数据\n\n例如创建一个Product, 可以发送:\n\n```text\nPOST /products\n\n    {\n        \"title\": \"new product\",\n        \"price\": 0.99,\n        ...\n    }\n```\n\n更新某个Product的数据, 则可以发送:\n\n```text\nPATCH /products/1\n\n    {\n        \"price\": 1.99,\n        ...\n    }\n```\n\n## 安装 djangorestframework\n\n```bash\npipenv install djangorestframework\n```\n\n配置app, 在`project/settings.py`文件中, 添加`INSTALLED_APP`配置:\n\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'rest_framework',\n]\n```\n\n## 创建 API Views\n\n以 `store` app为例, 在 `store/views.py` 文件中创建方法:\n\n```python\nfrom django.shortcuts import render\nfrom django.http import HttpResponse\n\n\ndef product_list(request):\n    return HttpResponse(\"ok\")\n\n```\n\n同时修改 `store/urls.py` 文件:\n\n```python\nfrom django.urls import path, include\nfrom . import views\n\nurlpatterns = [\n    path('', views.index),\n    path('products/', views.product_list)\n]\n```\n\n最后在 `project/urls.py` 中加入app的对应配置:\n\n```python\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('store/', include('store.urls'))\n]\n```\n\n此时, 通过浏览器访问 `http://127.0.0.1:8000/store/products/` 如果显示`ok`, 那么变代表创建成功了.\n\n## 使用 djangorestframework\n\n[官方文档](https://www.django-rest-framework.org)\n\nDjango的View通过`HttpRequest`和`HttpResponse`接收和返回请求, 但是这两个对象更多的是基于Django自身的`MTV`模式而设计的.\n\n为了更好的使用REST API, 需要通过`djangorestframework`所封装的`Request`和`Response`对象进行替换.\n\n修改`store/views.py`文件\n\n```python\nfrom django.shortcuts import render\nfrom rest_framework.decorators import api_view\nfrom rest_framework.response import Response\n\n@api_view()  # 该装饰器替换默认的request对象为djangorestframework的request对象\ndef product_list(request):\n    # 使用djangorestframwork的Response返回数据\n    return Response(\"ok\")\n```\n\n此时, 如果通过浏览器调用URL, 便会显示API的运行结果页面, 如下图所示\n![result](/assets/img/img_202311112248208661.png)\n__运行结果__\n\n但如果通过非浏览器调用, 就仅仅只会获得返回的json数据.\n\n### 根据ID获取对应的对象\n\n按照REST的规则, 获取全部对象的url是`GET products/`, 而获取指定id对象的url便应该是`GET products/id`.\n\n在`store/views.py`新建视图方法:\n\n```python\n# store/views.py\n@api_view()\ndef product_detail(request, product_id):\n    return Response(\"ok\")\n```\n\n同时更新配置文件:\n\n```python\n# store/urls.py\nfrom django.urls import path, include\nfrom . import views\n\nurlpatterns = [\n    path('', views.index),\n    path('products/', views.product_list),\n    path('products/<int:product_id>/', views.product_detail)\n]\n```\n\n> 视图方法中的形参名称`product_id`与路由配置中的形参名称必须相同, `<int:product_id>`限定了参数形式必须为int类型, 如果传入其他类型的参数则会跳转至404页面.\n{: .prompt-tip }\n","slug":"django-10-using-restful-api-in-django","published":1,"updated":"2023-12-13T08:41:08.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5uz000pi3er9vljappz","content":"<p>REST(Representational State Transfer), 一套客户端与服务器进行交互的规则</p>\n<h2 id=\"Resources\"><a href=\"#Resources\" class=\"headerlink\" title=\"Resources\"></a>Resources</h2><p>可以理解为能够通过URL访问的对象, 比如<code>Product</code>, <code>Collection</code>等.</p>\n<p>比如:</p>\n<pre><code class=\"url\">http://your.url/products\nhttp://your.url/products/1\nhttp://your.url/products/1/reviews\nhttp://your.url/products/1/reviews/1\n...\n</code></pre>\n<p>当客户端访问这些URL的时候, 后台会根据请求的URL以<code>HTML</code>, <code>XML</code>, <code>JSON</code>等呈现形式返回对应的数据.</p>\n<h2 id=\"HTTP-method\"><a href=\"#HTTP-method\" class=\"headerlink\" title=\"HTTP method\"></a>HTTP method</h2><p><code>GET</code>: 获取数据<br><code>POST</code>: 创建数据<br><code>PUT</code>: 更新数据<br><code>PATCH</code>: 部分更新<br><code>DELETE</code>: 删除数据</p>\n<p>例如创建一个Product, 可以发送:</p>\n<pre><code class=\"text\">POST /products\n\n    &#123;\n        &quot;title&quot;: &quot;new product&quot;,\n        &quot;price&quot;: 0.99,\n        ...\n    &#125;\n</code></pre>\n<p>更新某个Product的数据, 则可以发送:</p>\n<pre><code class=\"text\">PATCH /products/1\n\n    &#123;\n        &quot;price&quot;: 1.99,\n        ...\n    &#125;\n</code></pre>\n<h2 id=\"安装-djangorestframework\"><a href=\"#安装-djangorestframework\" class=\"headerlink\" title=\"安装 djangorestframework\"></a>安装 djangorestframework</h2><pre><code class=\"bash\">pipenv install djangorestframework\n</code></pre>\n<p>配置app, 在<code>project/settings.py</code>文件中, 添加<code>INSTALLED_APP</code>配置:</p>\n<pre><code class=\"python\">INSTALLED_APPS = [\n    &#39;django.contrib.admin&#39;,\n    &#39;django.contrib.auth&#39;,\n    &#39;django.contrib.contenttypes&#39;,\n    &#39;django.contrib.sessions&#39;,\n    &#39;django.contrib.messages&#39;,\n    &#39;django.contrib.staticfiles&#39;,\n    &#39;rest_framework&#39;,\n]\n</code></pre>\n<h2 id=\"创建-API-Views\"><a href=\"#创建-API-Views\" class=\"headerlink\" title=\"创建 API Views\"></a>创建 API Views</h2><p>以 <code>store</code> app为例, 在 <code>store/views.py</code> 文件中创建方法:</p>\n<pre><code class=\"python\">from django.shortcuts import render\nfrom django.http import HttpResponse\n\n\ndef product_list(request):\n    return HttpResponse(&quot;ok&quot;)\n</code></pre>\n<p>同时修改 <code>store/urls.py</code> 文件:</p>\n<pre><code class=\"python\">from django.urls import path, include\nfrom . import views\n\nurlpatterns = [\n    path(&#39;&#39;, views.index),\n    path(&#39;products/&#39;, views.product_list)\n]\n</code></pre>\n<p>最后在 <code>project/urls.py</code> 中加入app的对应配置:</p>\n<pre><code class=\"python\">urlpatterns = [\n    path(&#39;admin/&#39;, admin.site.urls),\n    path(&#39;store/&#39;, include(&#39;store.urls&#39;))\n]\n</code></pre>\n<p>此时, 通过浏览器访问 <code>http://127.0.0.1:8000/store/products/</code> 如果显示<code>ok</code>, 那么变代表创建成功了.</p>\n<h2 id=\"使用-djangorestframework\"><a href=\"#使用-djangorestframework\" class=\"headerlink\" title=\"使用 djangorestframework\"></a>使用 djangorestframework</h2><p><a href=\"https://www.django-rest-framework.org/\">官方文档</a></p>\n<p>Django的View通过<code>HttpRequest</code>和<code>HttpResponse</code>接收和返回请求, 但是这两个对象更多的是基于Django自身的<code>MTV</code>模式而设计的.</p>\n<p>为了更好的使用REST API, 需要通过<code>djangorestframework</code>所封装的<code>Request</code>和<code>Response</code>对象进行替换.</p>\n<p>修改<code>store/views.py</code>文件</p>\n<pre><code class=\"python\">from django.shortcuts import render\nfrom rest_framework.decorators import api_view\nfrom rest_framework.response import Response\n\n@api_view()  # 该装饰器替换默认的request对象为djangorestframework的request对象\ndef product_list(request):\n    # 使用djangorestframwork的Response返回数据\n    return Response(&quot;ok&quot;)\n</code></pre>\n<p>此时, 如果通过浏览器调用URL, 便会显示API的运行结果页面, 如下图所示<br><img src=\"/assets/img/img_202311112248208661.png\" alt=\"result\"><br><strong>运行结果</strong></p>\n<p>但如果通过非浏览器调用, 就仅仅只会获得返回的json数据.</p>\n<h3 id=\"根据ID获取对应的对象\"><a href=\"#根据ID获取对应的对象\" class=\"headerlink\" title=\"根据ID获取对应的对象\"></a>根据ID获取对应的对象</h3><p>按照REST的规则, 获取全部对象的url是<code>GET products/</code>, 而获取指定id对象的url便应该是<code>GET products/id</code>.</p>\n<p>在<code>store/views.py</code>新建视图方法:</p>\n<pre><code class=\"python\"># store/views.py\n@api_view()\ndef product_detail(request, product_id):\n    return Response(&quot;ok&quot;)\n</code></pre>\n<p>同时更新配置文件:</p>\n<pre><code class=\"python\"># store/urls.py\nfrom django.urls import path, include\nfrom . import views\n\nurlpatterns = [\n    path(&#39;&#39;, views.index),\n    path(&#39;products/&#39;, views.product_list),\n    path(&#39;products/&lt;int:product_id&gt;/&#39;, views.product_detail)\n]\n</code></pre>\n<blockquote>\n<p>视图方法中的形参名称<code>product_id</code>与路由配置中的形参名称必须相同, <code>&lt;int:product_id&gt;</code>限定了参数形式必须为int类型, 如果传入其他类型的参数则会跳转至404页面.<br>{: .prompt-tip }</p>\n</blockquote>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>REST(Representational State Transfer), 一套客户端与服务器进行交互的规则</p>\n<h2 id=\"Resources\"><a href=\"#Resources\" class=\"headerlink\" title=\"Resources\"></a>Resources</h2><p>可以理解为能够通过URL访问的对象, 比如<code>Product</code>, <code>Collection</code>等.</p>\n<p>比如:</p>\n<pre><code class=\"url\">http://your.url/products\nhttp://your.url/products/1\nhttp://your.url/products/1/reviews\nhttp://your.url/products/1/reviews/1\n...\n</code></pre>\n<p>当客户端访问这些URL的时候, 后台会根据请求的URL以<code>HTML</code>, <code>XML</code>, <code>JSON</code>等呈现形式返回对应的数据.</p>\n<h2 id=\"HTTP-method\"><a href=\"#HTTP-method\" class=\"headerlink\" title=\"HTTP method\"></a>HTTP method</h2><p><code>GET</code>: 获取数据<br><code>POST</code>: 创建数据<br><code>PUT</code>: 更新数据<br><code>PATCH</code>: 部分更新<br><code>DELETE</code>: 删除数据</p>\n<p>例如创建一个Product, 可以发送:</p>\n<pre><code class=\"text\">POST /products\n\n    &#123;\n        &quot;title&quot;: &quot;new product&quot;,\n        &quot;price&quot;: 0.99,\n        ...\n    &#125;\n</code></pre>\n<p>更新某个Product的数据, 则可以发送:</p>\n<pre><code class=\"text\">PATCH /products/1\n\n    &#123;\n        &quot;price&quot;: 1.99,\n        ...\n    &#125;\n</code></pre>\n<h2 id=\"安装-djangorestframework\"><a href=\"#安装-djangorestframework\" class=\"headerlink\" title=\"安装 djangorestframework\"></a>安装 djangorestframework</h2><pre><code class=\"bash\">pipenv install djangorestframework\n</code></pre>\n<p>配置app, 在<code>project/settings.py</code>文件中, 添加<code>INSTALLED_APP</code>配置:</p>\n<pre><code class=\"python\">INSTALLED_APPS = [\n    &#39;django.contrib.admin&#39;,\n    &#39;django.contrib.auth&#39;,\n    &#39;django.contrib.contenttypes&#39;,\n    &#39;django.contrib.sessions&#39;,\n    &#39;django.contrib.messages&#39;,\n    &#39;django.contrib.staticfiles&#39;,\n    &#39;rest_framework&#39;,\n]\n</code></pre>\n<h2 id=\"创建-API-Views\"><a href=\"#创建-API-Views\" class=\"headerlink\" title=\"创建 API Views\"></a>创建 API Views</h2><p>以 <code>store</code> app为例, 在 <code>store/views.py</code> 文件中创建方法:</p>\n<pre><code class=\"python\">from django.shortcuts import render\nfrom django.http import HttpResponse\n\n\ndef product_list(request):\n    return HttpResponse(&quot;ok&quot;)\n</code></pre>\n<p>同时修改 <code>store/urls.py</code> 文件:</p>\n<pre><code class=\"python\">from django.urls import path, include\nfrom . import views\n\nurlpatterns = [\n    path(&#39;&#39;, views.index),\n    path(&#39;products/&#39;, views.product_list)\n]\n</code></pre>\n<p>最后在 <code>project/urls.py</code> 中加入app的对应配置:</p>\n<pre><code class=\"python\">urlpatterns = [\n    path(&#39;admin/&#39;, admin.site.urls),\n    path(&#39;store/&#39;, include(&#39;store.urls&#39;))\n]\n</code></pre>\n<p>此时, 通过浏览器访问 <code>http://127.0.0.1:8000/store/products/</code> 如果显示<code>ok</code>, 那么变代表创建成功了.</p>\n<h2 id=\"使用-djangorestframework\"><a href=\"#使用-djangorestframework\" class=\"headerlink\" title=\"使用 djangorestframework\"></a>使用 djangorestframework</h2><p><a href=\"https://www.django-rest-framework.org/\">官方文档</a></p>\n<p>Django的View通过<code>HttpRequest</code>和<code>HttpResponse</code>接收和返回请求, 但是这两个对象更多的是基于Django自身的<code>MTV</code>模式而设计的.</p>\n<p>为了更好的使用REST API, 需要通过<code>djangorestframework</code>所封装的<code>Request</code>和<code>Response</code>对象进行替换.</p>\n<p>修改<code>store/views.py</code>文件</p>\n<pre><code class=\"python\">from django.shortcuts import render\nfrom rest_framework.decorators import api_view\nfrom rest_framework.response import Response\n\n@api_view()  # 该装饰器替换默认的request对象为djangorestframework的request对象\ndef product_list(request):\n    # 使用djangorestframwork的Response返回数据\n    return Response(&quot;ok&quot;)\n</code></pre>\n<p>此时, 如果通过浏览器调用URL, 便会显示API的运行结果页面, 如下图所示<br><img src=\"/assets/img/img_202311112248208661.png\" alt=\"result\"><br><strong>运行结果</strong></p>\n<p>但如果通过非浏览器调用, 就仅仅只会获得返回的json数据.</p>\n<h3 id=\"根据ID获取对应的对象\"><a href=\"#根据ID获取对应的对象\" class=\"headerlink\" title=\"根据ID获取对应的对象\"></a>根据ID获取对应的对象</h3><p>按照REST的规则, 获取全部对象的url是<code>GET products/</code>, 而获取指定id对象的url便应该是<code>GET products/id</code>.</p>\n<p>在<code>store/views.py</code>新建视图方法:</p>\n<pre><code class=\"python\"># store/views.py\n@api_view()\ndef product_detail(request, product_id):\n    return Response(&quot;ok&quot;)\n</code></pre>\n<p>同时更新配置文件:</p>\n<pre><code class=\"python\"># store/urls.py\nfrom django.urls import path, include\nfrom . import views\n\nurlpatterns = [\n    path(&#39;&#39;, views.index),\n    path(&#39;products/&#39;, views.product_list),\n    path(&#39;products/&lt;int:product_id&gt;/&#39;, views.product_detail)\n]\n</code></pre>\n<blockquote>\n<p>视图方法中的形参名称<code>product_id</code>与路由配置中的形参名称必须相同, <code>&lt;int:product_id&gt;</code>限定了参数形式必须为int类型, 如果传入其他类型的参数则会跳转至404页面.<br>{: .prompt-tip }</p>\n</blockquote>\n"},{"title":"修改gem国内源","date":"2023-12-13T08:41:08.352Z","_content":"\n默认gem源可能出现下载速度太慢的问题, 可以直接改为国内源:\n\n```bash\ngem sources --remove https://rubygems.org/\ngem sources -a https://mirrors.ustc.edu.cn/rubygems/\ngem sources -l\ngem sources -u\n```\n\n> 如果安装了`bundle` 可以同时将bundle的源一同改为国内源\n>\n> ```bash\n> bundle config mirror.https://rubygems.org https://mirrors.ustc.edu.cn/rubygems/\n> ```\n\n## 可选源\n\n* 腾讯源: `https://mirrors.cloud.tencent.com/rubygems/`\n* ruby-china: `https://gems.ruby-china.com/`\n* 中科大: `https://mirrors.ustc.edu.cn/rubygems/`\n","source":"_posts/others/set-gem-sources.md","raw":"---\ntitle: 修改gem国内源\ndate: 2023-11-11 13:56:48 +08000\ncategories: [速查, 配置]\ntags: [gem, config]\n---\n\n默认gem源可能出现下载速度太慢的问题, 可以直接改为国内源:\n\n```bash\ngem sources --remove https://rubygems.org/\ngem sources -a https://mirrors.ustc.edu.cn/rubygems/\ngem sources -l\ngem sources -u\n```\n\n> 如果安装了`bundle` 可以同时将bundle的源一同改为国内源\n>\n> ```bash\n> bundle config mirror.https://rubygems.org https://mirrors.ustc.edu.cn/rubygems/\n> ```\n\n## 可选源\n\n* 腾讯源: `https://mirrors.cloud.tencent.com/rubygems/`\n* ruby-china: `https://gems.ruby-china.com/`\n* 中科大: `https://mirrors.ustc.edu.cn/rubygems/`\n","slug":"others-set-gem-sources","published":1,"updated":"2023-12-13T08:41:08.352Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5uz000ti3ercqpye45m","content":"<p>默认gem源可能出现下载速度太慢的问题, 可以直接改为国内源:</p>\n<pre><code class=\"bash\">gem sources --remove https://rubygems.org/\ngem sources -a https://mirrors.ustc.edu.cn/rubygems/\ngem sources -l\ngem sources -u\n</code></pre>\n<blockquote>\n<p>如果安装了<code>bundle</code> 可以同时将bundle的源一同改为国内源</p>\n<pre><code class=\"bash\">bundle config mirror.https://rubygems.org https://mirrors.ustc.edu.cn/rubygems/\n</code></pre>\n</blockquote>\n<h2 id=\"可选源\"><a href=\"#可选源\" class=\"headerlink\" title=\"可选源\"></a>可选源</h2><ul>\n<li>腾讯源: <code>https://mirrors.cloud.tencent.com/rubygems/</code></li>\n<li>ruby-china: <code>https://gems.ruby-china.com/</code></li>\n<li>中科大: <code>https://mirrors.ustc.edu.cn/rubygems/</code></li>\n</ul>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>默认gem源可能出现下载速度太慢的问题, 可以直接改为国内源:</p>\n<pre><code class=\"bash\">gem sources --remove https://rubygems.org/\ngem sources -a https://mirrors.ustc.edu.cn/rubygems/\ngem sources -l\ngem sources -u\n</code></pre>\n<blockquote>\n<p>如果安装了<code>bundle</code> 可以同时将bundle的源一同改为国内源</p>\n<pre><code class=\"bash\">bundle config mirror.https://rubygems.org https://mirrors.ustc.edu.cn/rubygems/\n</code></pre>\n</blockquote>\n<h2 id=\"可选源\"><a href=\"#可选源\" class=\"headerlink\" title=\"可选源\"></a>可选源</h2><ul>\n<li>腾讯源: <code>https://mirrors.cloud.tencent.com/rubygems/</code></li>\n<li>ruby-china: <code>https://gems.ruby-china.com/</code></li>\n<li>中科大: <code>https://mirrors.ustc.edu.cn/rubygems/</code></li>\n</ul>\n"},{"title":"2. 创建基础的模型类","date":"2023-12-13T08:41:08.345Z","_content":"\n一个类就是一个表\n\ndjango会自动添加主键, 多数情况下不需要自己设置主键\n\n```python\nfrom django.db import models\n\n# Create your models here.\n\n\nclass Product(models.Model):\n    title = models.CharField(max_length=255)\n    description = models.TextField()\n    price = models.DecimalField(max_digits=6, decimal_places=2)\n    inventory = models.IntegerField()\n    last_updated = models.DateTimeField(auto_now=True)\n\n\nclass Customer(models.Model):\n    first_name = models.CharField(max_length=255)\n    last_name = models.CharField(max_length=255)\n    email = models.EmailField(unique=True)\n    phone = models.CharField(max_length=255)\n    birth_date = models.DateField(null=True)\n\n```\n\n## 选项字段\n\ndjango通过选项字段来处理枚举类型, 对该选项进行定义\n\n```python\nclass Customer(models.Model):\n\n    MEMBERSHIP_BRONZE = 'B'\n    MEMBERSHIP_SILVER = 'S'\n    MEMBERSHIP_GOLD = 'G'\n\n    MEMBERSHIP_CHOICES = [\n        (MEMBERSHIP_BRONZE, 'Bronze'),\n        (MEMBERSHIP_BRONZE, 'Silver'),\n        (MEMBERSHIP_GOLD, 'Gold')\n    ]\n    first_name = models.CharField(max_length=255)\n    last_name = models.CharField(max_length=255)\n    email = models.EmailField(unique=True)\n    phone = models.CharField(max_length=255)\n    birth_date = models.DateField(null=True)\n    membership = models.CharField(max_length=1,\n                                  choices=MEMBERSHIP_CHOICES,\n                                  default=MEMBERSHIP_BRONZE)\n\n```\n\n## 解决循环引用\n\n![image-20231109160342949](/assets/img/image-20231109160342949.png)\n\n在某些需求中, 可能存在两个表之间的相互外键引用, 如上图所示:\n\n* 多个Product可以隶属于一个Collection\n* 每个Collection最多只能有一款主打产品,\n\n于是就产生了Product与Collection之间相互引用的问题\n\n* Product (m) -- (1) Collection\n* Product (0,1) -- (1) Collection\n\n在models定义的过程中, 由于代码是从上到下编译的, 所以就会出现一个引用了未定义类型的问题.\n\n```python\nclass Collection(models.Model):\n    title = models.CharField(max_length=255)\n    # 由于Product尚未定义, 此时代码无法编译\n    #   featured_product = models.ForeignKey(\n    #   Product, on_delete=models.SET_NULL, null=True)\n    # 通过字符串来传递模型类的名称, 便可以解决这个问题\n    featured_product = models.ForeignKey(\n        'Product', on_delete=models.SET_NULL, null=True, related_name='+')\n    # other fields\n    \n    # !!!但是通过该方法, 虽然能够解决数据模型的相互依赖问题, 但是如果在后续维护时对Product进行重名经操作, 上面的字符串是不会同时修改的, 也就有可能引起其他异常\n    \nclass Product(models.Model):\n    title = models.CharField(max_length=255)\n    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)\n    # other fields\n```\n\n> 总的来说, 循环引用的问题并非无法解决, 但是在进行数据库设计的时候应当尽力避免\n{: .prompt-warning}\n","source":"_posts/django/2-creating-models.md","raw":"---\ntitle: 2. 创建基础的模型类\ndate: 2023-11-5 01:57:59 +08000\ncategories: [笔记, Django]\ntags: [python, django, backend]\n---\n\n一个类就是一个表\n\ndjango会自动添加主键, 多数情况下不需要自己设置主键\n\n```python\nfrom django.db import models\n\n# Create your models here.\n\n\nclass Product(models.Model):\n    title = models.CharField(max_length=255)\n    description = models.TextField()\n    price = models.DecimalField(max_digits=6, decimal_places=2)\n    inventory = models.IntegerField()\n    last_updated = models.DateTimeField(auto_now=True)\n\n\nclass Customer(models.Model):\n    first_name = models.CharField(max_length=255)\n    last_name = models.CharField(max_length=255)\n    email = models.EmailField(unique=True)\n    phone = models.CharField(max_length=255)\n    birth_date = models.DateField(null=True)\n\n```\n\n## 选项字段\n\ndjango通过选项字段来处理枚举类型, 对该选项进行定义\n\n```python\nclass Customer(models.Model):\n\n    MEMBERSHIP_BRONZE = 'B'\n    MEMBERSHIP_SILVER = 'S'\n    MEMBERSHIP_GOLD = 'G'\n\n    MEMBERSHIP_CHOICES = [\n        (MEMBERSHIP_BRONZE, 'Bronze'),\n        (MEMBERSHIP_BRONZE, 'Silver'),\n        (MEMBERSHIP_GOLD, 'Gold')\n    ]\n    first_name = models.CharField(max_length=255)\n    last_name = models.CharField(max_length=255)\n    email = models.EmailField(unique=True)\n    phone = models.CharField(max_length=255)\n    birth_date = models.DateField(null=True)\n    membership = models.CharField(max_length=1,\n                                  choices=MEMBERSHIP_CHOICES,\n                                  default=MEMBERSHIP_BRONZE)\n\n```\n\n## 解决循环引用\n\n![image-20231109160342949](/assets/img/image-20231109160342949.png)\n\n在某些需求中, 可能存在两个表之间的相互外键引用, 如上图所示:\n\n* 多个Product可以隶属于一个Collection\n* 每个Collection最多只能有一款主打产品,\n\n于是就产生了Product与Collection之间相互引用的问题\n\n* Product (m) -- (1) Collection\n* Product (0,1) -- (1) Collection\n\n在models定义的过程中, 由于代码是从上到下编译的, 所以就会出现一个引用了未定义类型的问题.\n\n```python\nclass Collection(models.Model):\n    title = models.CharField(max_length=255)\n    # 由于Product尚未定义, 此时代码无法编译\n    #   featured_product = models.ForeignKey(\n    #   Product, on_delete=models.SET_NULL, null=True)\n    # 通过字符串来传递模型类的名称, 便可以解决这个问题\n    featured_product = models.ForeignKey(\n        'Product', on_delete=models.SET_NULL, null=True, related_name='+')\n    # other fields\n    \n    # !!!但是通过该方法, 虽然能够解决数据模型的相互依赖问题, 但是如果在后续维护时对Product进行重名经操作, 上面的字符串是不会同时修改的, 也就有可能引起其他异常\n    \nclass Product(models.Model):\n    title = models.CharField(max_length=255)\n    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)\n    # other fields\n```\n\n> 总的来说, 循环引用的问题并非无法解决, 但是在进行数据库设计的时候应当尽力避免\n{: .prompt-warning}\n","slug":"django-2-creating-models","published":1,"updated":"2023-12-13T08:41:08.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5uz000wi3erfcq2gxw1","content":"<p>一个类就是一个表</p>\n<p>django会自动添加主键, 多数情况下不需要自己设置主键</p>\n<pre><code class=\"python\">from django.db import models\n\n# Create your models here.\n\n\nclass Product(models.Model):\n    title = models.CharField(max_length=255)\n    description = models.TextField()\n    price = models.DecimalField(max_digits=6, decimal_places=2)\n    inventory = models.IntegerField()\n    last_updated = models.DateTimeField(auto_now=True)\n\n\nclass Customer(models.Model):\n    first_name = models.CharField(max_length=255)\n    last_name = models.CharField(max_length=255)\n    email = models.EmailField(unique=True)\n    phone = models.CharField(max_length=255)\n    birth_date = models.DateField(null=True)\n</code></pre>\n<h2 id=\"选项字段\"><a href=\"#选项字段\" class=\"headerlink\" title=\"选项字段\"></a>选项字段</h2><p>django通过选项字段来处理枚举类型, 对该选项进行定义</p>\n<pre><code class=\"python\">class Customer(models.Model):\n\n    MEMBERSHIP_BRONZE = &#39;B&#39;\n    MEMBERSHIP_SILVER = &#39;S&#39;\n    MEMBERSHIP_GOLD = &#39;G&#39;\n\n    MEMBERSHIP_CHOICES = [\n        (MEMBERSHIP_BRONZE, &#39;Bronze&#39;),\n        (MEMBERSHIP_BRONZE, &#39;Silver&#39;),\n        (MEMBERSHIP_GOLD, &#39;Gold&#39;)\n    ]\n    first_name = models.CharField(max_length=255)\n    last_name = models.CharField(max_length=255)\n    email = models.EmailField(unique=True)\n    phone = models.CharField(max_length=255)\n    birth_date = models.DateField(null=True)\n    membership = models.CharField(max_length=1,\n                                  choices=MEMBERSHIP_CHOICES,\n                                  default=MEMBERSHIP_BRONZE)\n</code></pre>\n<h2 id=\"解决循环引用\"><a href=\"#解决循环引用\" class=\"headerlink\" title=\"解决循环引用\"></a>解决循环引用</h2><p><img src=\"/assets/img/image-20231109160342949.png\" alt=\"image-20231109160342949\"></p>\n<p>在某些需求中, 可能存在两个表之间的相互外键引用, 如上图所示:</p>\n<ul>\n<li>多个Product可以隶属于一个Collection</li>\n<li>每个Collection最多只能有一款主打产品,</li>\n</ul>\n<p>于是就产生了Product与Collection之间相互引用的问题</p>\n<ul>\n<li>Product (m) – (1) Collection</li>\n<li>Product (0,1) – (1) Collection</li>\n</ul>\n<p>在models定义的过程中, 由于代码是从上到下编译的, 所以就会出现一个引用了未定义类型的问题.</p>\n<pre><code class=\"python\">class Collection(models.Model):\n    title = models.CharField(max_length=255)\n    # 由于Product尚未定义, 此时代码无法编译\n    #   featured_product = models.ForeignKey(\n    #   Product, on_delete=models.SET_NULL, null=True)\n    # 通过字符串来传递模型类的名称, 便可以解决这个问题\n    featured_product = models.ForeignKey(\n        &#39;Product&#39;, on_delete=models.SET_NULL, null=True, related_name=&#39;+&#39;)\n    # other fields\n    \n    # !!!但是通过该方法, 虽然能够解决数据模型的相互依赖问题, 但是如果在后续维护时对Product进行重名经操作, 上面的字符串是不会同时修改的, 也就有可能引起其他异常\n    \nclass Product(models.Model):\n    title = models.CharField(max_length=255)\n    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)\n    # other fields\n</code></pre>\n<blockquote>\n<p>总的来说, 循环引用的问题并非无法解决, 但是在进行数据库设计的时候应当尽力避免<br>{: .prompt-warning}</p>\n</blockquote>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>一个类就是一个表</p>\n<p>django会自动添加主键, 多数情况下不需要自己设置主键</p>\n<pre><code class=\"python\">from django.db import models\n\n# Create your models here.\n\n\nclass Product(models.Model):\n    title = models.CharField(max_length=255)\n    description = models.TextField()\n    price = models.DecimalField(max_digits=6, decimal_places=2)\n    inventory = models.IntegerField()\n    last_updated = models.DateTimeField(auto_now=True)\n\n\nclass Customer(models.Model):\n    first_name = models.CharField(max_length=255)\n    last_name = models.CharField(max_length=255)\n    email = models.EmailField(unique=True)\n    phone = models.CharField(max_length=255)\n    birth_date = models.DateField(null=True)\n</code></pre>\n<h2 id=\"选项字段\"><a href=\"#选项字段\" class=\"headerlink\" title=\"选项字段\"></a>选项字段</h2><p>django通过选项字段来处理枚举类型, 对该选项进行定义</p>\n<pre><code class=\"python\">class Customer(models.Model):\n\n    MEMBERSHIP_BRONZE = &#39;B&#39;\n    MEMBERSHIP_SILVER = &#39;S&#39;\n    MEMBERSHIP_GOLD = &#39;G&#39;\n\n    MEMBERSHIP_CHOICES = [\n        (MEMBERSHIP_BRONZE, &#39;Bronze&#39;),\n        (MEMBERSHIP_BRONZE, &#39;Silver&#39;),\n        (MEMBERSHIP_GOLD, &#39;Gold&#39;)\n    ]\n    first_name = models.CharField(max_length=255)\n    last_name = models.CharField(max_length=255)\n    email = models.EmailField(unique=True)\n    phone = models.CharField(max_length=255)\n    birth_date = models.DateField(null=True)\n    membership = models.CharField(max_length=1,\n                                  choices=MEMBERSHIP_CHOICES,\n                                  default=MEMBERSHIP_BRONZE)\n</code></pre>\n<h2 id=\"解决循环引用\"><a href=\"#解决循环引用\" class=\"headerlink\" title=\"解决循环引用\"></a>解决循环引用</h2><p><img src=\"/assets/img/image-20231109160342949.png\" alt=\"image-20231109160342949\"></p>\n<p>在某些需求中, 可能存在两个表之间的相互外键引用, 如上图所示:</p>\n<ul>\n<li>多个Product可以隶属于一个Collection</li>\n<li>每个Collection最多只能有一款主打产品,</li>\n</ul>\n<p>于是就产生了Product与Collection之间相互引用的问题</p>\n<ul>\n<li>Product (m) – (1) Collection</li>\n<li>Product (0,1) – (1) Collection</li>\n</ul>\n<p>在models定义的过程中, 由于代码是从上到下编译的, 所以就会出现一个引用了未定义类型的问题.</p>\n<pre><code class=\"python\">class Collection(models.Model):\n    title = models.CharField(max_length=255)\n    # 由于Product尚未定义, 此时代码无法编译\n    #   featured_product = models.ForeignKey(\n    #   Product, on_delete=models.SET_NULL, null=True)\n    # 通过字符串来传递模型类的名称, 便可以解决这个问题\n    featured_product = models.ForeignKey(\n        &#39;Product&#39;, on_delete=models.SET_NULL, null=True, related_name=&#39;+&#39;)\n    # other fields\n    \n    # !!!但是通过该方法, 虽然能够解决数据模型的相互依赖问题, 但是如果在后续维护时对Product进行重名经操作, 上面的字符串是不会同时修改的, 也就有可能引起其他异常\n    \nclass Product(models.Model):\n    title = models.CharField(max_length=255)\n    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)\n    # other fields\n</code></pre>\n<blockquote>\n<p>总的来说, 循环引用的问题并非无法解决, 但是在进行数据库设计的时候应当尽力避免<br>{: .prompt-warning}</p>\n</blockquote>\n"},{"title":"3. 在Django项目中集成MySql","date":"2023-12-13T08:41:08.345Z","_content":"\n## 安装mysqlclient\n\n```bash\npipenv install mysqlclient\n```\n\n> 在使用`pipenv install mysqlclient`时报错, 本来以为是mysqlclient或者pipenv的问题, 反复尝试无果\n>\n> 又随便找了几个其他的包尝试安装, 包括`requests`,`pydoc`等\n>\n> 发现依然会出现同样的问题,但是像`django`等一些包就安装很顺利\n>\n> 最后找到一些解决方案, 需要安装一个名为`pkg-connfig`的包,\n>\n> ```zsh\n> sudo apt-get install pkg-config\n> ```\n>\n> 但是Mac 并不支持`apt-get`\n>\n> 于是只能换一种思路, 使用`brew`来安装`pkg-config`\n>\n> 经尝试\n>\n> ```zsh\n> brew install pkg-config\n> ```\n>\n> 运行完成之后`mysqlclient`便可以通过pipenv正常安装了\n>\n> > PS: brew安装:\n> >\n> > ```bash\n> > /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n> > ```\n>\n\n## 修改settings.py配置文件\n\nvscode快捷键: `cmd+T`/ `cmd+shift+O`\n\n修改`DATABASES`设置\n\n```python\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'storefront',\n        'HOST': 'localhost',\n        \"USER\": 'root',\n        \"PASSWORD\": '000000'\n    }\n}\n```\n\n## 运行自定义SQL\n\n1. 生成一个空的migration文件:\n\n   ```dash\n   # sotre是子app的名字\n   > python manage.py makemigrations store --empty\n   \n   Migrations for 'store':\n     store/migrations/0002_auto_20231107_0610.py\n   ```\n\n2. 可以修改该文件的名字, 如`0002_insert_test_data.py`\n\n3. 在文件中编辑SQL语句\n\n   ```python\n   class Migration(migrations.Migration):\n   \n       dependencies = [\n           ('store', '0001_initial'),\n       ]\n   \n       operations = [\n            # 第一条SQL用于部署\n            # 第二条SQL用于还原\n            # 具体执行那一条根据python manage.py migrate来进行操作\n           migrations.RunSQL(\"\"\"\n               INSERT INTO store_collection (title)\n               VALUES ('collection1')\n           \"\"\", \"\"\"\n               DELETE FROM store_collection\n               WHERE title = 'collection1'\n           \"\"\")\n       ]\n   \n   ```\n\n4. 部署SQL\n\n   ```bash\n   python manage.py migrate\n   ```\n\n5. 还原\n\n   ```bash\n   python manage.py migrate store 0001\n   ```\n\n## 添加测试数据\n\n测试数据在线工具: [https://mockaroo.com](https://mockaroo.com)\n\n在线编辑字段, 选择类型, 选择sql, 下载SQL文件\n\n在datagrip中执行即可\n\n或者使用`Faker`,`DataFactory`等python库进行数据生成\n","source":"_posts/django/3-using-mysql.md","raw":"---\ntitle: 3. 在Django项目中集成MySql\ndate: 2023-11-6 01:59:44 +08000\ncategories: [笔记, Django]\ntags: [python, django, backend]\n---\n\n## 安装mysqlclient\n\n```bash\npipenv install mysqlclient\n```\n\n> 在使用`pipenv install mysqlclient`时报错, 本来以为是mysqlclient或者pipenv的问题, 反复尝试无果\n>\n> 又随便找了几个其他的包尝试安装, 包括`requests`,`pydoc`等\n>\n> 发现依然会出现同样的问题,但是像`django`等一些包就安装很顺利\n>\n> 最后找到一些解决方案, 需要安装一个名为`pkg-connfig`的包,\n>\n> ```zsh\n> sudo apt-get install pkg-config\n> ```\n>\n> 但是Mac 并不支持`apt-get`\n>\n> 于是只能换一种思路, 使用`brew`来安装`pkg-config`\n>\n> 经尝试\n>\n> ```zsh\n> brew install pkg-config\n> ```\n>\n> 运行完成之后`mysqlclient`便可以通过pipenv正常安装了\n>\n> > PS: brew安装:\n> >\n> > ```bash\n> > /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n> > ```\n>\n\n## 修改settings.py配置文件\n\nvscode快捷键: `cmd+T`/ `cmd+shift+O`\n\n修改`DATABASES`设置\n\n```python\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'storefront',\n        'HOST': 'localhost',\n        \"USER\": 'root',\n        \"PASSWORD\": '000000'\n    }\n}\n```\n\n## 运行自定义SQL\n\n1. 生成一个空的migration文件:\n\n   ```dash\n   # sotre是子app的名字\n   > python manage.py makemigrations store --empty\n   \n   Migrations for 'store':\n     store/migrations/0002_auto_20231107_0610.py\n   ```\n\n2. 可以修改该文件的名字, 如`0002_insert_test_data.py`\n\n3. 在文件中编辑SQL语句\n\n   ```python\n   class Migration(migrations.Migration):\n   \n       dependencies = [\n           ('store', '0001_initial'),\n       ]\n   \n       operations = [\n            # 第一条SQL用于部署\n            # 第二条SQL用于还原\n            # 具体执行那一条根据python manage.py migrate来进行操作\n           migrations.RunSQL(\"\"\"\n               INSERT INTO store_collection (title)\n               VALUES ('collection1')\n           \"\"\", \"\"\"\n               DELETE FROM store_collection\n               WHERE title = 'collection1'\n           \"\"\")\n       ]\n   \n   ```\n\n4. 部署SQL\n\n   ```bash\n   python manage.py migrate\n   ```\n\n5. 还原\n\n   ```bash\n   python manage.py migrate store 0001\n   ```\n\n## 添加测试数据\n\n测试数据在线工具: [https://mockaroo.com](https://mockaroo.com)\n\n在线编辑字段, 选择类型, 选择sql, 下载SQL文件\n\n在datagrip中执行即可\n\n或者使用`Faker`,`DataFactory`等python库进行数据生成\n","slug":"django-3-using-mysql","published":1,"updated":"2023-12-13T08:41:08.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v0000zi3er3p7r5fza","content":"<h2 id=\"安装mysqlclient\"><a href=\"#安装mysqlclient\" class=\"headerlink\" title=\"安装mysqlclient\"></a>安装mysqlclient</h2><pre><code class=\"bash\">pipenv install mysqlclient\n</code></pre>\n<blockquote>\n<p>在使用<code>pipenv install mysqlclient</code>时报错, 本来以为是mysqlclient或者pipenv的问题, 反复尝试无果</p>\n<p>又随便找了几个其他的包尝试安装, 包括<code>requests</code>,<code>pydoc</code>等</p>\n<p>发现依然会出现同样的问题,但是像<code>django</code>等一些包就安装很顺利</p>\n<p>最后找到一些解决方案, 需要安装一个名为<code>pkg-connfig</code>的包,</p>\n<pre><code class=\"zsh\">sudo apt-get install pkg-config\n</code></pre>\n<p>但是Mac 并不支持<code>apt-get</code></p>\n<p>于是只能换一种思路, 使用<code>brew</code>来安装<code>pkg-config</code></p>\n<p>经尝试</p>\n<pre><code class=\"zsh\">brew install pkg-config\n</code></pre>\n<p>运行完成之后<code>mysqlclient</code>便可以通过pipenv正常安装了</p>\n<blockquote>\n<p>PS: brew安装:</p>\n<pre><code class=\"bash\">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;\n</code></pre>\n</blockquote>\n</blockquote>\n<h2 id=\"修改settings-py配置文件\"><a href=\"#修改settings-py配置文件\" class=\"headerlink\" title=\"修改settings.py配置文件\"></a>修改settings.py配置文件</h2><p>vscode快捷键: <code>cmd+T</code>&#x2F; <code>cmd+shift+O</code></p>\n<p>修改<code>DATABASES</code>设置</p>\n<pre><code class=\"python\">DATABASES = &#123;\n    &#39;default&#39;: &#123;\n        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,\n        &#39;NAME&#39;: &#39;storefront&#39;,\n        &#39;HOST&#39;: &#39;localhost&#39;,\n        &quot;USER&quot;: &#39;root&#39;,\n        &quot;PASSWORD&quot;: &#39;000000&#39;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"运行自定义SQL\"><a href=\"#运行自定义SQL\" class=\"headerlink\" title=\"运行自定义SQL\"></a>运行自定义SQL</h2><ol>\n<li><p>生成一个空的migration文件:</p>\n<pre><code class=\"dash\"># sotre是子app的名字\n&gt; python manage.py makemigrations store --empty\n\nMigrations for &#39;store&#39;:\n  store/migrations/0002_auto_20231107_0610.py\n</code></pre>\n</li>\n<li><p>可以修改该文件的名字, 如<code>0002_insert_test_data.py</code></p>\n</li>\n<li><p>在文件中编辑SQL语句</p>\n<pre><code class=\"python\">class Migration(migrations.Migration):\n\n    dependencies = [\n        (&#39;store&#39;, &#39;0001_initial&#39;),\n    ]\n\n    operations = [\n         # 第一条SQL用于部署\n         # 第二条SQL用于还原\n         # 具体执行那一条根据python manage.py migrate来进行操作\n        migrations.RunSQL(&quot;&quot;&quot;\n            INSERT INTO store_collection (title)\n            VALUES (&#39;collection1&#39;)\n        &quot;&quot;&quot;, &quot;&quot;&quot;\n            DELETE FROM store_collection\n            WHERE title = &#39;collection1&#39;\n        &quot;&quot;&quot;)\n    ]\n</code></pre>\n</li>\n<li><p>部署SQL</p>\n<pre><code class=\"bash\">python manage.py migrate\n</code></pre>\n</li>\n<li><p>还原</p>\n<pre><code class=\"bash\">python manage.py migrate store 0001\n</code></pre>\n</li>\n</ol>\n<h2 id=\"添加测试数据\"><a href=\"#添加测试数据\" class=\"headerlink\" title=\"添加测试数据\"></a>添加测试数据</h2><p>测试数据在线工具: <a href=\"https://mockaroo.com/\">https://mockaroo.com</a></p>\n<p>在线编辑字段, 选择类型, 选择sql, 下载SQL文件</p>\n<p>在datagrip中执行即可</p>\n<p>或者使用<code>Faker</code>,<code>DataFactory</code>等python库进行数据生成</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"安装mysqlclient\"><a href=\"#安装mysqlclient\" class=\"headerlink\" title=\"安装mysqlclient\"></a>安装mysqlclient</h2><pre><code class=\"bash\">pipenv install mysqlclient\n</code></pre>\n<blockquote>\n<p>在使用<code>pipenv install mysqlclient</code>时报错, 本来以为是mysqlclient或者pipenv的问题, 反复尝试无果</p>\n<p>又随便找了几个其他的包尝试安装, 包括<code>requests</code>,<code>pydoc</code>等</p>\n<p>发现依然会出现同样的问题,但是像<code>django</code>等一些包就安装很顺利</p>\n<p>最后找到一些解决方案, 需要安装一个名为<code>pkg-connfig</code>的包,</p>\n<pre><code class=\"zsh\">sudo apt-get install pkg-config\n</code></pre>\n<p>但是Mac 并不支持<code>apt-get</code></p>\n<p>于是只能换一种思路, 使用<code>brew</code>来安装<code>pkg-config</code></p>\n<p>经尝试</p>\n<pre><code class=\"zsh\">brew install pkg-config\n</code></pre>\n<p>运行完成之后<code>mysqlclient</code>便可以通过pipenv正常安装了</p>\n<blockquote>\n<p>PS: brew安装:</p>\n<pre><code class=\"bash\">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;\n</code></pre>\n</blockquote>\n</blockquote>\n<h2 id=\"修改settings-py配置文件\"><a href=\"#修改settings-py配置文件\" class=\"headerlink\" title=\"修改settings.py配置文件\"></a>修改settings.py配置文件</h2><p>vscode快捷键: <code>cmd+T</code>&#x2F; <code>cmd+shift+O</code></p>\n<p>修改<code>DATABASES</code>设置</p>\n<pre><code class=\"python\">DATABASES = &#123;\n    &#39;default&#39;: &#123;\n        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,\n        &#39;NAME&#39;: &#39;storefront&#39;,\n        &#39;HOST&#39;: &#39;localhost&#39;,\n        &quot;USER&quot;: &#39;root&#39;,\n        &quot;PASSWORD&quot;: &#39;000000&#39;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"运行自定义SQL\"><a href=\"#运行自定义SQL\" class=\"headerlink\" title=\"运行自定义SQL\"></a>运行自定义SQL</h2><ol>\n<li><p>生成一个空的migration文件:</p>\n<pre><code class=\"dash\"># sotre是子app的名字\n&gt; python manage.py makemigrations store --empty\n\nMigrations for &#39;store&#39;:\n  store/migrations/0002_auto_20231107_0610.py\n</code></pre>\n</li>\n<li><p>可以修改该文件的名字, 如<code>0002_insert_test_data.py</code></p>\n</li>\n<li><p>在文件中编辑SQL语句</p>\n<pre><code class=\"python\">class Migration(migrations.Migration):\n\n    dependencies = [\n        (&#39;store&#39;, &#39;0001_initial&#39;),\n    ]\n\n    operations = [\n         # 第一条SQL用于部署\n         # 第二条SQL用于还原\n         # 具体执行那一条根据python manage.py migrate来进行操作\n        migrations.RunSQL(&quot;&quot;&quot;\n            INSERT INTO store_collection (title)\n            VALUES (&#39;collection1&#39;)\n        &quot;&quot;&quot;, &quot;&quot;&quot;\n            DELETE FROM store_collection\n            WHERE title = &#39;collection1&#39;\n        &quot;&quot;&quot;)\n    ]\n</code></pre>\n</li>\n<li><p>部署SQL</p>\n<pre><code class=\"bash\">python manage.py migrate\n</code></pre>\n</li>\n<li><p>还原</p>\n<pre><code class=\"bash\">python manage.py migrate store 0001\n</code></pre>\n</li>\n</ol>\n<h2 id=\"添加测试数据\"><a href=\"#添加测试数据\" class=\"headerlink\" title=\"添加测试数据\"></a>添加测试数据</h2><p>测试数据在线工具: <a href=\"https://mockaroo.com/\">https://mockaroo.com</a></p>\n<p>在线编辑字段, 选择类型, 选择sql, 下载SQL文件</p>\n<p>在datagrip中执行即可</p>\n<p>或者使用<code>Faker</code>,<code>DataFactory</code>等python库进行数据生成</p>\n"},{"title":"5. Django-admin后台管理","date":"2023-12-13T08:41:08.346Z","_content":"\n有django提供的一个数据管理后台, 功能强大, 熟练使用可以节省大量的编码时间\n[Django Admin完整官方文档](https://docs.djangoproject.com/en/dev/ref/contrib/admin/)\n\n## 基本使用\n\n可以通过`admin/`进行访问, 如\n\n```url\nhttp://127.0.0.1:8000/admin\n```\n\n在使用admin之前, 需要创建admin用户, 在终端执行:\n\n```zsh\npython manage.py createsuperuser\n```\n\n输入用户名密码即可.\n\n忘记密码时可以通过终端命令直接修改\n\n```zsh\npython manage.py changepassword [username]\n```\n\n### 修改后台页面标题\n\n```python\nfrom django.contrib import admin\n\n# 可以直接在项目的urls.py中添加, 但不推荐\nadmin.site.site_header = 'My site to learn django'\nadmin.site.index_title = \"Site Apps\"\n```\n\n![image-20231108212229095](/assets/img/image-20231108212229095.png){: .shadow}\n\n## 注册模块\n\n要通过admin后台管理某个app的数据, 需要先对其进行注册, 如`playground`模块的`Product`对象\n\n```python\n# `playground/admin.py`\nfrom django.contrib import admin\nfrom . import models\n\nadmin.site.register(models.Product)\n```\n\n## 修改显示字段和表排序方式\n\n```python\nclass Product(models.Model):\n    title = models.CharField(max_length=255)\n    # other fields ...\n\n    def __str__(self) -> str:\n        return str(self.title)\n\n    class Meta:\n        ordering = ['title']\n```\n\n## 自定义管理后台\n\n通过对ORM对象的设置完成自定义的后台管理\n\n```python\n# `playground/admin.py`\nfrom django.contrib import admin\nfrom . import models\n\n# 如果不使用装饰器可以使用代码进行注册\n# admin.site.register(models.Product, ProductAdmin)\n# 只能注册一次, 即装饰器和代码注册只能二选一\n@admin.register(models.Product)\nclass ProductAdmin(admin.ModelAdmin):\n    list_display = [\"name\", 'price', 'description']\n    list_editable = ['price']\n    list_per_page = 20\n    \n    # ---添加计算字段---\n    # 装饰器定义字段的排序方式\n    @admin.display(ordering='price')\n    def price_level(self, product):\n        if product.price < 10:\n            return \"cheap\"\n        return 'expensive'\n    \n    # 添加一个计算库存总价值的字段, 该字段同样是计算字段, 但是其数据基于当前数据行\n    # 因此便需要通过重写父类的`get_queryset`方法来修改数据集\n    @admin.display(ordering=F('price')*F('inventory'))\n    def total_price(self, product):\n        return product.total_price\n\n    # admin模块载入orm对象时的查询方法\n    # 与`Model.objects`中获取的数据集操作方式完全一致\n    # 可以通过annotate添加计算字段, 外链字段等一系列操作\n    def get_queryset(self, request: HttpRequest) -> QuerySet[Any]:\n        return super().get_queryset(request) \\\n            .annotate(total_price=F('price') * F('inventory'))\n```\n\n### 外键字段的显示\n\n在Product模型中, 存在一个`collection`外键\n\n```python\nclass Product(models.Model):\n    # ...\n    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)\n```\n\n而`Collection`模型中设置了该模型的`__str__`方法\n\n```python\nclass Collection(models.Model):\n    title = models.CharField(max_length=255)\n    # ...\n    def __str__(self) -> str:\n        return str(self.title)\n```\n\n那么此时,  如果在ProductAdmin中设置显示该外键字段, 那么便会直接显示其`title`值, 对应的SQL如下:\n\n```sql\nSELECT `store_product`.`id`,\n       `store_product`.`title`,\n       `store_product`.`slug`,\n       `store_product`.`description`,\n       `store_product`.`unit_price`,\n       `store_product`.`inventory`,\n       `store_product`.`last_update`,\n       `store_product`.`collection_id`,\n       `store_collection`.`id`,\n       `store_collection`.`title`,\n       `store_collection`.`featured_product_id`\n  FROM `store_product`\n INNER JOIN `store_collection`\n    ON (`store_product`.`collection_id` = `store_collection`.`id`)\n ORDER BY `store_product`.`title` ASC,\n          `store_product`.`id` DESC\n```\n\n此时对于外键查询并不会产生额外的sql查询\n\n但如果查询Collection的其他字段, 即通过orm对象进行关联查询, 此处依然用title举例:\n\n```python\nclass ProductAdmin(admin.ModelAdmin):\n    list_display = ['title', 'unit_price',\n                        'inventory_status', 'collection_title']\n\n    def collection_title(self, product):\n        return product.collection.title\n```\n\n便会因为关联查询而产生额外的sql:\n\n```sql\nSELECT `store_collection`.`id`,\n       `store_collection`.`title`,\n       `store_collection`.`featured_product_id`\n  FROM `store_collection`\n WHERE `store_collection`.`id` = 5\n LIMIT 21\n \n SELECT `store_collection`.`id`,\n       `store_collection`.`title`,\n       `store_collection`.`featured_product_id`\n  FROM `store_collection`\n WHERE `store_collection`.`id` = 4\n LIMIT 21\n \n -- ...\n```\n\n具体产生的sql数量与当前页的数据条目相关\n\n为了避免额外的sql查询, 可以直接使用关联查询来进行处理, 只需要在`list_select_related`成员中设置需要关联查询的表, 便可以在显示字段中添加任意关联表的字段.\n\n```python\nclass ProductAdmin(admin.ModelAdmin):\n    list_display = ['title', 'unit_price',\n                    'inventory_status', 'collection_title']\n    list_editable = ['unit_price']\n    list_per_page = 10\n    \n    # 设置关联查询表\n    list_select_related = ['collection']\n```\n\n对应的SQL:\n\n```sql\nSELECT `store_product`.`id`,\n       `store_product`.`title`,\n       `store_product`.`slug`,\n       `store_product`.`description`,\n       `store_product`.`unit_price`,\n       `store_product`.`inventory`,\n       `store_product`.`last_update`,\n       `store_product`.`collection_id`,\n       `store_collection`.`id`,\n       `store_collection`.`title`,\n       `store_collection`.`featured_product_id`\n  FROM `store_product`\n INNER JOIN `store_collection`\n    ON (`store_product`.`collection_id` = `store_collection`.`id`)\n ORDER BY `store_product`.`title` ASC,\n          `store_product`.`id` DESC\n```\n\n### 添加超链接\n\n在admin中位某一个字段的值添加超链接\n\n```python\nfrom django.utils.html import format_html, urlencode\nfrom django.urls import reverse\n\n@admin.register(models.Collection)\nclass CollectionAdmin(admin.ModelAdmin):\n    list_display = ['title', 'products_count']\n\n    @admin.display(ordering='products_count')\n    def products_count(self, collecton):\n        url = (reverse('admin:store_product_changelist')\n               + '?'\n               + urlencode({\n                   'collection__id': str(collecton.id)\n               }))\n\n        return format_html('<a href=\"{}\">{}</a>',\n                           url,\n                           collecton.products_count)\n\n    def get_queryset(self, request: HttpRequest) -> QuerySet[Any]:\n        return super().get_queryset(request)\\\n            .annotate(products_count=Count('product'))\n```\n\n💡 reverse函数用于动态获取页面的路由地址, 之后再说...\n\n> 在上面的代码里, `get_queryset`方法中通过`Count`统计了`product`字段\n>\n> ```python\n>     def get_queryset(self, request: HttpRequest) -> QuerySet[Any]:\n>         return super().get_queryset(request)\\\n>             .annotate(products_count=Count('product'))\n> ```\n>\n> 而`Collection`模型的定义如下:\n>\n> ```python\n> class Collection(models.Model):\n>     title = models.CharField(max_length=255)\n>     featured_product = models.ForeignKey(\n>         'Product', on_delete=models.SET_NULL, null=True, related_name='+')\n> \n>     def __str__(self) -> str:\n>         return str(self.title)\n> \n>     class Meta:\n>         ordering = ['title']\n> ```\n>\n> 显然, 在Collection中并没有product字段, 而代码运行没有问题.\n>\n> 这是由于django在定义数据模型时, 会位外键字段反向创建一个关系字段, 这一字段应该是创建在python对象中, 所以数据库中并不存在, 来看Product类的定义:\n>\n> ```python\n> class Product(models.Model):\n>     title = models.CharField(max_length=255)\n>     slug = models.SlugField()\n>     description = models.TextField()\n>     unit_price = models.DecimalField(max_digits=6, decimal_places=2)\n>     inventory = models.IntegerField()\n>     last_update = models.DateTimeField(auto_now=True)\n>     ## 这里\n>     collection = models.ForeignKey(Collection, on_delete=models.PROTECT)\n>     promotions = models.ManyToManyField(Promotion)\n> \n>     def __str__(self) -> str:\n>         return str(self.title)\n> ```\n>\n> 正是因为`collection`字段是到`Collection`模型的外键字段, 因此在Collection中也就自动添加了`product`字段,\n>\n> 于是也就能够直接通过django orm直接在`Collection`对象中使用`Count(\"product\")`操作了\n>\n> 再看`Collection`对象中的代码\n>\n> ```python\n>   featured_product = models.ForeignKey(\n>       'Product', on_delete=models.SET_NULL, null=True, related_name='+')\n> ```\n>\n> 这里用了一个关键字参数, `related_name='+'`\n>\n> 其意思便是在Product类中不创建反向字段, 事实上, 在本例中如果没有这个关键字参数会触发编译器错误\n>\n> 因为Product在Collection中创创建了product关系字段,\n>\n> 同时Collection也在Product中创建了collection关系字段\n>\n> 而Product自己已经有了一个同名的字段, 也就出现了命名冲突, 只要改掉其中一个名字即可.\n>\n> 同样的, 如果修改`Product`类的代码为:\n>\n> ```python\n> collection = models.ForeignKey(\n>         Collection, on_delete=models.PROTECT, related_name='+')\n> ```\n>\n> 也就是不在Collection对象中创建关系字段, 在访问页面时就会直接出错\n>\n> ```zsh\n> django.core.exceptions.FieldError: Cannot resolve keyword 'product' into field. Choices are: featured_product, featured_product_id, id, title\n> ```\n\n### 添加搜索\n\n在django admin中添加基础的搜索条功能\n\n```python\nsearch_fields = ['first_name__istartswith', 'last_name__istartswith']\n```\n\n搜索条会在指定的字段中, 基于指定的lookup方式进行数据搜索\n\n### 添加过滤器\n\n基于当前表的某个字段进行过滤, 可以直接调用django提供的默认过滤器\n\n```python\nlist_filter = ['collection', 'last_update']\n```\n\n也可以使用自定义过滤器, 过滤器本质类似于html中的单选框, 有一个id和一个value, id用于唯一标识, value用于UI显示\n\n```python\nclass InventoryFilter(admin.SimpleListFilter):\n    # 显示在过滤器列表中的名称\n    title = 'Inventory'\n    # 通过URL传递的参数名称\n    parameter_name = 'inven'\n    # 需要返回一个tupule list, 每一个tuple是过滤器的一个显示项, tuple的第一个值会作为过滤器的value, 用于判断过滤器选中状态, 第二个值用于UI显示\n    def lookups(self, request: Any, model_admin: Any) -> list[tuple[Any, str]]:\n        return [\n            ('<10', 'Low')\n        ]\n\n    def queryset(self, request: Any, queryset: QuerySet[Any]) -> QuerySet[Any] | None:\n        # 如果当前过滤器选项是 `<10`\n        if self.value() == '<10':\n            # 对当前页面的queryset进行过滤, 与ORM语法完全一样\n            return queryset.filter(inventory__lt=10)\n        return None\n```\n\n并在过滤器列表中添加自定义的过滤器即可\n\n```python\nlist_filter = ['collection', 'last_update', InventoryFilter]\n```\n\n### 自定义用户操作\n\n在django admin中添加对数据的批量操作方式\n\n```python\nfrom django.contrib import admin, messages\n\nfrom . import models\n\n@admin.register(models.Product)\nclass ProductAdmin(admin.ModelAdmin):\n    # ...code...\n    actions = ['clear_inventory']\n\n    @admin.action(description='Clear inventory')\n    def clear_inventory(self, request, queryset):\n        updated__count = queryset.update(inventory=0)\n        self.message_user(\n            request,\n            f'{updated__count} products were successfully updated.',\n            messages.SUCCESS # 可选\n        )\n```\n\n### 自定义操作表单\n\n对于数据的创建或修改的详情页面表单:\n\n![image-20231109181130563](/assets/img/image-20231109181130563.png)\n\n可以在对应的模型Admin类中对其进行定义, 如:\n\n* `fields = ['title', 'slug']`: 仅显示列表中的字段\n\n* `exclude = ['promotions']`: 不显示的字段\n\n* `readonly_fields = ['slug']`: 只读字段\n\n* `prepopulated_field = {'slug': ['title']}`:  自动填充字段, 代表slug在空白状态下会根据title的内容进行自动填充, 如果手动更改过则不会变更,  实测没什么效果, 感觉意义不大\n\n* `autocomplete_fields = ['collection']`: 自动完成字段, 下拉列表的变种形式, 对于数量太多的下拉列表, 常规形式会严重影响用户操作体验, 自动完成字段则是在下拉列表上方增加一个文本输入框, 实现类似编码自动补全的效果.\n\n  > 需要在`Collection`模型中设置`search_filds`成员以配合使用, 否则会出现编译错误\n  >\n  > ```bash\n  > django.core.management.base.SystemCheckError: SystemCheckError: System check identified some issues:\n  > \n  > ERRORS:\n  > <class 'store.admin.ProductAdmin'>: (admin.E040) CollectionAdmin must define \"search_fields\", because it's referenced by ProductAdmin.autocomplete_fields.\n  > ```\n\n### 内联表\n\n在多对多的关系中通常会使用一些链接表, 比如一个`Order`可以包含多个`Product`,一个`Product`可以出现在多个`Order`中, 所以每一个订单记录都需要知道它是哪一个订单的哪一个产品的信息\n\n这里定义了一个`OrderItem`表\n\n```python\nclass OrderItem(models.Model):\n    order = models.ForeignKey(Order, on_delete=models.PROTECT)\n    product = models.ForeignKey(Product, on_delete=models.PROTECT)\n    quantity = models.PositiveSmallIntegerField()\n    unit_price = models.DecimalField(max_digits=6, decimal_places=2)\n```\n\n但是在django admin中去单独设计该表的admin页面没有任何实际意义, 因为他必须依托于`Order`来进行呈现, 所以通常会以内联表的形式进行操作\n\n```python\nclass OrderItemInline(admin.TabularInline):\n    model = models.OrderItem\n    autocomplete_fields = ['product']\n    # 内联表额外的数据行\n    extra = 0\n    # 最小数据行\n    min_num = 1\n    # 实际数据行 = 最小 + 额外\n    \n@admin.register(models.Order)\nclass OrderAdmin(admin.ModelAdmin):\n    list_display = ['id', 'placed_at', 'customer']\n    ordering = ['id']\n    list_per_page = LIST_PER_PAGE\n    inlines = [OrderItemInline]\n    autocomplete_fields = ['customer']\n```\n\n内联样式有两种:\n\n* admin.StackedInline: 以数据表单的形式呈现\n* admin.TabularInline: 以数据表的形式呈现, 每条数据呈一行, 比较常用\n","source":"_posts/django/5-use-django-admin.md","raw":"---\ntitle: 5. Django-admin后台管理\ndate: 2023-11-6 02:05:37 +08000\ncategories: [笔记, Django]\ntags: [python, django, backend]\n---\n\n有django提供的一个数据管理后台, 功能强大, 熟练使用可以节省大量的编码时间\n[Django Admin完整官方文档](https://docs.djangoproject.com/en/dev/ref/contrib/admin/)\n\n## 基本使用\n\n可以通过`admin/`进行访问, 如\n\n```url\nhttp://127.0.0.1:8000/admin\n```\n\n在使用admin之前, 需要创建admin用户, 在终端执行:\n\n```zsh\npython manage.py createsuperuser\n```\n\n输入用户名密码即可.\n\n忘记密码时可以通过终端命令直接修改\n\n```zsh\npython manage.py changepassword [username]\n```\n\n### 修改后台页面标题\n\n```python\nfrom django.contrib import admin\n\n# 可以直接在项目的urls.py中添加, 但不推荐\nadmin.site.site_header = 'My site to learn django'\nadmin.site.index_title = \"Site Apps\"\n```\n\n![image-20231108212229095](/assets/img/image-20231108212229095.png){: .shadow}\n\n## 注册模块\n\n要通过admin后台管理某个app的数据, 需要先对其进行注册, 如`playground`模块的`Product`对象\n\n```python\n# `playground/admin.py`\nfrom django.contrib import admin\nfrom . import models\n\nadmin.site.register(models.Product)\n```\n\n## 修改显示字段和表排序方式\n\n```python\nclass Product(models.Model):\n    title = models.CharField(max_length=255)\n    # other fields ...\n\n    def __str__(self) -> str:\n        return str(self.title)\n\n    class Meta:\n        ordering = ['title']\n```\n\n## 自定义管理后台\n\n通过对ORM对象的设置完成自定义的后台管理\n\n```python\n# `playground/admin.py`\nfrom django.contrib import admin\nfrom . import models\n\n# 如果不使用装饰器可以使用代码进行注册\n# admin.site.register(models.Product, ProductAdmin)\n# 只能注册一次, 即装饰器和代码注册只能二选一\n@admin.register(models.Product)\nclass ProductAdmin(admin.ModelAdmin):\n    list_display = [\"name\", 'price', 'description']\n    list_editable = ['price']\n    list_per_page = 20\n    \n    # ---添加计算字段---\n    # 装饰器定义字段的排序方式\n    @admin.display(ordering='price')\n    def price_level(self, product):\n        if product.price < 10:\n            return \"cheap\"\n        return 'expensive'\n    \n    # 添加一个计算库存总价值的字段, 该字段同样是计算字段, 但是其数据基于当前数据行\n    # 因此便需要通过重写父类的`get_queryset`方法来修改数据集\n    @admin.display(ordering=F('price')*F('inventory'))\n    def total_price(self, product):\n        return product.total_price\n\n    # admin模块载入orm对象时的查询方法\n    # 与`Model.objects`中获取的数据集操作方式完全一致\n    # 可以通过annotate添加计算字段, 外链字段等一系列操作\n    def get_queryset(self, request: HttpRequest) -> QuerySet[Any]:\n        return super().get_queryset(request) \\\n            .annotate(total_price=F('price') * F('inventory'))\n```\n\n### 外键字段的显示\n\n在Product模型中, 存在一个`collection`外键\n\n```python\nclass Product(models.Model):\n    # ...\n    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)\n```\n\n而`Collection`模型中设置了该模型的`__str__`方法\n\n```python\nclass Collection(models.Model):\n    title = models.CharField(max_length=255)\n    # ...\n    def __str__(self) -> str:\n        return str(self.title)\n```\n\n那么此时,  如果在ProductAdmin中设置显示该外键字段, 那么便会直接显示其`title`值, 对应的SQL如下:\n\n```sql\nSELECT `store_product`.`id`,\n       `store_product`.`title`,\n       `store_product`.`slug`,\n       `store_product`.`description`,\n       `store_product`.`unit_price`,\n       `store_product`.`inventory`,\n       `store_product`.`last_update`,\n       `store_product`.`collection_id`,\n       `store_collection`.`id`,\n       `store_collection`.`title`,\n       `store_collection`.`featured_product_id`\n  FROM `store_product`\n INNER JOIN `store_collection`\n    ON (`store_product`.`collection_id` = `store_collection`.`id`)\n ORDER BY `store_product`.`title` ASC,\n          `store_product`.`id` DESC\n```\n\n此时对于外键查询并不会产生额外的sql查询\n\n但如果查询Collection的其他字段, 即通过orm对象进行关联查询, 此处依然用title举例:\n\n```python\nclass ProductAdmin(admin.ModelAdmin):\n    list_display = ['title', 'unit_price',\n                        'inventory_status', 'collection_title']\n\n    def collection_title(self, product):\n        return product.collection.title\n```\n\n便会因为关联查询而产生额外的sql:\n\n```sql\nSELECT `store_collection`.`id`,\n       `store_collection`.`title`,\n       `store_collection`.`featured_product_id`\n  FROM `store_collection`\n WHERE `store_collection`.`id` = 5\n LIMIT 21\n \n SELECT `store_collection`.`id`,\n       `store_collection`.`title`,\n       `store_collection`.`featured_product_id`\n  FROM `store_collection`\n WHERE `store_collection`.`id` = 4\n LIMIT 21\n \n -- ...\n```\n\n具体产生的sql数量与当前页的数据条目相关\n\n为了避免额外的sql查询, 可以直接使用关联查询来进行处理, 只需要在`list_select_related`成员中设置需要关联查询的表, 便可以在显示字段中添加任意关联表的字段.\n\n```python\nclass ProductAdmin(admin.ModelAdmin):\n    list_display = ['title', 'unit_price',\n                    'inventory_status', 'collection_title']\n    list_editable = ['unit_price']\n    list_per_page = 10\n    \n    # 设置关联查询表\n    list_select_related = ['collection']\n```\n\n对应的SQL:\n\n```sql\nSELECT `store_product`.`id`,\n       `store_product`.`title`,\n       `store_product`.`slug`,\n       `store_product`.`description`,\n       `store_product`.`unit_price`,\n       `store_product`.`inventory`,\n       `store_product`.`last_update`,\n       `store_product`.`collection_id`,\n       `store_collection`.`id`,\n       `store_collection`.`title`,\n       `store_collection`.`featured_product_id`\n  FROM `store_product`\n INNER JOIN `store_collection`\n    ON (`store_product`.`collection_id` = `store_collection`.`id`)\n ORDER BY `store_product`.`title` ASC,\n          `store_product`.`id` DESC\n```\n\n### 添加超链接\n\n在admin中位某一个字段的值添加超链接\n\n```python\nfrom django.utils.html import format_html, urlencode\nfrom django.urls import reverse\n\n@admin.register(models.Collection)\nclass CollectionAdmin(admin.ModelAdmin):\n    list_display = ['title', 'products_count']\n\n    @admin.display(ordering='products_count')\n    def products_count(self, collecton):\n        url = (reverse('admin:store_product_changelist')\n               + '?'\n               + urlencode({\n                   'collection__id': str(collecton.id)\n               }))\n\n        return format_html('<a href=\"{}\">{}</a>',\n                           url,\n                           collecton.products_count)\n\n    def get_queryset(self, request: HttpRequest) -> QuerySet[Any]:\n        return super().get_queryset(request)\\\n            .annotate(products_count=Count('product'))\n```\n\n💡 reverse函数用于动态获取页面的路由地址, 之后再说...\n\n> 在上面的代码里, `get_queryset`方法中通过`Count`统计了`product`字段\n>\n> ```python\n>     def get_queryset(self, request: HttpRequest) -> QuerySet[Any]:\n>         return super().get_queryset(request)\\\n>             .annotate(products_count=Count('product'))\n> ```\n>\n> 而`Collection`模型的定义如下:\n>\n> ```python\n> class Collection(models.Model):\n>     title = models.CharField(max_length=255)\n>     featured_product = models.ForeignKey(\n>         'Product', on_delete=models.SET_NULL, null=True, related_name='+')\n> \n>     def __str__(self) -> str:\n>         return str(self.title)\n> \n>     class Meta:\n>         ordering = ['title']\n> ```\n>\n> 显然, 在Collection中并没有product字段, 而代码运行没有问题.\n>\n> 这是由于django在定义数据模型时, 会位外键字段反向创建一个关系字段, 这一字段应该是创建在python对象中, 所以数据库中并不存在, 来看Product类的定义:\n>\n> ```python\n> class Product(models.Model):\n>     title = models.CharField(max_length=255)\n>     slug = models.SlugField()\n>     description = models.TextField()\n>     unit_price = models.DecimalField(max_digits=6, decimal_places=2)\n>     inventory = models.IntegerField()\n>     last_update = models.DateTimeField(auto_now=True)\n>     ## 这里\n>     collection = models.ForeignKey(Collection, on_delete=models.PROTECT)\n>     promotions = models.ManyToManyField(Promotion)\n> \n>     def __str__(self) -> str:\n>         return str(self.title)\n> ```\n>\n> 正是因为`collection`字段是到`Collection`模型的外键字段, 因此在Collection中也就自动添加了`product`字段,\n>\n> 于是也就能够直接通过django orm直接在`Collection`对象中使用`Count(\"product\")`操作了\n>\n> 再看`Collection`对象中的代码\n>\n> ```python\n>   featured_product = models.ForeignKey(\n>       'Product', on_delete=models.SET_NULL, null=True, related_name='+')\n> ```\n>\n> 这里用了一个关键字参数, `related_name='+'`\n>\n> 其意思便是在Product类中不创建反向字段, 事实上, 在本例中如果没有这个关键字参数会触发编译器错误\n>\n> 因为Product在Collection中创创建了product关系字段,\n>\n> 同时Collection也在Product中创建了collection关系字段\n>\n> 而Product自己已经有了一个同名的字段, 也就出现了命名冲突, 只要改掉其中一个名字即可.\n>\n> 同样的, 如果修改`Product`类的代码为:\n>\n> ```python\n> collection = models.ForeignKey(\n>         Collection, on_delete=models.PROTECT, related_name='+')\n> ```\n>\n> 也就是不在Collection对象中创建关系字段, 在访问页面时就会直接出错\n>\n> ```zsh\n> django.core.exceptions.FieldError: Cannot resolve keyword 'product' into field. Choices are: featured_product, featured_product_id, id, title\n> ```\n\n### 添加搜索\n\n在django admin中添加基础的搜索条功能\n\n```python\nsearch_fields = ['first_name__istartswith', 'last_name__istartswith']\n```\n\n搜索条会在指定的字段中, 基于指定的lookup方式进行数据搜索\n\n### 添加过滤器\n\n基于当前表的某个字段进行过滤, 可以直接调用django提供的默认过滤器\n\n```python\nlist_filter = ['collection', 'last_update']\n```\n\n也可以使用自定义过滤器, 过滤器本质类似于html中的单选框, 有一个id和一个value, id用于唯一标识, value用于UI显示\n\n```python\nclass InventoryFilter(admin.SimpleListFilter):\n    # 显示在过滤器列表中的名称\n    title = 'Inventory'\n    # 通过URL传递的参数名称\n    parameter_name = 'inven'\n    # 需要返回一个tupule list, 每一个tuple是过滤器的一个显示项, tuple的第一个值会作为过滤器的value, 用于判断过滤器选中状态, 第二个值用于UI显示\n    def lookups(self, request: Any, model_admin: Any) -> list[tuple[Any, str]]:\n        return [\n            ('<10', 'Low')\n        ]\n\n    def queryset(self, request: Any, queryset: QuerySet[Any]) -> QuerySet[Any] | None:\n        # 如果当前过滤器选项是 `<10`\n        if self.value() == '<10':\n            # 对当前页面的queryset进行过滤, 与ORM语法完全一样\n            return queryset.filter(inventory__lt=10)\n        return None\n```\n\n并在过滤器列表中添加自定义的过滤器即可\n\n```python\nlist_filter = ['collection', 'last_update', InventoryFilter]\n```\n\n### 自定义用户操作\n\n在django admin中添加对数据的批量操作方式\n\n```python\nfrom django.contrib import admin, messages\n\nfrom . import models\n\n@admin.register(models.Product)\nclass ProductAdmin(admin.ModelAdmin):\n    # ...code...\n    actions = ['clear_inventory']\n\n    @admin.action(description='Clear inventory')\n    def clear_inventory(self, request, queryset):\n        updated__count = queryset.update(inventory=0)\n        self.message_user(\n            request,\n            f'{updated__count} products were successfully updated.',\n            messages.SUCCESS # 可选\n        )\n```\n\n### 自定义操作表单\n\n对于数据的创建或修改的详情页面表单:\n\n![image-20231109181130563](/assets/img/image-20231109181130563.png)\n\n可以在对应的模型Admin类中对其进行定义, 如:\n\n* `fields = ['title', 'slug']`: 仅显示列表中的字段\n\n* `exclude = ['promotions']`: 不显示的字段\n\n* `readonly_fields = ['slug']`: 只读字段\n\n* `prepopulated_field = {'slug': ['title']}`:  自动填充字段, 代表slug在空白状态下会根据title的内容进行自动填充, 如果手动更改过则不会变更,  实测没什么效果, 感觉意义不大\n\n* `autocomplete_fields = ['collection']`: 自动完成字段, 下拉列表的变种形式, 对于数量太多的下拉列表, 常规形式会严重影响用户操作体验, 自动完成字段则是在下拉列表上方增加一个文本输入框, 实现类似编码自动补全的效果.\n\n  > 需要在`Collection`模型中设置`search_filds`成员以配合使用, 否则会出现编译错误\n  >\n  > ```bash\n  > django.core.management.base.SystemCheckError: SystemCheckError: System check identified some issues:\n  > \n  > ERRORS:\n  > <class 'store.admin.ProductAdmin'>: (admin.E040) CollectionAdmin must define \"search_fields\", because it's referenced by ProductAdmin.autocomplete_fields.\n  > ```\n\n### 内联表\n\n在多对多的关系中通常会使用一些链接表, 比如一个`Order`可以包含多个`Product`,一个`Product`可以出现在多个`Order`中, 所以每一个订单记录都需要知道它是哪一个订单的哪一个产品的信息\n\n这里定义了一个`OrderItem`表\n\n```python\nclass OrderItem(models.Model):\n    order = models.ForeignKey(Order, on_delete=models.PROTECT)\n    product = models.ForeignKey(Product, on_delete=models.PROTECT)\n    quantity = models.PositiveSmallIntegerField()\n    unit_price = models.DecimalField(max_digits=6, decimal_places=2)\n```\n\n但是在django admin中去单独设计该表的admin页面没有任何实际意义, 因为他必须依托于`Order`来进行呈现, 所以通常会以内联表的形式进行操作\n\n```python\nclass OrderItemInline(admin.TabularInline):\n    model = models.OrderItem\n    autocomplete_fields = ['product']\n    # 内联表额外的数据行\n    extra = 0\n    # 最小数据行\n    min_num = 1\n    # 实际数据行 = 最小 + 额外\n    \n@admin.register(models.Order)\nclass OrderAdmin(admin.ModelAdmin):\n    list_display = ['id', 'placed_at', 'customer']\n    ordering = ['id']\n    list_per_page = LIST_PER_PAGE\n    inlines = [OrderItemInline]\n    autocomplete_fields = ['customer']\n```\n\n内联样式有两种:\n\n* admin.StackedInline: 以数据表单的形式呈现\n* admin.TabularInline: 以数据表的形式呈现, 每条数据呈一行, 比较常用\n","slug":"django-5-use-django-admin","published":1,"updated":"2023-12-13T08:41:08.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v00012i3er6db59mam","content":"<p>有django提供的一个数据管理后台, 功能强大, 熟练使用可以节省大量的编码时间<br><a href=\"https://docs.djangoproject.com/en/dev/ref/contrib/admin/\">Django Admin完整官方文档</a></p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>可以通过<code>admin/</code>进行访问, 如</p>\n<pre><code class=\"url\">http://127.0.0.1:8000/admin\n</code></pre>\n<p>在使用admin之前, 需要创建admin用户, 在终端执行:</p>\n<pre><code class=\"zsh\">python manage.py createsuperuser\n</code></pre>\n<p>输入用户名密码即可.</p>\n<p>忘记密码时可以通过终端命令直接修改</p>\n<pre><code class=\"zsh\">python manage.py changepassword [username]\n</code></pre>\n<h3 id=\"修改后台页面标题\"><a href=\"#修改后台页面标题\" class=\"headerlink\" title=\"修改后台页面标题\"></a>修改后台页面标题</h3><pre><code class=\"python\">from django.contrib import admin\n\n# 可以直接在项目的urls.py中添加, 但不推荐\nadmin.site.site_header = &#39;My site to learn django&#39;\nadmin.site.index_title = &quot;Site Apps&quot;\n</code></pre>\n<p><img src=\"/assets/img/image-20231108212229095.png\" alt=\"image-20231108212229095\">{: .shadow}</p>\n<h2 id=\"注册模块\"><a href=\"#注册模块\" class=\"headerlink\" title=\"注册模块\"></a>注册模块</h2><p>要通过admin后台管理某个app的数据, 需要先对其进行注册, 如<code>playground</code>模块的<code>Product</code>对象</p>\n<pre><code class=\"python\"># `playground/admin.py`\nfrom django.contrib import admin\nfrom . import models\n\nadmin.site.register(models.Product)\n</code></pre>\n<h2 id=\"修改显示字段和表排序方式\"><a href=\"#修改显示字段和表排序方式\" class=\"headerlink\" title=\"修改显示字段和表排序方式\"></a>修改显示字段和表排序方式</h2><pre><code class=\"python\">class Product(models.Model):\n    title = models.CharField(max_length=255)\n    # other fields ...\n\n    def __str__(self) -&gt; str:\n        return str(self.title)\n\n    class Meta:\n        ordering = [&#39;title&#39;]\n</code></pre>\n<h2 id=\"自定义管理后台\"><a href=\"#自定义管理后台\" class=\"headerlink\" title=\"自定义管理后台\"></a>自定义管理后台</h2><p>通过对ORM对象的设置完成自定义的后台管理</p>\n<pre><code class=\"python\"># `playground/admin.py`\nfrom django.contrib import admin\nfrom . import models\n\n# 如果不使用装饰器可以使用代码进行注册\n# admin.site.register(models.Product, ProductAdmin)\n# 只能注册一次, 即装饰器和代码注册只能二选一\n@admin.register(models.Product)\nclass ProductAdmin(admin.ModelAdmin):\n    list_display = [&quot;name&quot;, &#39;price&#39;, &#39;description&#39;]\n    list_editable = [&#39;price&#39;]\n    list_per_page = 20\n    \n    # ---添加计算字段---\n    # 装饰器定义字段的排序方式\n    @admin.display(ordering=&#39;price&#39;)\n    def price_level(self, product):\n        if product.price &lt; 10:\n            return &quot;cheap&quot;\n        return &#39;expensive&#39;\n    \n    # 添加一个计算库存总价值的字段, 该字段同样是计算字段, 但是其数据基于当前数据行\n    # 因此便需要通过重写父类的`get_queryset`方法来修改数据集\n    @admin.display(ordering=F(&#39;price&#39;)*F(&#39;inventory&#39;))\n    def total_price(self, product):\n        return product.total_price\n\n    # admin模块载入orm对象时的查询方法\n    # 与`Model.objects`中获取的数据集操作方式完全一致\n    # 可以通过annotate添加计算字段, 外链字段等一系列操作\n    def get_queryset(self, request: HttpRequest) -&gt; QuerySet[Any]:\n        return super().get_queryset(request) \\\n            .annotate(total_price=F(&#39;price&#39;) * F(&#39;inventory&#39;))\n</code></pre>\n<h3 id=\"外键字段的显示\"><a href=\"#外键字段的显示\" class=\"headerlink\" title=\"外键字段的显示\"></a>外键字段的显示</h3><p>在Product模型中, 存在一个<code>collection</code>外键</p>\n<pre><code class=\"python\">class Product(models.Model):\n    # ...\n    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)\n</code></pre>\n<p>而<code>Collection</code>模型中设置了该模型的<code>__str__</code>方法</p>\n<pre><code class=\"python\">class Collection(models.Model):\n    title = models.CharField(max_length=255)\n    # ...\n    def __str__(self) -&gt; str:\n        return str(self.title)\n</code></pre>\n<p>那么此时,  如果在ProductAdmin中设置显示该外键字段, 那么便会直接显示其<code>title</code>值, 对应的SQL如下:</p>\n<pre><code class=\"sql\">SELECT `store_product`.`id`,\n       `store_product`.`title`,\n       `store_product`.`slug`,\n       `store_product`.`description`,\n       `store_product`.`unit_price`,\n       `store_product`.`inventory`,\n       `store_product`.`last_update`,\n       `store_product`.`collection_id`,\n       `store_collection`.`id`,\n       `store_collection`.`title`,\n       `store_collection`.`featured_product_id`\n  FROM `store_product`\n INNER JOIN `store_collection`\n    ON (`store_product`.`collection_id` = `store_collection`.`id`)\n ORDER BY `store_product`.`title` ASC,\n          `store_product`.`id` DESC\n</code></pre>\n<p>此时对于外键查询并不会产生额外的sql查询</p>\n<p>但如果查询Collection的其他字段, 即通过orm对象进行关联查询, 此处依然用title举例:</p>\n<pre><code class=\"python\">class ProductAdmin(admin.ModelAdmin):\n    list_display = [&#39;title&#39;, &#39;unit_price&#39;,\n                        &#39;inventory_status&#39;, &#39;collection_title&#39;]\n\n    def collection_title(self, product):\n        return product.collection.title\n</code></pre>\n<p>便会因为关联查询而产生额外的sql:</p>\n<pre><code class=\"sql\">SELECT `store_collection`.`id`,\n       `store_collection`.`title`,\n       `store_collection`.`featured_product_id`\n  FROM `store_collection`\n WHERE `store_collection`.`id` = 5\n LIMIT 21\n \n SELECT `store_collection`.`id`,\n       `store_collection`.`title`,\n       `store_collection`.`featured_product_id`\n  FROM `store_collection`\n WHERE `store_collection`.`id` = 4\n LIMIT 21\n \n -- ...\n</code></pre>\n<p>具体产生的sql数量与当前页的数据条目相关</p>\n<p>为了避免额外的sql查询, 可以直接使用关联查询来进行处理, 只需要在<code>list_select_related</code>成员中设置需要关联查询的表, 便可以在显示字段中添加任意关联表的字段.</p>\n<pre><code class=\"python\">class ProductAdmin(admin.ModelAdmin):\n    list_display = [&#39;title&#39;, &#39;unit_price&#39;,\n                    &#39;inventory_status&#39;, &#39;collection_title&#39;]\n    list_editable = [&#39;unit_price&#39;]\n    list_per_page = 10\n    \n    # 设置关联查询表\n    list_select_related = [&#39;collection&#39;]\n</code></pre>\n<p>对应的SQL:</p>\n<pre><code class=\"sql\">SELECT `store_product`.`id`,\n       `store_product`.`title`,\n       `store_product`.`slug`,\n       `store_product`.`description`,\n       `store_product`.`unit_price`,\n       `store_product`.`inventory`,\n       `store_product`.`last_update`,\n       `store_product`.`collection_id`,\n       `store_collection`.`id`,\n       `store_collection`.`title`,\n       `store_collection`.`featured_product_id`\n  FROM `store_product`\n INNER JOIN `store_collection`\n    ON (`store_product`.`collection_id` = `store_collection`.`id`)\n ORDER BY `store_product`.`title` ASC,\n          `store_product`.`id` DESC\n</code></pre>\n<h3 id=\"添加超链接\"><a href=\"#添加超链接\" class=\"headerlink\" title=\"添加超链接\"></a>添加超链接</h3><p>在admin中位某一个字段的值添加超链接</p>\n<pre><code class=\"python\">from django.utils.html import format_html, urlencode\nfrom django.urls import reverse\n\n@admin.register(models.Collection)\nclass CollectionAdmin(admin.ModelAdmin):\n    list_display = [&#39;title&#39;, &#39;products_count&#39;]\n\n    @admin.display(ordering=&#39;products_count&#39;)\n    def products_count(self, collecton):\n        url = (reverse(&#39;admin:store_product_changelist&#39;)\n               + &#39;?&#39;\n               + urlencode(&#123;\n                   &#39;collection__id&#39;: str(collecton.id)\n               &#125;))\n\n        return format_html(&#39;&lt;a href=&quot;&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&#39;,\n                           url,\n                           collecton.products_count)\n\n    def get_queryset(self, request: HttpRequest) -&gt; QuerySet[Any]:\n        return super().get_queryset(request)\\\n            .annotate(products_count=Count(&#39;product&#39;))\n</code></pre>\n<p>💡 reverse函数用于动态获取页面的路由地址, 之后再说…</p>\n<blockquote>\n<p>在上面的代码里, <code>get_queryset</code>方法中通过<code>Count</code>统计了<code>product</code>字段</p>\n<pre><code class=\"python\">    def get_queryset(self, request: HttpRequest) -&gt; QuerySet[Any]:\n        return super().get_queryset(request)\\\n            .annotate(products_count=Count(&#39;product&#39;))\n</code></pre>\n<p>而<code>Collection</code>模型的定义如下:</p>\n<pre><code class=\"python\">class Collection(models.Model):\n    title = models.CharField(max_length=255)\n    featured_product = models.ForeignKey(\n        &#39;Product&#39;, on_delete=models.SET_NULL, null=True, related_name=&#39;+&#39;)\n\n    def __str__(self) -&gt; str:\n        return str(self.title)\n\n    class Meta:\n        ordering = [&#39;title&#39;]\n</code></pre>\n<p>显然, 在Collection中并没有product字段, 而代码运行没有问题.</p>\n<p>这是由于django在定义数据模型时, 会位外键字段反向创建一个关系字段, 这一字段应该是创建在python对象中, 所以数据库中并不存在, 来看Product类的定义:</p>\n<pre><code class=\"python\">class Product(models.Model):\n    title = models.CharField(max_length=255)\n    slug = models.SlugField()\n    description = models.TextField()\n    unit_price = models.DecimalField(max_digits=6, decimal_places=2)\n    inventory = models.IntegerField()\n    last_update = models.DateTimeField(auto_now=True)\n    ## 这里\n    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)\n    promotions = models.ManyToManyField(Promotion)\n\n    def __str__(self) -&gt; str:\n        return str(self.title)\n</code></pre>\n<p>正是因为<code>collection</code>字段是到<code>Collection</code>模型的外键字段, 因此在Collection中也就自动添加了<code>product</code>字段,</p>\n<p>于是也就能够直接通过django orm直接在<code>Collection</code>对象中使用<code>Count(&quot;product&quot;)</code>操作了</p>\n<p>再看<code>Collection</code>对象中的代码</p>\n<pre><code class=\"python\">  featured_product = models.ForeignKey(\n      &#39;Product&#39;, on_delete=models.SET_NULL, null=True, related_name=&#39;+&#39;)\n</code></pre>\n<p>这里用了一个关键字参数, <code>related_name=&#39;+&#39;</code></p>\n<p>其意思便是在Product类中不创建反向字段, 事实上, 在本例中如果没有这个关键字参数会触发编译器错误</p>\n<p>因为Product在Collection中创创建了product关系字段,</p>\n<p>同时Collection也在Product中创建了collection关系字段</p>\n<p>而Product自己已经有了一个同名的字段, 也就出现了命名冲突, 只要改掉其中一个名字即可.</p>\n<p>同样的, 如果修改<code>Product</code>类的代码为:</p>\n<pre><code class=\"python\">collection = models.ForeignKey(\n        Collection, on_delete=models.PROTECT, related_name=&#39;+&#39;)\n</code></pre>\n<p>也就是不在Collection对象中创建关系字段, 在访问页面时就会直接出错</p>\n<pre><code class=\"zsh\">django.core.exceptions.FieldError: Cannot resolve keyword &#39;product&#39; into field. Choices are: featured_product, featured_product_id, id, title\n</code></pre>\n</blockquote>\n<h3 id=\"添加搜索\"><a href=\"#添加搜索\" class=\"headerlink\" title=\"添加搜索\"></a>添加搜索</h3><p>在django admin中添加基础的搜索条功能</p>\n<pre><code class=\"python\">search_fields = [&#39;first_name__istartswith&#39;, &#39;last_name__istartswith&#39;]\n</code></pre>\n<p>搜索条会在指定的字段中, 基于指定的lookup方式进行数据搜索</p>\n<h3 id=\"添加过滤器\"><a href=\"#添加过滤器\" class=\"headerlink\" title=\"添加过滤器\"></a>添加过滤器</h3><p>基于当前表的某个字段进行过滤, 可以直接调用django提供的默认过滤器</p>\n<pre><code class=\"python\">list_filter = [&#39;collection&#39;, &#39;last_update&#39;]\n</code></pre>\n<p>也可以使用自定义过滤器, 过滤器本质类似于html中的单选框, 有一个id和一个value, id用于唯一标识, value用于UI显示</p>\n<pre><code class=\"python\">class InventoryFilter(admin.SimpleListFilter):\n    # 显示在过滤器列表中的名称\n    title = &#39;Inventory&#39;\n    # 通过URL传递的参数名称\n    parameter_name = &#39;inven&#39;\n    # 需要返回一个tupule list, 每一个tuple是过滤器的一个显示项, tuple的第一个值会作为过滤器的value, 用于判断过滤器选中状态, 第二个值用于UI显示\n    def lookups(self, request: Any, model_admin: Any) -&gt; list[tuple[Any, str]]:\n        return [\n            (&#39;&lt;10&#39;, &#39;Low&#39;)\n        ]\n\n    def queryset(self, request: Any, queryset: QuerySet[Any]) -&gt; QuerySet[Any] | None:\n        # 如果当前过滤器选项是 `&lt;10`\n        if self.value() == &#39;&lt;10&#39;:\n            # 对当前页面的queryset进行过滤, 与ORM语法完全一样\n            return queryset.filter(inventory__lt=10)\n        return None\n</code></pre>\n<p>并在过滤器列表中添加自定义的过滤器即可</p>\n<pre><code class=\"python\">list_filter = [&#39;collection&#39;, &#39;last_update&#39;, InventoryFilter]\n</code></pre>\n<h3 id=\"自定义用户操作\"><a href=\"#自定义用户操作\" class=\"headerlink\" title=\"自定义用户操作\"></a>自定义用户操作</h3><p>在django admin中添加对数据的批量操作方式</p>\n<pre><code class=\"python\">from django.contrib import admin, messages\n\nfrom . import models\n\n@admin.register(models.Product)\nclass ProductAdmin(admin.ModelAdmin):\n    # ...code...\n    actions = [&#39;clear_inventory&#39;]\n\n    @admin.action(description=&#39;Clear inventory&#39;)\n    def clear_inventory(self, request, queryset):\n        updated__count = queryset.update(inventory=0)\n        self.message_user(\n            request,\n            f&#39;&#123;updated__count&#125; products were successfully updated.&#39;,\n            messages.SUCCESS # 可选\n        )\n</code></pre>\n<h3 id=\"自定义操作表单\"><a href=\"#自定义操作表单\" class=\"headerlink\" title=\"自定义操作表单\"></a>自定义操作表单</h3><p>对于数据的创建或修改的详情页面表单:</p>\n<p><img src=\"/assets/img/image-20231109181130563.png\" alt=\"image-20231109181130563\"></p>\n<p>可以在对应的模型Admin类中对其进行定义, 如:</p>\n<ul>\n<li><p><code>fields = [&#39;title&#39;, &#39;slug&#39;]</code>: 仅显示列表中的字段</p>\n</li>\n<li><p><code>exclude = [&#39;promotions&#39;]</code>: 不显示的字段</p>\n</li>\n<li><p><code>readonly_fields = [&#39;slug&#39;]</code>: 只读字段</p>\n</li>\n<li><p><code>prepopulated_field = &#123;&#39;slug&#39;: [&#39;title&#39;]&#125;</code>:  自动填充字段, 代表slug在空白状态下会根据title的内容进行自动填充, 如果手动更改过则不会变更,  实测没什么效果, 感觉意义不大</p>\n</li>\n<li><p><code>autocomplete_fields = [&#39;collection&#39;]</code>: 自动完成字段, 下拉列表的变种形式, 对于数量太多的下拉列表, 常规形式会严重影响用户操作体验, 自动完成字段则是在下拉列表上方增加一个文本输入框, 实现类似编码自动补全的效果.</p>\n<blockquote>\n<p>需要在<code>Collection</code>模型中设置<code>search_filds</code>成员以配合使用, 否则会出现编译错误</p>\n<pre><code class=\"bash\">django.core.management.base.SystemCheckError: SystemCheckError: System check identified some issues:\n\nERRORS:\n&lt;class &#39;store.admin.ProductAdmin&#39;&gt;: (admin.E040) CollectionAdmin must define &quot;search_fields&quot;, because it&#39;s referenced by ProductAdmin.autocomplete_fields.\n</code></pre>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"内联表\"><a href=\"#内联表\" class=\"headerlink\" title=\"内联表\"></a>内联表</h3><p>在多对多的关系中通常会使用一些链接表, 比如一个<code>Order</code>可以包含多个<code>Product</code>,一个<code>Product</code>可以出现在多个<code>Order</code>中, 所以每一个订单记录都需要知道它是哪一个订单的哪一个产品的信息</p>\n<p>这里定义了一个<code>OrderItem</code>表</p>\n<pre><code class=\"python\">class OrderItem(models.Model):\n    order = models.ForeignKey(Order, on_delete=models.PROTECT)\n    product = models.ForeignKey(Product, on_delete=models.PROTECT)\n    quantity = models.PositiveSmallIntegerField()\n    unit_price = models.DecimalField(max_digits=6, decimal_places=2)\n</code></pre>\n<p>但是在django admin中去单独设计该表的admin页面没有任何实际意义, 因为他必须依托于<code>Order</code>来进行呈现, 所以通常会以内联表的形式进行操作</p>\n<pre><code class=\"python\">class OrderItemInline(admin.TabularInline):\n    model = models.OrderItem\n    autocomplete_fields = [&#39;product&#39;]\n    # 内联表额外的数据行\n    extra = 0\n    # 最小数据行\n    min_num = 1\n    # 实际数据行 = 最小 + 额外\n    \n@admin.register(models.Order)\nclass OrderAdmin(admin.ModelAdmin):\n    list_display = [&#39;id&#39;, &#39;placed_at&#39;, &#39;customer&#39;]\n    ordering = [&#39;id&#39;]\n    list_per_page = LIST_PER_PAGE\n    inlines = [OrderItemInline]\n    autocomplete_fields = [&#39;customer&#39;]\n</code></pre>\n<p>内联样式有两种:</p>\n<ul>\n<li>admin.StackedInline: 以数据表单的形式呈现</li>\n<li>admin.TabularInline: 以数据表的形式呈现, 每条数据呈一行, 比较常用</li>\n</ul>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>有django提供的一个数据管理后台, 功能强大, 熟练使用可以节省大量的编码时间<br><a href=\"https://docs.djangoproject.com/en/dev/ref/contrib/admin/\">Django Admin完整官方文档</a></p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>可以通过<code>admin/</code>进行访问, 如</p>\n<pre><code class=\"url\">http://127.0.0.1:8000/admin\n</code></pre>\n<p>在使用admin之前, 需要创建admin用户, 在终端执行:</p>\n<pre><code class=\"zsh\">python manage.py createsuperuser\n</code></pre>\n<p>输入用户名密码即可.</p>\n<p>忘记密码时可以通过终端命令直接修改</p>\n<pre><code class=\"zsh\">python manage.py changepassword [username]\n</code></pre>\n<h3 id=\"修改后台页面标题\"><a href=\"#修改后台页面标题\" class=\"headerlink\" title=\"修改后台页面标题\"></a>修改后台页面标题</h3><pre><code class=\"python\">from django.contrib import admin\n\n# 可以直接在项目的urls.py中添加, 但不推荐\nadmin.site.site_header = &#39;My site to learn django&#39;\nadmin.site.index_title = &quot;Site Apps&quot;\n</code></pre>\n<p><img src=\"/assets/img/image-20231108212229095.png\" alt=\"image-20231108212229095\">{: .shadow}</p>\n<h2 id=\"注册模块\"><a href=\"#注册模块\" class=\"headerlink\" title=\"注册模块\"></a>注册模块</h2><p>要通过admin后台管理某个app的数据, 需要先对其进行注册, 如<code>playground</code>模块的<code>Product</code>对象</p>\n<pre><code class=\"python\"># `playground/admin.py`\nfrom django.contrib import admin\nfrom . import models\n\nadmin.site.register(models.Product)\n</code></pre>\n<h2 id=\"修改显示字段和表排序方式\"><a href=\"#修改显示字段和表排序方式\" class=\"headerlink\" title=\"修改显示字段和表排序方式\"></a>修改显示字段和表排序方式</h2><pre><code class=\"python\">class Product(models.Model):\n    title = models.CharField(max_length=255)\n    # other fields ...\n\n    def __str__(self) -&gt; str:\n        return str(self.title)\n\n    class Meta:\n        ordering = [&#39;title&#39;]\n</code></pre>\n<h2 id=\"自定义管理后台\"><a href=\"#自定义管理后台\" class=\"headerlink\" title=\"自定义管理后台\"></a>自定义管理后台</h2><p>通过对ORM对象的设置完成自定义的后台管理</p>\n<pre><code class=\"python\"># `playground/admin.py`\nfrom django.contrib import admin\nfrom . import models\n\n# 如果不使用装饰器可以使用代码进行注册\n# admin.site.register(models.Product, ProductAdmin)\n# 只能注册一次, 即装饰器和代码注册只能二选一\n@admin.register(models.Product)\nclass ProductAdmin(admin.ModelAdmin):\n    list_display = [&quot;name&quot;, &#39;price&#39;, &#39;description&#39;]\n    list_editable = [&#39;price&#39;]\n    list_per_page = 20\n    \n    # ---添加计算字段---\n    # 装饰器定义字段的排序方式\n    @admin.display(ordering=&#39;price&#39;)\n    def price_level(self, product):\n        if product.price &lt; 10:\n            return &quot;cheap&quot;\n        return &#39;expensive&#39;\n    \n    # 添加一个计算库存总价值的字段, 该字段同样是计算字段, 但是其数据基于当前数据行\n    # 因此便需要通过重写父类的`get_queryset`方法来修改数据集\n    @admin.display(ordering=F(&#39;price&#39;)*F(&#39;inventory&#39;))\n    def total_price(self, product):\n        return product.total_price\n\n    # admin模块载入orm对象时的查询方法\n    # 与`Model.objects`中获取的数据集操作方式完全一致\n    # 可以通过annotate添加计算字段, 外链字段等一系列操作\n    def get_queryset(self, request: HttpRequest) -&gt; QuerySet[Any]:\n        return super().get_queryset(request) \\\n            .annotate(total_price=F(&#39;price&#39;) * F(&#39;inventory&#39;))\n</code></pre>\n<h3 id=\"外键字段的显示\"><a href=\"#外键字段的显示\" class=\"headerlink\" title=\"外键字段的显示\"></a>外键字段的显示</h3><p>在Product模型中, 存在一个<code>collection</code>外键</p>\n<pre><code class=\"python\">class Product(models.Model):\n    # ...\n    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)\n</code></pre>\n<p>而<code>Collection</code>模型中设置了该模型的<code>__str__</code>方法</p>\n<pre><code class=\"python\">class Collection(models.Model):\n    title = models.CharField(max_length=255)\n    # ...\n    def __str__(self) -&gt; str:\n        return str(self.title)\n</code></pre>\n<p>那么此时,  如果在ProductAdmin中设置显示该外键字段, 那么便会直接显示其<code>title</code>值, 对应的SQL如下:</p>\n<pre><code class=\"sql\">SELECT `store_product`.`id`,\n       `store_product`.`title`,\n       `store_product`.`slug`,\n       `store_product`.`description`,\n       `store_product`.`unit_price`,\n       `store_product`.`inventory`,\n       `store_product`.`last_update`,\n       `store_product`.`collection_id`,\n       `store_collection`.`id`,\n       `store_collection`.`title`,\n       `store_collection`.`featured_product_id`\n  FROM `store_product`\n INNER JOIN `store_collection`\n    ON (`store_product`.`collection_id` = `store_collection`.`id`)\n ORDER BY `store_product`.`title` ASC,\n          `store_product`.`id` DESC\n</code></pre>\n<p>此时对于外键查询并不会产生额外的sql查询</p>\n<p>但如果查询Collection的其他字段, 即通过orm对象进行关联查询, 此处依然用title举例:</p>\n<pre><code class=\"python\">class ProductAdmin(admin.ModelAdmin):\n    list_display = [&#39;title&#39;, &#39;unit_price&#39;,\n                        &#39;inventory_status&#39;, &#39;collection_title&#39;]\n\n    def collection_title(self, product):\n        return product.collection.title\n</code></pre>\n<p>便会因为关联查询而产生额外的sql:</p>\n<pre><code class=\"sql\">SELECT `store_collection`.`id`,\n       `store_collection`.`title`,\n       `store_collection`.`featured_product_id`\n  FROM `store_collection`\n WHERE `store_collection`.`id` = 5\n LIMIT 21\n \n SELECT `store_collection`.`id`,\n       `store_collection`.`title`,\n       `store_collection`.`featured_product_id`\n  FROM `store_collection`\n WHERE `store_collection`.`id` = 4\n LIMIT 21\n \n -- ...\n</code></pre>\n<p>具体产生的sql数量与当前页的数据条目相关</p>\n<p>为了避免额外的sql查询, 可以直接使用关联查询来进行处理, 只需要在<code>list_select_related</code>成员中设置需要关联查询的表, 便可以在显示字段中添加任意关联表的字段.</p>\n<pre><code class=\"python\">class ProductAdmin(admin.ModelAdmin):\n    list_display = [&#39;title&#39;, &#39;unit_price&#39;,\n                    &#39;inventory_status&#39;, &#39;collection_title&#39;]\n    list_editable = [&#39;unit_price&#39;]\n    list_per_page = 10\n    \n    # 设置关联查询表\n    list_select_related = [&#39;collection&#39;]\n</code></pre>\n<p>对应的SQL:</p>\n<pre><code class=\"sql\">SELECT `store_product`.`id`,\n       `store_product`.`title`,\n       `store_product`.`slug`,\n       `store_product`.`description`,\n       `store_product`.`unit_price`,\n       `store_product`.`inventory`,\n       `store_product`.`last_update`,\n       `store_product`.`collection_id`,\n       `store_collection`.`id`,\n       `store_collection`.`title`,\n       `store_collection`.`featured_product_id`\n  FROM `store_product`\n INNER JOIN `store_collection`\n    ON (`store_product`.`collection_id` = `store_collection`.`id`)\n ORDER BY `store_product`.`title` ASC,\n          `store_product`.`id` DESC\n</code></pre>\n<h3 id=\"添加超链接\"><a href=\"#添加超链接\" class=\"headerlink\" title=\"添加超链接\"></a>添加超链接</h3><p>在admin中位某一个字段的值添加超链接</p>\n<pre><code class=\"python\">from django.utils.html import format_html, urlencode\nfrom django.urls import reverse\n\n@admin.register(models.Collection)\nclass CollectionAdmin(admin.ModelAdmin):\n    list_display = [&#39;title&#39;, &#39;products_count&#39;]\n\n    @admin.display(ordering=&#39;products_count&#39;)\n    def products_count(self, collecton):\n        url = (reverse(&#39;admin:store_product_changelist&#39;)\n               + &#39;?&#39;\n               + urlencode(&#123;\n                   &#39;collection__id&#39;: str(collecton.id)\n               &#125;))\n\n        return format_html(&#39;&lt;a href=&quot;&#123;&#125;&quot;&gt;&#123;&#125;&lt;/a&gt;&#39;,\n                           url,\n                           collecton.products_count)\n\n    def get_queryset(self, request: HttpRequest) -&gt; QuerySet[Any]:\n        return super().get_queryset(request)\\\n            .annotate(products_count=Count(&#39;product&#39;))\n</code></pre>\n<p>💡 reverse函数用于动态获取页面的路由地址, 之后再说…</p>\n<blockquote>\n<p>在上面的代码里, <code>get_queryset</code>方法中通过<code>Count</code>统计了<code>product</code>字段</p>\n<pre><code class=\"python\">    def get_queryset(self, request: HttpRequest) -&gt; QuerySet[Any]:\n        return super().get_queryset(request)\\\n            .annotate(products_count=Count(&#39;product&#39;))\n</code></pre>\n<p>而<code>Collection</code>模型的定义如下:</p>\n<pre><code class=\"python\">class Collection(models.Model):\n    title = models.CharField(max_length=255)\n    featured_product = models.ForeignKey(\n        &#39;Product&#39;, on_delete=models.SET_NULL, null=True, related_name=&#39;+&#39;)\n\n    def __str__(self) -&gt; str:\n        return str(self.title)\n\n    class Meta:\n        ordering = [&#39;title&#39;]\n</code></pre>\n<p>显然, 在Collection中并没有product字段, 而代码运行没有问题.</p>\n<p>这是由于django在定义数据模型时, 会位外键字段反向创建一个关系字段, 这一字段应该是创建在python对象中, 所以数据库中并不存在, 来看Product类的定义:</p>\n<pre><code class=\"python\">class Product(models.Model):\n    title = models.CharField(max_length=255)\n    slug = models.SlugField()\n    description = models.TextField()\n    unit_price = models.DecimalField(max_digits=6, decimal_places=2)\n    inventory = models.IntegerField()\n    last_update = models.DateTimeField(auto_now=True)\n    ## 这里\n    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)\n    promotions = models.ManyToManyField(Promotion)\n\n    def __str__(self) -&gt; str:\n        return str(self.title)\n</code></pre>\n<p>正是因为<code>collection</code>字段是到<code>Collection</code>模型的外键字段, 因此在Collection中也就自动添加了<code>product</code>字段,</p>\n<p>于是也就能够直接通过django orm直接在<code>Collection</code>对象中使用<code>Count(&quot;product&quot;)</code>操作了</p>\n<p>再看<code>Collection</code>对象中的代码</p>\n<pre><code class=\"python\">  featured_product = models.ForeignKey(\n      &#39;Product&#39;, on_delete=models.SET_NULL, null=True, related_name=&#39;+&#39;)\n</code></pre>\n<p>这里用了一个关键字参数, <code>related_name=&#39;+&#39;</code></p>\n<p>其意思便是在Product类中不创建反向字段, 事实上, 在本例中如果没有这个关键字参数会触发编译器错误</p>\n<p>因为Product在Collection中创创建了product关系字段,</p>\n<p>同时Collection也在Product中创建了collection关系字段</p>\n<p>而Product自己已经有了一个同名的字段, 也就出现了命名冲突, 只要改掉其中一个名字即可.</p>\n<p>同样的, 如果修改<code>Product</code>类的代码为:</p>\n<pre><code class=\"python\">collection = models.ForeignKey(\n        Collection, on_delete=models.PROTECT, related_name=&#39;+&#39;)\n</code></pre>\n<p>也就是不在Collection对象中创建关系字段, 在访问页面时就会直接出错</p>\n<pre><code class=\"zsh\">django.core.exceptions.FieldError: Cannot resolve keyword &#39;product&#39; into field. Choices are: featured_product, featured_product_id, id, title\n</code></pre>\n</blockquote>\n<h3 id=\"添加搜索\"><a href=\"#添加搜索\" class=\"headerlink\" title=\"添加搜索\"></a>添加搜索</h3><p>在django admin中添加基础的搜索条功能</p>\n<pre><code class=\"python\">search_fields = [&#39;first_name__istartswith&#39;, &#39;last_name__istartswith&#39;]\n</code></pre>\n<p>搜索条会在指定的字段中, 基于指定的lookup方式进行数据搜索</p>\n<h3 id=\"添加过滤器\"><a href=\"#添加过滤器\" class=\"headerlink\" title=\"添加过滤器\"></a>添加过滤器</h3><p>基于当前表的某个字段进行过滤, 可以直接调用django提供的默认过滤器</p>\n<pre><code class=\"python\">list_filter = [&#39;collection&#39;, &#39;last_update&#39;]\n</code></pre>\n<p>也可以使用自定义过滤器, 过滤器本质类似于html中的单选框, 有一个id和一个value, id用于唯一标识, value用于UI显示</p>\n<pre><code class=\"python\">class InventoryFilter(admin.SimpleListFilter):\n    # 显示在过滤器列表中的名称\n    title = &#39;Inventory&#39;\n    # 通过URL传递的参数名称\n    parameter_name = &#39;inven&#39;\n    # 需要返回一个tupule list, 每一个tuple是过滤器的一个显示项, tuple的第一个值会作为过滤器的value, 用于判断过滤器选中状态, 第二个值用于UI显示\n    def lookups(self, request: Any, model_admin: Any) -&gt; list[tuple[Any, str]]:\n        return [\n            (&#39;&lt;10&#39;, &#39;Low&#39;)\n        ]\n\n    def queryset(self, request: Any, queryset: QuerySet[Any]) -&gt; QuerySet[Any] | None:\n        # 如果当前过滤器选项是 `&lt;10`\n        if self.value() == &#39;&lt;10&#39;:\n            # 对当前页面的queryset进行过滤, 与ORM语法完全一样\n            return queryset.filter(inventory__lt=10)\n        return None\n</code></pre>\n<p>并在过滤器列表中添加自定义的过滤器即可</p>\n<pre><code class=\"python\">list_filter = [&#39;collection&#39;, &#39;last_update&#39;, InventoryFilter]\n</code></pre>\n<h3 id=\"自定义用户操作\"><a href=\"#自定义用户操作\" class=\"headerlink\" title=\"自定义用户操作\"></a>自定义用户操作</h3><p>在django admin中添加对数据的批量操作方式</p>\n<pre><code class=\"python\">from django.contrib import admin, messages\n\nfrom . import models\n\n@admin.register(models.Product)\nclass ProductAdmin(admin.ModelAdmin):\n    # ...code...\n    actions = [&#39;clear_inventory&#39;]\n\n    @admin.action(description=&#39;Clear inventory&#39;)\n    def clear_inventory(self, request, queryset):\n        updated__count = queryset.update(inventory=0)\n        self.message_user(\n            request,\n            f&#39;&#123;updated__count&#125; products were successfully updated.&#39;,\n            messages.SUCCESS # 可选\n        )\n</code></pre>\n<h3 id=\"自定义操作表单\"><a href=\"#自定义操作表单\" class=\"headerlink\" title=\"自定义操作表单\"></a>自定义操作表单</h3><p>对于数据的创建或修改的详情页面表单:</p>\n<p><img src=\"/assets/img/image-20231109181130563.png\" alt=\"image-20231109181130563\"></p>\n<p>可以在对应的模型Admin类中对其进行定义, 如:</p>\n<ul>\n<li><p><code>fields = [&#39;title&#39;, &#39;slug&#39;]</code>: 仅显示列表中的字段</p>\n</li>\n<li><p><code>exclude = [&#39;promotions&#39;]</code>: 不显示的字段</p>\n</li>\n<li><p><code>readonly_fields = [&#39;slug&#39;]</code>: 只读字段</p>\n</li>\n<li><p><code>prepopulated_field = &#123;&#39;slug&#39;: [&#39;title&#39;]&#125;</code>:  自动填充字段, 代表slug在空白状态下会根据title的内容进行自动填充, 如果手动更改过则不会变更,  实测没什么效果, 感觉意义不大</p>\n</li>\n<li><p><code>autocomplete_fields = [&#39;collection&#39;]</code>: 自动完成字段, 下拉列表的变种形式, 对于数量太多的下拉列表, 常规形式会严重影响用户操作体验, 自动完成字段则是在下拉列表上方增加一个文本输入框, 实现类似编码自动补全的效果.</p>\n<blockquote>\n<p>需要在<code>Collection</code>模型中设置<code>search_filds</code>成员以配合使用, 否则会出现编译错误</p>\n<pre><code class=\"bash\">django.core.management.base.SystemCheckError: SystemCheckError: System check identified some issues:\n\nERRORS:\n&lt;class &#39;store.admin.ProductAdmin&#39;&gt;: (admin.E040) CollectionAdmin must define &quot;search_fields&quot;, because it&#39;s referenced by ProductAdmin.autocomplete_fields.\n</code></pre>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"内联表\"><a href=\"#内联表\" class=\"headerlink\" title=\"内联表\"></a>内联表</h3><p>在多对多的关系中通常会使用一些链接表, 比如一个<code>Order</code>可以包含多个<code>Product</code>,一个<code>Product</code>可以出现在多个<code>Order</code>中, 所以每一个订单记录都需要知道它是哪一个订单的哪一个产品的信息</p>\n<p>这里定义了一个<code>OrderItem</code>表</p>\n<pre><code class=\"python\">class OrderItem(models.Model):\n    order = models.ForeignKey(Order, on_delete=models.PROTECT)\n    product = models.ForeignKey(Product, on_delete=models.PROTECT)\n    quantity = models.PositiveSmallIntegerField()\n    unit_price = models.DecimalField(max_digits=6, decimal_places=2)\n</code></pre>\n<p>但是在django admin中去单独设计该表的admin页面没有任何实际意义, 因为他必须依托于<code>Order</code>来进行呈现, 所以通常会以内联表的形式进行操作</p>\n<pre><code class=\"python\">class OrderItemInline(admin.TabularInline):\n    model = models.OrderItem\n    autocomplete_fields = [&#39;product&#39;]\n    # 内联表额外的数据行\n    extra = 0\n    # 最小数据行\n    min_num = 1\n    # 实际数据行 = 最小 + 额外\n    \n@admin.register(models.Order)\nclass OrderAdmin(admin.ModelAdmin):\n    list_display = [&#39;id&#39;, &#39;placed_at&#39;, &#39;customer&#39;]\n    ordering = [&#39;id&#39;]\n    list_per_page = LIST_PER_PAGE\n    inlines = [OrderItemInline]\n    autocomplete_fields = [&#39;customer&#39;]\n</code></pre>\n<p>内联样式有两种:</p>\n<ul>\n<li>admin.StackedInline: 以数据表单的形式呈现</li>\n<li>admin.TabularInline: 以数据表的形式呈现, 每条数据呈一行, 比较常用</li>\n</ul>\n"},{"title":"6. 通用关系查询","date":"2023-12-13T08:41:08.346Z","_content":"\n当编写一个tags模块, 用于记录某一项数据是否被标记了\n\n没有必要专门为每一种类型的记录专门定义一个tags模块, 而是可以通过一个通用的tags模块来完成\n\n即视频, 文章, 产品, 等等全部由该模块来进行标记记录, 即便这些数据分属于不同的子app\n\n此时便可以通过`generic relationships`来完成\n\n这一功能基于django的`ContentType`模块\n\n```python\nINSTALLED_APPS = [\n    # ...\n    'django.contrib.contenttypes',\n    # ...\n]\n```\n\ndjango会为所有的model生成一个唯一的content_type, 储存在`django_content_type`表中\n\n要获取特定model的content_type\n\n```python\nfrom django.shortcuts import render\nfrom django.contrib.contenttypes.models import ContentType\n\ndef index(request):\n    # 基于模型类直接获取其content type\n    content_type = ContentType.objects.get_for_model(Product)\n    return render(request, 'tags.html')\n\n```\n\n对应的SQL\n\n```sql\nSELECT `django_content_type`.`id`,\n       `django_content_type`.`app_label`,\n       `django_content_type`.`model`\n  FROM `django_content_type`\n WHERE (`django_content_type`.`app_label` = 'store' AND `django_content_type`.`model` = 'product')\n LIMIT 21\n```\n\n通过`content_type`进行数据查询\n\n```python\nquery_set = TaggedItem.objects\\\n        .select_related('tag')\\\n        .filter(content_type=content_type, object_id=1)\n```\n","source":"_posts/django/6-generic-relationships.md","raw":"---\ntitle: 6. 通用关系查询\ndate: 2023-11-7 02:17:16 +08000\ncategories: [笔记, Django]\ntags: [python, django, backend]\n---\n\n当编写一个tags模块, 用于记录某一项数据是否被标记了\n\n没有必要专门为每一种类型的记录专门定义一个tags模块, 而是可以通过一个通用的tags模块来完成\n\n即视频, 文章, 产品, 等等全部由该模块来进行标记记录, 即便这些数据分属于不同的子app\n\n此时便可以通过`generic relationships`来完成\n\n这一功能基于django的`ContentType`模块\n\n```python\nINSTALLED_APPS = [\n    # ...\n    'django.contrib.contenttypes',\n    # ...\n]\n```\n\ndjango会为所有的model生成一个唯一的content_type, 储存在`django_content_type`表中\n\n要获取特定model的content_type\n\n```python\nfrom django.shortcuts import render\nfrom django.contrib.contenttypes.models import ContentType\n\ndef index(request):\n    # 基于模型类直接获取其content type\n    content_type = ContentType.objects.get_for_model(Product)\n    return render(request, 'tags.html')\n\n```\n\n对应的SQL\n\n```sql\nSELECT `django_content_type`.`id`,\n       `django_content_type`.`app_label`,\n       `django_content_type`.`model`\n  FROM `django_content_type`\n WHERE (`django_content_type`.`app_label` = 'store' AND `django_content_type`.`model` = 'product')\n LIMIT 21\n```\n\n通过`content_type`进行数据查询\n\n```python\nquery_set = TaggedItem.objects\\\n        .select_related('tag')\\\n        .filter(content_type=content_type, object_id=1)\n```\n","slug":"django-6-generic-relationships","published":1,"updated":"2023-12-13T08:41:08.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v00015i3erexcc8ama","content":"<p>当编写一个tags模块, 用于记录某一项数据是否被标记了</p>\n<p>没有必要专门为每一种类型的记录专门定义一个tags模块, 而是可以通过一个通用的tags模块来完成</p>\n<p>即视频, 文章, 产品, 等等全部由该模块来进行标记记录, 即便这些数据分属于不同的子app</p>\n<p>此时便可以通过<code>generic relationships</code>来完成</p>\n<p>这一功能基于django的<code>ContentType</code>模块</p>\n<pre><code class=\"python\">INSTALLED_APPS = [\n    # ...\n    &#39;django.contrib.contenttypes&#39;,\n    # ...\n]\n</code></pre>\n<p>django会为所有的model生成一个唯一的content_type, 储存在<code>django_content_type</code>表中</p>\n<p>要获取特定model的content_type</p>\n<pre><code class=\"python\">from django.shortcuts import render\nfrom django.contrib.contenttypes.models import ContentType\n\ndef index(request):\n    # 基于模型类直接获取其content type\n    content_type = ContentType.objects.get_for_model(Product)\n    return render(request, &#39;tags.html&#39;)\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">SELECT `django_content_type`.`id`,\n       `django_content_type`.`app_label`,\n       `django_content_type`.`model`\n  FROM `django_content_type`\n WHERE (`django_content_type`.`app_label` = &#39;store&#39; AND `django_content_type`.`model` = &#39;product&#39;)\n LIMIT 21\n</code></pre>\n<p>通过<code>content_type</code>进行数据查询</p>\n<pre><code class=\"python\">query_set = TaggedItem.objects\\\n        .select_related(&#39;tag&#39;)\\\n        .filter(content_type=content_type, object_id=1)\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>当编写一个tags模块, 用于记录某一项数据是否被标记了</p>\n<p>没有必要专门为每一种类型的记录专门定义一个tags模块, 而是可以通过一个通用的tags模块来完成</p>\n<p>即视频, 文章, 产品, 等等全部由该模块来进行标记记录, 即便这些数据分属于不同的子app</p>\n<p>此时便可以通过<code>generic relationships</code>来完成</p>\n<p>这一功能基于django的<code>ContentType</code>模块</p>\n<pre><code class=\"python\">INSTALLED_APPS = [\n    # ...\n    &#39;django.contrib.contenttypes&#39;,\n    # ...\n]\n</code></pre>\n<p>django会为所有的model生成一个唯一的content_type, 储存在<code>django_content_type</code>表中</p>\n<p>要获取特定model的content_type</p>\n<pre><code class=\"python\">from django.shortcuts import render\nfrom django.contrib.contenttypes.models import ContentType\n\ndef index(request):\n    # 基于模型类直接获取其content type\n    content_type = ContentType.objects.get_for_model(Product)\n    return render(request, &#39;tags.html&#39;)\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">SELECT `django_content_type`.`id`,\n       `django_content_type`.`app_label`,\n       `django_content_type`.`model`\n  FROM `django_content_type`\n WHERE (`django_content_type`.`app_label` = &#39;store&#39; AND `django_content_type`.`model` = &#39;product&#39;)\n LIMIT 21\n</code></pre>\n<p>通过<code>content_type</code>进行数据查询</p>\n<pre><code class=\"python\">query_set = TaggedItem.objects\\\n        .select_related(&#39;tag&#39;)\\\n        .filter(content_type=content_type, object_id=1)\n</code></pre>\n"},{"title":"8. Django 数据校验","date":"2023-12-13T08:41:08.347Z","_content":"\n[Django 数据校验的文档](https://docs.djangoproject.com/en/4.2/ref/validators/)\n\n在定义ORM模型时便可直接为字段添加数据校验\n\n```python\nfrom django.core.validators import MinValueValidator\nclass Product(models.Model):\n    title = models.CharField(max_length=255)\n    slug = models.SlugField()\n    # null表示在数据库中可以为空, 而表单依然要求输入内容\n    # blank则表示表单输入可以为空\n    description = models.TextField(null=True, blank=True)\n    unit_price = models.DecimalField(max_digits=6,\n                                     decimal_places=2,\n                                     validators=[MinValueValidator(1, message='最小值为1')])\n```\n","source":"_posts/django/8-basic-data-validation.md","raw":"---\ntitle: 8. Django 数据校验\ndate: 2023-11-8 02:18:51 +08000\ncategories: [笔记, Django]\ntags: [python, django, backend]\n---\n\n[Django 数据校验的文档](https://docs.djangoproject.com/en/4.2/ref/validators/)\n\n在定义ORM模型时便可直接为字段添加数据校验\n\n```python\nfrom django.core.validators import MinValueValidator\nclass Product(models.Model):\n    title = models.CharField(max_length=255)\n    slug = models.SlugField()\n    # null表示在数据库中可以为空, 而表单依然要求输入内容\n    # blank则表示表单输入可以为空\n    description = models.TextField(null=True, blank=True)\n    unit_price = models.DecimalField(max_digits=6,\n                                     decimal_places=2,\n                                     validators=[MinValueValidator(1, message='最小值为1')])\n```\n","slug":"django-8-basic-data-validation","published":1,"updated":"2023-12-13T08:41:08.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v1001ai3er13tqfwrl","content":"<p><a href=\"https://docs.djangoproject.com/en/4.2/ref/validators/\">Django 数据校验的文档</a></p>\n<p>在定义ORM模型时便可直接为字段添加数据校验</p>\n<pre><code class=\"python\">from django.core.validators import MinValueValidator\nclass Product(models.Model):\n    title = models.CharField(max_length=255)\n    slug = models.SlugField()\n    # null表示在数据库中可以为空, 而表单依然要求输入内容\n    # blank则表示表单输入可以为空\n    description = models.TextField(null=True, blank=True)\n    unit_price = models.DecimalField(max_digits=6,\n                                     decimal_places=2,\n                                     validators=[MinValueValidator(1, message=&#39;最小值为1&#39;)])\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p><a href=\"https://docs.djangoproject.com/en/4.2/ref/validators/\">Django 数据校验的文档</a></p>\n<p>在定义ORM模型时便可直接为字段添加数据校验</p>\n<pre><code class=\"python\">from django.core.validators import MinValueValidator\nclass Product(models.Model):\n    title = models.CharField(max_length=255)\n    slug = models.SlugField()\n    # null表示在数据库中可以为空, 而表单依然要求输入内容\n    # blank则表示表单输入可以为空\n    description = models.TextField(null=True, blank=True)\n    unit_price = models.DecimalField(max_digits=6,\n                                     decimal_places=2,\n                                     validators=[MinValueValidator(1, message=&#39;最小值为1&#39;)])\n</code></pre>\n"},{"title":"4. Django orm的基本使用","date":"2023-12-13T08:41:08.346Z","_content":"\ndjango orm的基本用法:\n\n```python\nfrom characters.models import Character\nquery = Character.objects.all()\n```\n\n通过直接调用模型类的objects成员的对应方法即可创建查询对象\n\n所创建的查询对象是延迟加载的,  以此来方便进行符合查询,如:\n\n```python\nCharacter.objects.all().order_by('level')\n```\n\n只有当确定读取数据的时候才会真正进行数据库查询, 如\n\n```python\nlist(query)\nquery[0:5]\n```\n\n即可以减少和服务器交互的次数, 也可以减少内存占用.\n\n## 查询对象\n\n### get()\n\n```python\ncharacter = Character.objects.get(pk=1)\n```\n\n如果id不存在, 则会引发异常, 因此需要为其进行异常处理\n\n```python\nfrom django.core.exceptions import ObjectDoesNotExist\n\ntry:\n    obj = Character.objects.get(pk=pk)\nexcept ObjectDoesNotExist:\n    pass\n```\n\n### filter()\n\n```python\n# 作用于get()想通, 区别在于不需要异常处理\nCharacter.objects.filter(pk=pk).first()\n```\n\nfilter()方法可以接收模型类所包含字段的过滤器, 其格式为:\n\n```python\nfiledname__lookup=value\n```\n\n比如`name`字段包含`woo`的行,就可以写成\n\n```python\nquery_set = Character.objects.filter(name__contains=\"woo\")\n\n# __contains代表包含, __icontains代表忽略大小写包含\n```\n\n#### 常用过滤器lookup\n\n* `range`: 查询范围, __range=(10,20)\n* `contains`,`icontains`:包含关键字\n* `in`,`gt`,`gte`,`lt`,`lte`: 在范围内, >,>=,<,<=\n* `start/endwith`:以xxx开始或结尾的,同样可以使用`i`前缀忽略大小写\n* `isnull`: 空值判断\n* `regex`:正则\n\n等等, 详细文档连线:[QuerySet API](https://docs.djangoproject.com/en/4.2/ref/models/querysets/#field-lookups)\n\n#### 复合查询\n\n可以向filter()传递多个关键字参数,以实现符合查询,如:\n\n```python\n# health > 50k and ap > 10k\nquery_set = Character.objects.filter(health__gt=50000,\n                                         attack_power__gt=10000)\n\n# 也可以写成\nquery_set = Character.objects.filter(health__gt=50000).filter(attack_power__gt=100000)\n```\n\n对应的SQL:\n\n```sql\nSELECT *\n  FROM `characters_character`\n WHERE (`characters_character`.`attack_power` > 10000 AND `characters_character`.`health` > 50000)\n```\n\n#### 使用`Q`进行复合逻辑查询\n\ndjango提供一个专用来处理查询条件的类`Q`, 每一个`Q`对象对应一个查询条件, 在多个`Q`对象之间可以使用逻辑运算符进行链接, 通常用来处理`OR`和`NOT` 关键字的查询, 如\n\n```python\nquery_set = Character.objects.filter(Q(health__gt=50000) &\n                                         Q(health__lt=70000))\n```\n\n对应的SQL\n\n```sql\nSELECT *\n  FROM `characters_character`\n WHERE (`characters_character`.`health` > 50000 AND `characters_character`.`health` < 70000)\n```\n\n或者:\n\n```python\nquery_set = Character.objects.filter(Q(attack_power__lt=50000) |\n                                         ~Q(health__gt=50000))\n```\n\n对应的SQL:\n\n```sql\nSELECT *\n  FROM `characters_character`\n WHERE (`characters_character`.`attack_power` < 50000 OR NOT (`characters_character`.`health` > 50000))\n```\n\n#### 使用F对象进行查询\n\nF代表字段引用, 在查询条件为表中某个字段的值时使用, 如:\n\n```python\nquery_set = Character.objects.filter(attack_power__gt=F('defense'))\n```\n\n对应的SQL:\n\n```sql\nSELECT *\n  FROM `characters_character`\n WHERE `characters_character`.`attack_power` > (`characters_character`.`defense`)\n```\n\n在关联字段查询时经常用到`F`对象\n\n### 排序\n\n通过`order_by`方法来对结果集进行排序, 直接输入字段名为正序, 添加`-`为倒序, 并且可以依据多个字段进行排序, 如:\n\n```python\n# 基于等级倒序, 按名称正序排列\nquery_set = Character.objects.order_by('-level', 'name')\n```\n\n对应的SQL\n\n```sql\nSELECT *\n  FROM `characters_character`\n ORDER BY `characters_character`.`level` DESC,\n          `characters_character`.`name` ASC\n```\n\n`reverse()` 反转排序条件\n\n### 分页\n\ndjango中的分页十分方便, 直接使用python的切片语法即可, 如:\n\n```python\ndef characters_ap_ranking_list(page, page_count=10):\n    query_set = Character.objects.order_by('-attack_power')\n    return query_set[page_count*(page-1):page_count * page]\n```\n\n对应的SQL:\n\n```sql\nSELECT *\n  FROM `characters_character`\n ORDER BY `characters_character`.`attack_power` DESC\n LIMIT 10\nOFFSET 20\n```\n\n### 指定数据与关联查询\n\n通过`values()`方法可以指定要进行查询的字段, 而非获取所有字段的数据以提升效率, 如\n\n```python\nquery_set = Character.objects.filter(id__lt=10).values('name', 'level')\n```\n\n对应SQL\n\n```sql\nSELECT `characters_character`.`name`,\n       `characters_character`.`level`\n  FROM `characters_character`\n WHERE `characters_character`.`id` < 10\n```\n\n同时可以进行关联查询, 在model1中存在外键关联到model2, 则可以直接通过改外键查询到关联表的字段值,如:\n\n```python\n# 其中 Character 模型存在一个外键, 对应 Club 类\n# club = models.ForeignKey(Club, on_delete=models.SET_NULL, null=True)\n\nquery_set = Character.objects.filter(id__lt=10)\nquery_set = query_set.values('name', 'level', 'club__name')\n```\n\n对应SQL\n\n```sql\nSELECT `characters_character`.`name`,\n       `characters_character`.`level`,\n       `characters_club`.`name`\n  FROM `characters_character`\n  LEFT OUTER JOIN `characters_club`\n    ON (`characters_character`.`club_id` = `characters_club`.`id`)\n WHERE `characters_character`.`id` < 10\n```\n\n`values()`指定的字段名将直接作为查询结果ORM对象的字段名, 查询打印结果如下:\n\n```zsh\n<QuerySet [\n{'name': 'Alec Rois', 'level': 95, 'club__name': 'Harris-Towne'}, \n{'name': 'Fairlie Champagne', 'level': 219, 'club__name': 'Lesch-Jacobson'},\n{'name': 'Gard Scargill', 'level': 218, 'club__name': 'Goldner-Kris'}, \n{'name': 'Bordie Domingues', 'level': 6, 'club__name': 'Harris-Towne'}, \n{'name': 'Renate Lamlin', 'level': 54, 'club__name': 'Huels, Wintheiser and Wisozk'}, \n{'name': 'Marsha Pellatt', 'level': 173, 'club__name': 'Skiles, Heathcote and Leannon'}, \n{'name': 'Luella Jakeway', 'level': 200, 'club__name': 'Skiles, Heathcote and Leannon'}, \n{'name': 'Gustavus Colliber', 'level': 80, 'club__name': 'Reinger LLC'}, \n{'name': 'Araldo Prosh', 'level': 193, 'club__name': 'Lesch-Jacobson'}]>\n```\n\n`values()` 方法返回的是词典集合, 而不是orm对象集合, 参数列表便是词典的`key`\n\n`values_list()`: 方法则是返回包含全部值的元组, 即没有字段名, 仅有数据\n\n** `only()`: 方法的效果与values()类似, 区别在于返回的不是词典, 而是模型对象, 也就具备后续操作的能力, 如果通过模型对象获取一个没有在only查询中列出的字段, 则会自动进行额外的数据库查询.\n\n### distinct去重\n\n通过`distinct()`方法可以去除重复的数据行, 如\n\n```python\nquery_set = Character.objects.values('level').distinct().order_by('level')\n```\n\n对应的SQL\n\n```sql\nSELECT DISTINCT `characters_character`.`level`\n  FROM `characters_character`\n ORDER BY `characters_character`.`level` ASC\n```\n\n去重操作可以用来确定一个范围, 比如:\n\n```python\n# 在人物表字段`club_id`上进行去重查询\nquery_set = Character.objects.values('club_id').distinct()\n# 查询club表, 并以上述查询作为范围, 以获取包含任务的club\nclub_set = Club.objects.filter(id__in=query_set)\n```\n\n对应的SQL\n\n```sql\nSELECT *\n  FROM `characters_club`\n WHERE `characters_club`.`id` IN (\n        SELECT DISTINCT U0.`club_id`\n          FROM `characters_character` U0\n       )\n```\n\n### 预加载数据\n\ndjango在获取orm对象时, 默认只加载当前表的数据, 对于外链表的数据并不会载入, 但是依然可以通过数据模型直接进行关联查询, 如\n\n```python\n# views.py\nquery_set = Character.objects.all()\n```\n\n在模板页面中通过orm对象获取关联表数据:\n\n```html\n# template.html\n<td>{{obj.club.name}}</td>\n```\n\n此时, 代码不会出现任何问题, 但是会产生大量额外用来查询关联表的SQL\n\n```sql\nSELECT *\n  FROM `characters_character`\n        --由于关联查询而产生的额外sql\nSELECT `characters_club`.`id`,\n        --fields ...\n  FROM `characters_club`\n WHERE `characters_club`.`id` = 26\n LIMIT 21\n \nSELECT `characters_club`.`id`,\n        --fields ...\n  FROM `characters_club`\n WHERE `characters_club`.`id` = 5\n LIMIT 21\n \n --...\n```\n\n为了解决这一问题, 可以使用预加载\n\n```python\nquery_set = Character.objects.select_related('club').all()\n```\n\n对应的SQL:\n\n```sql\nSELECT -- fields ...\n       `characters_club`.`id`,\n       `characters_club`.`name`,\n        -- fields ...\n  FROM `characters_character`\n  LEFT OUTER JOIN `characters_club`\n    ON (`characters_character`.`club_id` = `characters_club`.`id`)\n```\n\n如此渲染同样的模板便不会产生额外的sql查询了\n\n`select_related`: 用于加载多一或者一对一的关系\n\n`prefetch_related`:用于加载多对多\n\n### 数据统计\n\n通过`aggreate`方法来进行数据统计\n\n```python\nfrom django.db.models.aggregates import Count, Max, Min, Avg\n\nresult = Character.objects.aggregate(count=Count('name'),\n                                         avg_level=Avg('level'),\n                                         max_ap=Max('attack_power'),\n                                         min_health=Min('health'))\n```\n\n对应的SQL\n\n```sql\nSELECT COUNT(`characters_character`.`name`) AS `count`,\n       AVG(`characters_character`.`level`) AS `avg_level`,\n       MAX(`characters_character`.`attack_power`) AS `max_ap`,\n       MIN(`characters_character`.`health`) AS `min_health`\n  FROM `characters_character`\n```\n\n### 添加注解字段\n\n可以通过`annotate()`方法在结果集中加入自定义的字段,如\n\n```python\nfrom django.db.models import F, Value\n\n# 注解字段的值不能使基本类型, 必须是表达式对象\n# 可以是`Value`, `F`, `Func`, `Aggregate`\ntemp = Character.objects.filter(level=254).values(\n    'id', 'name', 'level'\n).annotate(\n    max_level=Value(True)\n).annotate(\n    test=Value(\"test\")\n).annotate(\n    club_owner_id=F('club__owner')\n).annotate(\n    club_owner_name=F('club__owner__name')\n).annotate(\n    ap_avg_dev=F('attack_power') - avg_attack_power['avg_ap']\n)\n```\n\n对应的sql\n\n```sql\nSELECT `characters_character`.`id`,\n       `characters_character`.`name`,\n       `characters_character`.`level`,\n       1 AS `max_level`,\n       'test' AS `test`,\n       `characters_club`.`owner_id` AS `club_owner_id`,\n       T3.`name` AS `club_owner_name`,\n       (`characters_character`.`attack_power` - 50049.574e0) AS `ap_avg_dev`\n  FROM `characters_character`\n  LEFT OUTER JOIN `characters_club`\n    ON (`characters_character`.`club_id` = `characters_club`.`id`)\n  LEFT OUTER JOIN `characters_character` T3\n    ON (`characters_club`.`owner_id` = T3.`id`)\n WHERE `characters_character`.`level` = 254\n```\n\n## 添加数据\n\ndjango的数据添加可以直接通过模型对象完成, 如:\n\n```python\n  p = Product()\n  p.name = \"some product\"\n  p.description = \"description of this product...\"\n  p.price = 0.99\n  p.save()\n```\n\n也可以通过模型类的构造函数或者使用create语句:\n\n```python\nProduct.objects.create(name=\"p1\",\n                       description=\"description of this product\",\n                       price=0.99)\n```\n\n但是通过关键字参数创建数据会存在一些问题:\n\n* 在编码时没有代码提示,需要纯手动键入, 容易出现错误\n* 在通过重命名进行重构字段时, 关键字参数不会被重命名, 导致引发异常\n\n因此建议在任何时候都实用对象赋值的方式进行数据添加\n\n## 更新数据\n\n与添加数据的操作类似, 仅需要通过`id`或者其他字段确定需要更新的数据, 然后修改其对应的数据并`save()`即可, 如:\n\n```python\n# 更新id位2的数据的name字段\np = Product(pk=2)\np.name = \"update product name\"\np.save()\n```\n\n但在实际运行中会出现问题, 因为p对象的其他字段的值皆为`None`, 如果表存在非空约束的字段, 那么会直接报错, 如果没有非空约束, 那么原始数据会被更新为空.\n\n因此, 正确的更新方式应该是优先通过ORM获取原始数据, 以保证所有的字段数据都在ORM对象之中, 然后更新其中的数据, 代码如下:\n\n```python\np = Product.objects.get(pk=2)\np.name = \"update product name\"\np.save()\n```\n\n对应的SQL\n\n```sql\nSELECT `playground_product`.`id`,\n       `playground_product`.`name`,\n       `playground_product`.`description`,\n       `playground_product`.`price`,\n       `playground_product`.`create_at`\n  FROM `playground_product`\n WHERE `playground_product`.`id` = 2\n LIMIT 21\n\nUPDATE `playground_product`\n   SET `name` = 'update product name',\n        -- 以下为数据库中的原始数据\n       `description` = 'description of this product',\n       `price` = 0.99,\n       `create_at` = '2023-11-08 12:09:37.122549'\n WHERE `playground_product`.`id` = 2\n```\n\n为了避免额外进行一次数据库读取的操作,可以通过`update`方法直接进行更新\n\n```python\nProduct.objects.filter(pk=2).update(name=\"new name by update\")\n```\n\n对应的SQL\n\n```sql\nUPDATE `playground_product`\n   SET `name` = 'new name by update'\n WHERE `playground_product`.`id` = 2\n```\n\n没有前置的数据读取, 也没有额外的数据写入, 但是仅有一个问题. 就是在对字段名进行重命名重构时关键字参数不会被重构, 从而存在出现bug的风险.\n\n## 删除数据\n\n直接通过ORM对象删除或者通过查询删除皆可, 如:\n\n```python\nProduct(pk=1).delete()\n\nProduct.objects.filter(pk__lt=100).delete()\n```\n\n## 事务(Transection)管理\n\n多条数据库操作一并执行, 要么全部成功, 要么全部失败\n\n```python\nfrom django.db import transaction\n\n# 装饰函数的所有内容放入同一个事务中进行管理\n@transaction.atomic()\ndef test_transaction():\n    p1 = Product()\n    p1.name = \"new product\"\n    p1.description = \"insert in transaction\"\n    p1.price = 1.2\n    p1.save()\n\n    p2 = Product(pk=3)\n    p2.name = \"new product\"\n    p2.description = 'already in database'\n    p2.price = 5\n    p2.save()\n```\n\n由于p2已经存在于数据库中, 相当于执行了update操作, 但是存在非空字段, 故而更新失败.\n\n所以同属一个事务的p1也不会保存到数据库中\n\n也可以对方法的部分内容进行事务管理, 如下:\n\n```python\ndef test_transaction():\n    # some code...\n    with transaction.atomic():\n        p1 = Product()\n        p1.name = \"new product\"\n        p1.description = \"insert in transaction\"\n        p1.price = 1.2\n        p1.save()\n\n        p2 = Product(pk=3)\n        p2.name = \"new product\"\n        p2.description = 'already in database'\n        p2.price = 5\n        p2.save()\n```\n\n## 执行原生SQL\n\n可以通过ORM对象直接调用原生SQL语句\n\n```python\nquery_set = Product.objects.raw(\"select * from playground_product\")\n```\n\n对应的SQL\n\n```sql\nselect *\n  from playground_product\n```\n\n对于简单的SQL语句完全没有必要, Django orm可以很好的生成这些语句\n\n但是某些情况下, 需要处理的查询比较复杂, 通过orm编写较为困难,或者容易产生性能瓶颈, 便可以直接通过原生SQL语句进行优化.\n\n对于执行原生SQL的情况, ORM模型并非是必须的环节, 可以直接通过数据库直连来执行, 如下:\n\n```python\nfrom django.db import connection\n\ncursor = connection.cursor()\ncursor.execute(\"select * from playground_product\")\ncursor.close()\n\n# 由于cursor必须手动关闭, 通常结合with一同使用\nwith connection.cursor() as cursor:\n    # 执行sql语句\n    cursor.execute(\"select * from playground_product\")\n    # 执行存储过程\n    cursor.callproc('get_product', [1, 2, 3])\n```\n","source":"_posts/django/4-use-django-orm.md","raw":"---\ntitle: 4. Django orm的基本使用\ndate: 2023-11-6 02:01:22 +08000\ncategories: [笔记, Django]\ntags: [python, django, backend]\n---\n\ndjango orm的基本用法:\n\n```python\nfrom characters.models import Character\nquery = Character.objects.all()\n```\n\n通过直接调用模型类的objects成员的对应方法即可创建查询对象\n\n所创建的查询对象是延迟加载的,  以此来方便进行符合查询,如:\n\n```python\nCharacter.objects.all().order_by('level')\n```\n\n只有当确定读取数据的时候才会真正进行数据库查询, 如\n\n```python\nlist(query)\nquery[0:5]\n```\n\n即可以减少和服务器交互的次数, 也可以减少内存占用.\n\n## 查询对象\n\n### get()\n\n```python\ncharacter = Character.objects.get(pk=1)\n```\n\n如果id不存在, 则会引发异常, 因此需要为其进行异常处理\n\n```python\nfrom django.core.exceptions import ObjectDoesNotExist\n\ntry:\n    obj = Character.objects.get(pk=pk)\nexcept ObjectDoesNotExist:\n    pass\n```\n\n### filter()\n\n```python\n# 作用于get()想通, 区别在于不需要异常处理\nCharacter.objects.filter(pk=pk).first()\n```\n\nfilter()方法可以接收模型类所包含字段的过滤器, 其格式为:\n\n```python\nfiledname__lookup=value\n```\n\n比如`name`字段包含`woo`的行,就可以写成\n\n```python\nquery_set = Character.objects.filter(name__contains=\"woo\")\n\n# __contains代表包含, __icontains代表忽略大小写包含\n```\n\n#### 常用过滤器lookup\n\n* `range`: 查询范围, __range=(10,20)\n* `contains`,`icontains`:包含关键字\n* `in`,`gt`,`gte`,`lt`,`lte`: 在范围内, >,>=,<,<=\n* `start/endwith`:以xxx开始或结尾的,同样可以使用`i`前缀忽略大小写\n* `isnull`: 空值判断\n* `regex`:正则\n\n等等, 详细文档连线:[QuerySet API](https://docs.djangoproject.com/en/4.2/ref/models/querysets/#field-lookups)\n\n#### 复合查询\n\n可以向filter()传递多个关键字参数,以实现符合查询,如:\n\n```python\n# health > 50k and ap > 10k\nquery_set = Character.objects.filter(health__gt=50000,\n                                         attack_power__gt=10000)\n\n# 也可以写成\nquery_set = Character.objects.filter(health__gt=50000).filter(attack_power__gt=100000)\n```\n\n对应的SQL:\n\n```sql\nSELECT *\n  FROM `characters_character`\n WHERE (`characters_character`.`attack_power` > 10000 AND `characters_character`.`health` > 50000)\n```\n\n#### 使用`Q`进行复合逻辑查询\n\ndjango提供一个专用来处理查询条件的类`Q`, 每一个`Q`对象对应一个查询条件, 在多个`Q`对象之间可以使用逻辑运算符进行链接, 通常用来处理`OR`和`NOT` 关键字的查询, 如\n\n```python\nquery_set = Character.objects.filter(Q(health__gt=50000) &\n                                         Q(health__lt=70000))\n```\n\n对应的SQL\n\n```sql\nSELECT *\n  FROM `characters_character`\n WHERE (`characters_character`.`health` > 50000 AND `characters_character`.`health` < 70000)\n```\n\n或者:\n\n```python\nquery_set = Character.objects.filter(Q(attack_power__lt=50000) |\n                                         ~Q(health__gt=50000))\n```\n\n对应的SQL:\n\n```sql\nSELECT *\n  FROM `characters_character`\n WHERE (`characters_character`.`attack_power` < 50000 OR NOT (`characters_character`.`health` > 50000))\n```\n\n#### 使用F对象进行查询\n\nF代表字段引用, 在查询条件为表中某个字段的值时使用, 如:\n\n```python\nquery_set = Character.objects.filter(attack_power__gt=F('defense'))\n```\n\n对应的SQL:\n\n```sql\nSELECT *\n  FROM `characters_character`\n WHERE `characters_character`.`attack_power` > (`characters_character`.`defense`)\n```\n\n在关联字段查询时经常用到`F`对象\n\n### 排序\n\n通过`order_by`方法来对结果集进行排序, 直接输入字段名为正序, 添加`-`为倒序, 并且可以依据多个字段进行排序, 如:\n\n```python\n# 基于等级倒序, 按名称正序排列\nquery_set = Character.objects.order_by('-level', 'name')\n```\n\n对应的SQL\n\n```sql\nSELECT *\n  FROM `characters_character`\n ORDER BY `characters_character`.`level` DESC,\n          `characters_character`.`name` ASC\n```\n\n`reverse()` 反转排序条件\n\n### 分页\n\ndjango中的分页十分方便, 直接使用python的切片语法即可, 如:\n\n```python\ndef characters_ap_ranking_list(page, page_count=10):\n    query_set = Character.objects.order_by('-attack_power')\n    return query_set[page_count*(page-1):page_count * page]\n```\n\n对应的SQL:\n\n```sql\nSELECT *\n  FROM `characters_character`\n ORDER BY `characters_character`.`attack_power` DESC\n LIMIT 10\nOFFSET 20\n```\n\n### 指定数据与关联查询\n\n通过`values()`方法可以指定要进行查询的字段, 而非获取所有字段的数据以提升效率, 如\n\n```python\nquery_set = Character.objects.filter(id__lt=10).values('name', 'level')\n```\n\n对应SQL\n\n```sql\nSELECT `characters_character`.`name`,\n       `characters_character`.`level`\n  FROM `characters_character`\n WHERE `characters_character`.`id` < 10\n```\n\n同时可以进行关联查询, 在model1中存在外键关联到model2, 则可以直接通过改外键查询到关联表的字段值,如:\n\n```python\n# 其中 Character 模型存在一个外键, 对应 Club 类\n# club = models.ForeignKey(Club, on_delete=models.SET_NULL, null=True)\n\nquery_set = Character.objects.filter(id__lt=10)\nquery_set = query_set.values('name', 'level', 'club__name')\n```\n\n对应SQL\n\n```sql\nSELECT `characters_character`.`name`,\n       `characters_character`.`level`,\n       `characters_club`.`name`\n  FROM `characters_character`\n  LEFT OUTER JOIN `characters_club`\n    ON (`characters_character`.`club_id` = `characters_club`.`id`)\n WHERE `characters_character`.`id` < 10\n```\n\n`values()`指定的字段名将直接作为查询结果ORM对象的字段名, 查询打印结果如下:\n\n```zsh\n<QuerySet [\n{'name': 'Alec Rois', 'level': 95, 'club__name': 'Harris-Towne'}, \n{'name': 'Fairlie Champagne', 'level': 219, 'club__name': 'Lesch-Jacobson'},\n{'name': 'Gard Scargill', 'level': 218, 'club__name': 'Goldner-Kris'}, \n{'name': 'Bordie Domingues', 'level': 6, 'club__name': 'Harris-Towne'}, \n{'name': 'Renate Lamlin', 'level': 54, 'club__name': 'Huels, Wintheiser and Wisozk'}, \n{'name': 'Marsha Pellatt', 'level': 173, 'club__name': 'Skiles, Heathcote and Leannon'}, \n{'name': 'Luella Jakeway', 'level': 200, 'club__name': 'Skiles, Heathcote and Leannon'}, \n{'name': 'Gustavus Colliber', 'level': 80, 'club__name': 'Reinger LLC'}, \n{'name': 'Araldo Prosh', 'level': 193, 'club__name': 'Lesch-Jacobson'}]>\n```\n\n`values()` 方法返回的是词典集合, 而不是orm对象集合, 参数列表便是词典的`key`\n\n`values_list()`: 方法则是返回包含全部值的元组, 即没有字段名, 仅有数据\n\n** `only()`: 方法的效果与values()类似, 区别在于返回的不是词典, 而是模型对象, 也就具备后续操作的能力, 如果通过模型对象获取一个没有在only查询中列出的字段, 则会自动进行额外的数据库查询.\n\n### distinct去重\n\n通过`distinct()`方法可以去除重复的数据行, 如\n\n```python\nquery_set = Character.objects.values('level').distinct().order_by('level')\n```\n\n对应的SQL\n\n```sql\nSELECT DISTINCT `characters_character`.`level`\n  FROM `characters_character`\n ORDER BY `characters_character`.`level` ASC\n```\n\n去重操作可以用来确定一个范围, 比如:\n\n```python\n# 在人物表字段`club_id`上进行去重查询\nquery_set = Character.objects.values('club_id').distinct()\n# 查询club表, 并以上述查询作为范围, 以获取包含任务的club\nclub_set = Club.objects.filter(id__in=query_set)\n```\n\n对应的SQL\n\n```sql\nSELECT *\n  FROM `characters_club`\n WHERE `characters_club`.`id` IN (\n        SELECT DISTINCT U0.`club_id`\n          FROM `characters_character` U0\n       )\n```\n\n### 预加载数据\n\ndjango在获取orm对象时, 默认只加载当前表的数据, 对于外链表的数据并不会载入, 但是依然可以通过数据模型直接进行关联查询, 如\n\n```python\n# views.py\nquery_set = Character.objects.all()\n```\n\n在模板页面中通过orm对象获取关联表数据:\n\n```html\n# template.html\n<td>{{obj.club.name}}</td>\n```\n\n此时, 代码不会出现任何问题, 但是会产生大量额外用来查询关联表的SQL\n\n```sql\nSELECT *\n  FROM `characters_character`\n        --由于关联查询而产生的额外sql\nSELECT `characters_club`.`id`,\n        --fields ...\n  FROM `characters_club`\n WHERE `characters_club`.`id` = 26\n LIMIT 21\n \nSELECT `characters_club`.`id`,\n        --fields ...\n  FROM `characters_club`\n WHERE `characters_club`.`id` = 5\n LIMIT 21\n \n --...\n```\n\n为了解决这一问题, 可以使用预加载\n\n```python\nquery_set = Character.objects.select_related('club').all()\n```\n\n对应的SQL:\n\n```sql\nSELECT -- fields ...\n       `characters_club`.`id`,\n       `characters_club`.`name`,\n        -- fields ...\n  FROM `characters_character`\n  LEFT OUTER JOIN `characters_club`\n    ON (`characters_character`.`club_id` = `characters_club`.`id`)\n```\n\n如此渲染同样的模板便不会产生额外的sql查询了\n\n`select_related`: 用于加载多一或者一对一的关系\n\n`prefetch_related`:用于加载多对多\n\n### 数据统计\n\n通过`aggreate`方法来进行数据统计\n\n```python\nfrom django.db.models.aggregates import Count, Max, Min, Avg\n\nresult = Character.objects.aggregate(count=Count('name'),\n                                         avg_level=Avg('level'),\n                                         max_ap=Max('attack_power'),\n                                         min_health=Min('health'))\n```\n\n对应的SQL\n\n```sql\nSELECT COUNT(`characters_character`.`name`) AS `count`,\n       AVG(`characters_character`.`level`) AS `avg_level`,\n       MAX(`characters_character`.`attack_power`) AS `max_ap`,\n       MIN(`characters_character`.`health`) AS `min_health`\n  FROM `characters_character`\n```\n\n### 添加注解字段\n\n可以通过`annotate()`方法在结果集中加入自定义的字段,如\n\n```python\nfrom django.db.models import F, Value\n\n# 注解字段的值不能使基本类型, 必须是表达式对象\n# 可以是`Value`, `F`, `Func`, `Aggregate`\ntemp = Character.objects.filter(level=254).values(\n    'id', 'name', 'level'\n).annotate(\n    max_level=Value(True)\n).annotate(\n    test=Value(\"test\")\n).annotate(\n    club_owner_id=F('club__owner')\n).annotate(\n    club_owner_name=F('club__owner__name')\n).annotate(\n    ap_avg_dev=F('attack_power') - avg_attack_power['avg_ap']\n)\n```\n\n对应的sql\n\n```sql\nSELECT `characters_character`.`id`,\n       `characters_character`.`name`,\n       `characters_character`.`level`,\n       1 AS `max_level`,\n       'test' AS `test`,\n       `characters_club`.`owner_id` AS `club_owner_id`,\n       T3.`name` AS `club_owner_name`,\n       (`characters_character`.`attack_power` - 50049.574e0) AS `ap_avg_dev`\n  FROM `characters_character`\n  LEFT OUTER JOIN `characters_club`\n    ON (`characters_character`.`club_id` = `characters_club`.`id`)\n  LEFT OUTER JOIN `characters_character` T3\n    ON (`characters_club`.`owner_id` = T3.`id`)\n WHERE `characters_character`.`level` = 254\n```\n\n## 添加数据\n\ndjango的数据添加可以直接通过模型对象完成, 如:\n\n```python\n  p = Product()\n  p.name = \"some product\"\n  p.description = \"description of this product...\"\n  p.price = 0.99\n  p.save()\n```\n\n也可以通过模型类的构造函数或者使用create语句:\n\n```python\nProduct.objects.create(name=\"p1\",\n                       description=\"description of this product\",\n                       price=0.99)\n```\n\n但是通过关键字参数创建数据会存在一些问题:\n\n* 在编码时没有代码提示,需要纯手动键入, 容易出现错误\n* 在通过重命名进行重构字段时, 关键字参数不会被重命名, 导致引发异常\n\n因此建议在任何时候都实用对象赋值的方式进行数据添加\n\n## 更新数据\n\n与添加数据的操作类似, 仅需要通过`id`或者其他字段确定需要更新的数据, 然后修改其对应的数据并`save()`即可, 如:\n\n```python\n# 更新id位2的数据的name字段\np = Product(pk=2)\np.name = \"update product name\"\np.save()\n```\n\n但在实际运行中会出现问题, 因为p对象的其他字段的值皆为`None`, 如果表存在非空约束的字段, 那么会直接报错, 如果没有非空约束, 那么原始数据会被更新为空.\n\n因此, 正确的更新方式应该是优先通过ORM获取原始数据, 以保证所有的字段数据都在ORM对象之中, 然后更新其中的数据, 代码如下:\n\n```python\np = Product.objects.get(pk=2)\np.name = \"update product name\"\np.save()\n```\n\n对应的SQL\n\n```sql\nSELECT `playground_product`.`id`,\n       `playground_product`.`name`,\n       `playground_product`.`description`,\n       `playground_product`.`price`,\n       `playground_product`.`create_at`\n  FROM `playground_product`\n WHERE `playground_product`.`id` = 2\n LIMIT 21\n\nUPDATE `playground_product`\n   SET `name` = 'update product name',\n        -- 以下为数据库中的原始数据\n       `description` = 'description of this product',\n       `price` = 0.99,\n       `create_at` = '2023-11-08 12:09:37.122549'\n WHERE `playground_product`.`id` = 2\n```\n\n为了避免额外进行一次数据库读取的操作,可以通过`update`方法直接进行更新\n\n```python\nProduct.objects.filter(pk=2).update(name=\"new name by update\")\n```\n\n对应的SQL\n\n```sql\nUPDATE `playground_product`\n   SET `name` = 'new name by update'\n WHERE `playground_product`.`id` = 2\n```\n\n没有前置的数据读取, 也没有额外的数据写入, 但是仅有一个问题. 就是在对字段名进行重命名重构时关键字参数不会被重构, 从而存在出现bug的风险.\n\n## 删除数据\n\n直接通过ORM对象删除或者通过查询删除皆可, 如:\n\n```python\nProduct(pk=1).delete()\n\nProduct.objects.filter(pk__lt=100).delete()\n```\n\n## 事务(Transection)管理\n\n多条数据库操作一并执行, 要么全部成功, 要么全部失败\n\n```python\nfrom django.db import transaction\n\n# 装饰函数的所有内容放入同一个事务中进行管理\n@transaction.atomic()\ndef test_transaction():\n    p1 = Product()\n    p1.name = \"new product\"\n    p1.description = \"insert in transaction\"\n    p1.price = 1.2\n    p1.save()\n\n    p2 = Product(pk=3)\n    p2.name = \"new product\"\n    p2.description = 'already in database'\n    p2.price = 5\n    p2.save()\n```\n\n由于p2已经存在于数据库中, 相当于执行了update操作, 但是存在非空字段, 故而更新失败.\n\n所以同属一个事务的p1也不会保存到数据库中\n\n也可以对方法的部分内容进行事务管理, 如下:\n\n```python\ndef test_transaction():\n    # some code...\n    with transaction.atomic():\n        p1 = Product()\n        p1.name = \"new product\"\n        p1.description = \"insert in transaction\"\n        p1.price = 1.2\n        p1.save()\n\n        p2 = Product(pk=3)\n        p2.name = \"new product\"\n        p2.description = 'already in database'\n        p2.price = 5\n        p2.save()\n```\n\n## 执行原生SQL\n\n可以通过ORM对象直接调用原生SQL语句\n\n```python\nquery_set = Product.objects.raw(\"select * from playground_product\")\n```\n\n对应的SQL\n\n```sql\nselect *\n  from playground_product\n```\n\n对于简单的SQL语句完全没有必要, Django orm可以很好的生成这些语句\n\n但是某些情况下, 需要处理的查询比较复杂, 通过orm编写较为困难,或者容易产生性能瓶颈, 便可以直接通过原生SQL语句进行优化.\n\n对于执行原生SQL的情况, ORM模型并非是必须的环节, 可以直接通过数据库直连来执行, 如下:\n\n```python\nfrom django.db import connection\n\ncursor = connection.cursor()\ncursor.execute(\"select * from playground_product\")\ncursor.close()\n\n# 由于cursor必须手动关闭, 通常结合with一同使用\nwith connection.cursor() as cursor:\n    # 执行sql语句\n    cursor.execute(\"select * from playground_product\")\n    # 执行存储过程\n    cursor.callproc('get_product', [1, 2, 3])\n```\n","slug":"django-4-use-django-orm","published":1,"updated":"2023-12-13T08:41:08.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v1001bi3eravg9ei7t","content":"<p>django orm的基本用法:</p>\n<pre><code class=\"python\">from characters.models import Character\nquery = Character.objects.all()\n</code></pre>\n<p>通过直接调用模型类的objects成员的对应方法即可创建查询对象</p>\n<p>所创建的查询对象是延迟加载的,  以此来方便进行符合查询,如:</p>\n<pre><code class=\"python\">Character.objects.all().order_by(&#39;level&#39;)\n</code></pre>\n<p>只有当确定读取数据的时候才会真正进行数据库查询, 如</p>\n<pre><code class=\"python\">list(query)\nquery[0:5]\n</code></pre>\n<p>即可以减少和服务器交互的次数, 也可以减少内存占用.</p>\n<h2 id=\"查询对象\"><a href=\"#查询对象\" class=\"headerlink\" title=\"查询对象\"></a>查询对象</h2><h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><pre><code class=\"python\">character = Character.objects.get(pk=1)\n</code></pre>\n<p>如果id不存在, 则会引发异常, 因此需要为其进行异常处理</p>\n<pre><code class=\"python\">from django.core.exceptions import ObjectDoesNotExist\n\ntry:\n    obj = Character.objects.get(pk=pk)\nexcept ObjectDoesNotExist:\n    pass\n</code></pre>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h3><pre><code class=\"python\"># 作用于get()想通, 区别在于不需要异常处理\nCharacter.objects.filter(pk=pk).first()\n</code></pre>\n<p>filter()方法可以接收模型类所包含字段的过滤器, 其格式为:</p>\n<pre><code class=\"python\">filedname__lookup=value\n</code></pre>\n<p>比如<code>name</code>字段包含<code>woo</code>的行,就可以写成</p>\n<pre><code class=\"python\">query_set = Character.objects.filter(name__contains=&quot;woo&quot;)\n\n# __contains代表包含, __icontains代表忽略大小写包含\n</code></pre>\n<h4 id=\"常用过滤器lookup\"><a href=\"#常用过滤器lookup\" class=\"headerlink\" title=\"常用过滤器lookup\"></a>常用过滤器lookup</h4><ul>\n<li><code>range</code>: 查询范围, __range&#x3D;(10,20)</li>\n<li><code>contains</code>,<code>icontains</code>:包含关键字</li>\n<li><code>in</code>,<code>gt</code>,<code>gte</code>,<code>lt</code>,<code>lte</code>: 在范围内, &gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;</li>\n<li><code>start/endwith</code>:以xxx开始或结尾的,同样可以使用<code>i</code>前缀忽略大小写</li>\n<li><code>isnull</code>: 空值判断</li>\n<li><code>regex</code>:正则</li>\n</ul>\n<p>等等, 详细文档连线:<a href=\"https://docs.djangoproject.com/en/4.2/ref/models/querysets/#field-lookups\">QuerySet API</a></p>\n<h4 id=\"复合查询\"><a href=\"#复合查询\" class=\"headerlink\" title=\"复合查询\"></a>复合查询</h4><p>可以向filter()传递多个关键字参数,以实现符合查询,如:</p>\n<pre><code class=\"python\"># health &gt; 50k and ap &gt; 10k\nquery_set = Character.objects.filter(health__gt=50000,\n                                         attack_power__gt=10000)\n\n# 也可以写成\nquery_set = Character.objects.filter(health__gt=50000).filter(attack_power__gt=100000)\n</code></pre>\n<p>对应的SQL:</p>\n<pre><code class=\"sql\">SELECT *\n  FROM `characters_character`\n WHERE (`characters_character`.`attack_power` &gt; 10000 AND `characters_character`.`health` &gt; 50000)\n</code></pre>\n<h4 id=\"使用Q进行复合逻辑查询\"><a href=\"#使用Q进行复合逻辑查询\" class=\"headerlink\" title=\"使用Q进行复合逻辑查询\"></a>使用<code>Q</code>进行复合逻辑查询</h4><p>django提供一个专用来处理查询条件的类<code>Q</code>, 每一个<code>Q</code>对象对应一个查询条件, 在多个<code>Q</code>对象之间可以使用逻辑运算符进行链接, 通常用来处理<code>OR</code>和<code>NOT</code> 关键字的查询, 如</p>\n<pre><code class=\"python\">query_set = Character.objects.filter(Q(health__gt=50000) &amp;\n                                         Q(health__lt=70000))\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">SELECT *\n  FROM `characters_character`\n WHERE (`characters_character`.`health` &gt; 50000 AND `characters_character`.`health` &lt; 70000)\n</code></pre>\n<p>或者:</p>\n<pre><code class=\"python\">query_set = Character.objects.filter(Q(attack_power__lt=50000) |\n                                         ~Q(health__gt=50000))\n</code></pre>\n<p>对应的SQL:</p>\n<pre><code class=\"sql\">SELECT *\n  FROM `characters_character`\n WHERE (`characters_character`.`attack_power` &lt; 50000 OR NOT (`characters_character`.`health` &gt; 50000))\n</code></pre>\n<h4 id=\"使用F对象进行查询\"><a href=\"#使用F对象进行查询\" class=\"headerlink\" title=\"使用F对象进行查询\"></a>使用F对象进行查询</h4><p>F代表字段引用, 在查询条件为表中某个字段的值时使用, 如:</p>\n<pre><code class=\"python\">query_set = Character.objects.filter(attack_power__gt=F(&#39;defense&#39;))\n</code></pre>\n<p>对应的SQL:</p>\n<pre><code class=\"sql\">SELECT *\n  FROM `characters_character`\n WHERE `characters_character`.`attack_power` &gt; (`characters_character`.`defense`)\n</code></pre>\n<p>在关联字段查询时经常用到<code>F</code>对象</p>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>通过<code>order_by</code>方法来对结果集进行排序, 直接输入字段名为正序, 添加<code>-</code>为倒序, 并且可以依据多个字段进行排序, 如:</p>\n<pre><code class=\"python\"># 基于等级倒序, 按名称正序排列\nquery_set = Character.objects.order_by(&#39;-level&#39;, &#39;name&#39;)\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">SELECT *\n  FROM `characters_character`\n ORDER BY `characters_character`.`level` DESC,\n          `characters_character`.`name` ASC\n</code></pre>\n<p><code>reverse()</code> 反转排序条件</p>\n<h3 id=\"分页\"><a href=\"#分页\" class=\"headerlink\" title=\"分页\"></a>分页</h3><p>django中的分页十分方便, 直接使用python的切片语法即可, 如:</p>\n<pre><code class=\"python\">def characters_ap_ranking_list(page, page_count=10):\n    query_set = Character.objects.order_by(&#39;-attack_power&#39;)\n    return query_set[page_count*(page-1):page_count * page]\n</code></pre>\n<p>对应的SQL:</p>\n<pre><code class=\"sql\">SELECT *\n  FROM `characters_character`\n ORDER BY `characters_character`.`attack_power` DESC\n LIMIT 10\nOFFSET 20\n</code></pre>\n<h3 id=\"指定数据与关联查询\"><a href=\"#指定数据与关联查询\" class=\"headerlink\" title=\"指定数据与关联查询\"></a>指定数据与关联查询</h3><p>通过<code>values()</code>方法可以指定要进行查询的字段, 而非获取所有字段的数据以提升效率, 如</p>\n<pre><code class=\"python\">query_set = Character.objects.filter(id__lt=10).values(&#39;name&#39;, &#39;level&#39;)\n</code></pre>\n<p>对应SQL</p>\n<pre><code class=\"sql\">SELECT `characters_character`.`name`,\n       `characters_character`.`level`\n  FROM `characters_character`\n WHERE `characters_character`.`id` &lt; 10\n</code></pre>\n<p>同时可以进行关联查询, 在model1中存在外键关联到model2, 则可以直接通过改外键查询到关联表的字段值,如:</p>\n<pre><code class=\"python\"># 其中 Character 模型存在一个外键, 对应 Club 类\n# club = models.ForeignKey(Club, on_delete=models.SET_NULL, null=True)\n\nquery_set = Character.objects.filter(id__lt=10)\nquery_set = query_set.values(&#39;name&#39;, &#39;level&#39;, &#39;club__name&#39;)\n</code></pre>\n<p>对应SQL</p>\n<pre><code class=\"sql\">SELECT `characters_character`.`name`,\n       `characters_character`.`level`,\n       `characters_club`.`name`\n  FROM `characters_character`\n  LEFT OUTER JOIN `characters_club`\n    ON (`characters_character`.`club_id` = `characters_club`.`id`)\n WHERE `characters_character`.`id` &lt; 10\n</code></pre>\n<p><code>values()</code>指定的字段名将直接作为查询结果ORM对象的字段名, 查询打印结果如下:</p>\n<pre><code class=\"zsh\">&lt;QuerySet [\n&#123;&#39;name&#39;: &#39;Alec Rois&#39;, &#39;level&#39;: 95, &#39;club__name&#39;: &#39;Harris-Towne&#39;&#125;, \n&#123;&#39;name&#39;: &#39;Fairlie Champagne&#39;, &#39;level&#39;: 219, &#39;club__name&#39;: &#39;Lesch-Jacobson&#39;&#125;,\n&#123;&#39;name&#39;: &#39;Gard Scargill&#39;, &#39;level&#39;: 218, &#39;club__name&#39;: &#39;Goldner-Kris&#39;&#125;, \n&#123;&#39;name&#39;: &#39;Bordie Domingues&#39;, &#39;level&#39;: 6, &#39;club__name&#39;: &#39;Harris-Towne&#39;&#125;, \n&#123;&#39;name&#39;: &#39;Renate Lamlin&#39;, &#39;level&#39;: 54, &#39;club__name&#39;: &#39;Huels, Wintheiser and Wisozk&#39;&#125;, \n&#123;&#39;name&#39;: &#39;Marsha Pellatt&#39;, &#39;level&#39;: 173, &#39;club__name&#39;: &#39;Skiles, Heathcote and Leannon&#39;&#125;, \n&#123;&#39;name&#39;: &#39;Luella Jakeway&#39;, &#39;level&#39;: 200, &#39;club__name&#39;: &#39;Skiles, Heathcote and Leannon&#39;&#125;, \n&#123;&#39;name&#39;: &#39;Gustavus Colliber&#39;, &#39;level&#39;: 80, &#39;club__name&#39;: &#39;Reinger LLC&#39;&#125;, \n&#123;&#39;name&#39;: &#39;Araldo Prosh&#39;, &#39;level&#39;: 193, &#39;club__name&#39;: &#39;Lesch-Jacobson&#39;&#125;]&gt;\n</code></pre>\n<p><code>values()</code> 方法返回的是词典集合, 而不是orm对象集合, 参数列表便是词典的<code>key</code></p>\n<p><code>values_list()</code>: 方法则是返回包含全部值的元组, 即没有字段名, 仅有数据</p>\n<p>** <code>only()</code>: 方法的效果与values()类似, 区别在于返回的不是词典, 而是模型对象, 也就具备后续操作的能力, 如果通过模型对象获取一个没有在only查询中列出的字段, 则会自动进行额外的数据库查询.</p>\n<h3 id=\"distinct去重\"><a href=\"#distinct去重\" class=\"headerlink\" title=\"distinct去重\"></a>distinct去重</h3><p>通过<code>distinct()</code>方法可以去除重复的数据行, 如</p>\n<pre><code class=\"python\">query_set = Character.objects.values(&#39;level&#39;).distinct().order_by(&#39;level&#39;)\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">SELECT DISTINCT `characters_character`.`level`\n  FROM `characters_character`\n ORDER BY `characters_character`.`level` ASC\n</code></pre>\n<p>去重操作可以用来确定一个范围, 比如:</p>\n<pre><code class=\"python\"># 在人物表字段`club_id`上进行去重查询\nquery_set = Character.objects.values(&#39;club_id&#39;).distinct()\n# 查询club表, 并以上述查询作为范围, 以获取包含任务的club\nclub_set = Club.objects.filter(id__in=query_set)\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">SELECT *\n  FROM `characters_club`\n WHERE `characters_club`.`id` IN (\n        SELECT DISTINCT U0.`club_id`\n          FROM `characters_character` U0\n       )\n</code></pre>\n<h3 id=\"预加载数据\"><a href=\"#预加载数据\" class=\"headerlink\" title=\"预加载数据\"></a>预加载数据</h3><p>django在获取orm对象时, 默认只加载当前表的数据, 对于外链表的数据并不会载入, 但是依然可以通过数据模型直接进行关联查询, 如</p>\n<pre><code class=\"python\"># views.py\nquery_set = Character.objects.all()\n</code></pre>\n<p>在模板页面中通过orm对象获取关联表数据:</p>\n<pre><code class=\"html\"># template.html\n&lt;td&gt;&#123;&#123;obj.club.name&#125;&#125;&lt;/td&gt;\n</code></pre>\n<p>此时, 代码不会出现任何问题, 但是会产生大量额外用来查询关联表的SQL</p>\n<pre><code class=\"sql\">SELECT *\n  FROM `characters_character`\n        --由于关联查询而产生的额外sql\nSELECT `characters_club`.`id`,\n        --fields ...\n  FROM `characters_club`\n WHERE `characters_club`.`id` = 26\n LIMIT 21\n \nSELECT `characters_club`.`id`,\n        --fields ...\n  FROM `characters_club`\n WHERE `characters_club`.`id` = 5\n LIMIT 21\n \n --...\n</code></pre>\n<p>为了解决这一问题, 可以使用预加载</p>\n<pre><code class=\"python\">query_set = Character.objects.select_related(&#39;club&#39;).all()\n</code></pre>\n<p>对应的SQL:</p>\n<pre><code class=\"sql\">SELECT -- fields ...\n       `characters_club`.`id`,\n       `characters_club`.`name`,\n        -- fields ...\n  FROM `characters_character`\n  LEFT OUTER JOIN `characters_club`\n    ON (`characters_character`.`club_id` = `characters_club`.`id`)\n</code></pre>\n<p>如此渲染同样的模板便不会产生额外的sql查询了</p>\n<p><code>select_related</code>: 用于加载多一或者一对一的关系</p>\n<p><code>prefetch_related</code>:用于加载多对多</p>\n<h3 id=\"数据统计\"><a href=\"#数据统计\" class=\"headerlink\" title=\"数据统计\"></a>数据统计</h3><p>通过<code>aggreate</code>方法来进行数据统计</p>\n<pre><code class=\"python\">from django.db.models.aggregates import Count, Max, Min, Avg\n\nresult = Character.objects.aggregate(count=Count(&#39;name&#39;),\n                                         avg_level=Avg(&#39;level&#39;),\n                                         max_ap=Max(&#39;attack_power&#39;),\n                                         min_health=Min(&#39;health&#39;))\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">SELECT COUNT(`characters_character`.`name`) AS `count`,\n       AVG(`characters_character`.`level`) AS `avg_level`,\n       MAX(`characters_character`.`attack_power`) AS `max_ap`,\n       MIN(`characters_character`.`health`) AS `min_health`\n  FROM `characters_character`\n</code></pre>\n<h3 id=\"添加注解字段\"><a href=\"#添加注解字段\" class=\"headerlink\" title=\"添加注解字段\"></a>添加注解字段</h3><p>可以通过<code>annotate()</code>方法在结果集中加入自定义的字段,如</p>\n<pre><code class=\"python\">from django.db.models import F, Value\n\n# 注解字段的值不能使基本类型, 必须是表达式对象\n# 可以是`Value`, `F`, `Func`, `Aggregate`\ntemp = Character.objects.filter(level=254).values(\n    &#39;id&#39;, &#39;name&#39;, &#39;level&#39;\n).annotate(\n    max_level=Value(True)\n).annotate(\n    test=Value(&quot;test&quot;)\n).annotate(\n    club_owner_id=F(&#39;club__owner&#39;)\n).annotate(\n    club_owner_name=F(&#39;club__owner__name&#39;)\n).annotate(\n    ap_avg_dev=F(&#39;attack_power&#39;) - avg_attack_power[&#39;avg_ap&#39;]\n)\n</code></pre>\n<p>对应的sql</p>\n<pre><code class=\"sql\">SELECT `characters_character`.`id`,\n       `characters_character`.`name`,\n       `characters_character`.`level`,\n       1 AS `max_level`,\n       &#39;test&#39; AS `test`,\n       `characters_club`.`owner_id` AS `club_owner_id`,\n       T3.`name` AS `club_owner_name`,\n       (`characters_character`.`attack_power` - 50049.574e0) AS `ap_avg_dev`\n  FROM `characters_character`\n  LEFT OUTER JOIN `characters_club`\n    ON (`characters_character`.`club_id` = `characters_club`.`id`)\n  LEFT OUTER JOIN `characters_character` T3\n    ON (`characters_club`.`owner_id` = T3.`id`)\n WHERE `characters_character`.`level` = 254\n</code></pre>\n<h2 id=\"添加数据\"><a href=\"#添加数据\" class=\"headerlink\" title=\"添加数据\"></a>添加数据</h2><p>django的数据添加可以直接通过模型对象完成, 如:</p>\n<pre><code class=\"python\">  p = Product()\n  p.name = &quot;some product&quot;\n  p.description = &quot;description of this product...&quot;\n  p.price = 0.99\n  p.save()\n</code></pre>\n<p>也可以通过模型类的构造函数或者使用create语句:</p>\n<pre><code class=\"python\">Product.objects.create(name=&quot;p1&quot;,\n                       description=&quot;description of this product&quot;,\n                       price=0.99)\n</code></pre>\n<p>但是通过关键字参数创建数据会存在一些问题:</p>\n<ul>\n<li>在编码时没有代码提示,需要纯手动键入, 容易出现错误</li>\n<li>在通过重命名进行重构字段时, 关键字参数不会被重命名, 导致引发异常</li>\n</ul>\n<p>因此建议在任何时候都实用对象赋值的方式进行数据添加</p>\n<h2 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h2><p>与添加数据的操作类似, 仅需要通过<code>id</code>或者其他字段确定需要更新的数据, 然后修改其对应的数据并<code>save()</code>即可, 如:</p>\n<pre><code class=\"python\"># 更新id位2的数据的name字段\np = Product(pk=2)\np.name = &quot;update product name&quot;\np.save()\n</code></pre>\n<p>但在实际运行中会出现问题, 因为p对象的其他字段的值皆为<code>None</code>, 如果表存在非空约束的字段, 那么会直接报错, 如果没有非空约束, 那么原始数据会被更新为空.</p>\n<p>因此, 正确的更新方式应该是优先通过ORM获取原始数据, 以保证所有的字段数据都在ORM对象之中, 然后更新其中的数据, 代码如下:</p>\n<pre><code class=\"python\">p = Product.objects.get(pk=2)\np.name = &quot;update product name&quot;\np.save()\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">SELECT `playground_product`.`id`,\n       `playground_product`.`name`,\n       `playground_product`.`description`,\n       `playground_product`.`price`,\n       `playground_product`.`create_at`\n  FROM `playground_product`\n WHERE `playground_product`.`id` = 2\n LIMIT 21\n\nUPDATE `playground_product`\n   SET `name` = &#39;update product name&#39;,\n        -- 以下为数据库中的原始数据\n       `description` = &#39;description of this product&#39;,\n       `price` = 0.99,\n       `create_at` = &#39;2023-11-08 12:09:37.122549&#39;\n WHERE `playground_product`.`id` = 2\n</code></pre>\n<p>为了避免额外进行一次数据库读取的操作,可以通过<code>update</code>方法直接进行更新</p>\n<pre><code class=\"python\">Product.objects.filter(pk=2).update(name=&quot;new name by update&quot;)\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">UPDATE `playground_product`\n   SET `name` = &#39;new name by update&#39;\n WHERE `playground_product`.`id` = 2\n</code></pre>\n<p>没有前置的数据读取, 也没有额外的数据写入, 但是仅有一个问题. 就是在对字段名进行重命名重构时关键字参数不会被重构, 从而存在出现bug的风险.</p>\n<h2 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h2><p>直接通过ORM对象删除或者通过查询删除皆可, 如:</p>\n<pre><code class=\"python\">Product(pk=1).delete()\n\nProduct.objects.filter(pk__lt=100).delete()\n</code></pre>\n<h2 id=\"事务-Transection-管理\"><a href=\"#事务-Transection-管理\" class=\"headerlink\" title=\"事务(Transection)管理\"></a>事务(Transection)管理</h2><p>多条数据库操作一并执行, 要么全部成功, 要么全部失败</p>\n<pre><code class=\"python\">from django.db import transaction\n\n# 装饰函数的所有内容放入同一个事务中进行管理\n@transaction.atomic()\ndef test_transaction():\n    p1 = Product()\n    p1.name = &quot;new product&quot;\n    p1.description = &quot;insert in transaction&quot;\n    p1.price = 1.2\n    p1.save()\n\n    p2 = Product(pk=3)\n    p2.name = &quot;new product&quot;\n    p2.description = &#39;already in database&#39;\n    p2.price = 5\n    p2.save()\n</code></pre>\n<p>由于p2已经存在于数据库中, 相当于执行了update操作, 但是存在非空字段, 故而更新失败.</p>\n<p>所以同属一个事务的p1也不会保存到数据库中</p>\n<p>也可以对方法的部分内容进行事务管理, 如下:</p>\n<pre><code class=\"python\">def test_transaction():\n    # some code...\n    with transaction.atomic():\n        p1 = Product()\n        p1.name = &quot;new product&quot;\n        p1.description = &quot;insert in transaction&quot;\n        p1.price = 1.2\n        p1.save()\n\n        p2 = Product(pk=3)\n        p2.name = &quot;new product&quot;\n        p2.description = &#39;already in database&#39;\n        p2.price = 5\n        p2.save()\n</code></pre>\n<h2 id=\"执行原生SQL\"><a href=\"#执行原生SQL\" class=\"headerlink\" title=\"执行原生SQL\"></a>执行原生SQL</h2><p>可以通过ORM对象直接调用原生SQL语句</p>\n<pre><code class=\"python\">query_set = Product.objects.raw(&quot;select * from playground_product&quot;)\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">select *\n  from playground_product\n</code></pre>\n<p>对于简单的SQL语句完全没有必要, Django orm可以很好的生成这些语句</p>\n<p>但是某些情况下, 需要处理的查询比较复杂, 通过orm编写较为困难,或者容易产生性能瓶颈, 便可以直接通过原生SQL语句进行优化.</p>\n<p>对于执行原生SQL的情况, ORM模型并非是必须的环节, 可以直接通过数据库直连来执行, 如下:</p>\n<pre><code class=\"python\">from django.db import connection\n\ncursor = connection.cursor()\ncursor.execute(&quot;select * from playground_product&quot;)\ncursor.close()\n\n# 由于cursor必须手动关闭, 通常结合with一同使用\nwith connection.cursor() as cursor:\n    # 执行sql语句\n    cursor.execute(&quot;select * from playground_product&quot;)\n    # 执行存储过程\n    cursor.callproc(&#39;get_product&#39;, [1, 2, 3])\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>django orm的基本用法:</p>\n<pre><code class=\"python\">from characters.models import Character\nquery = Character.objects.all()\n</code></pre>\n<p>通过直接调用模型类的objects成员的对应方法即可创建查询对象</p>\n<p>所创建的查询对象是延迟加载的,  以此来方便进行符合查询,如:</p>\n<pre><code class=\"python\">Character.objects.all().order_by(&#39;level&#39;)\n</code></pre>\n<p>只有当确定读取数据的时候才会真正进行数据库查询, 如</p>\n<pre><code class=\"python\">list(query)\nquery[0:5]\n</code></pre>\n<p>即可以减少和服务器交互的次数, 也可以减少内存占用.</p>\n<h2 id=\"查询对象\"><a href=\"#查询对象\" class=\"headerlink\" title=\"查询对象\"></a>查询对象</h2><h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><pre><code class=\"python\">character = Character.objects.get(pk=1)\n</code></pre>\n<p>如果id不存在, 则会引发异常, 因此需要为其进行异常处理</p>\n<pre><code class=\"python\">from django.core.exceptions import ObjectDoesNotExist\n\ntry:\n    obj = Character.objects.get(pk=pk)\nexcept ObjectDoesNotExist:\n    pass\n</code></pre>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h3><pre><code class=\"python\"># 作用于get()想通, 区别在于不需要异常处理\nCharacter.objects.filter(pk=pk).first()\n</code></pre>\n<p>filter()方法可以接收模型类所包含字段的过滤器, 其格式为:</p>\n<pre><code class=\"python\">filedname__lookup=value\n</code></pre>\n<p>比如<code>name</code>字段包含<code>woo</code>的行,就可以写成</p>\n<pre><code class=\"python\">query_set = Character.objects.filter(name__contains=&quot;woo&quot;)\n\n# __contains代表包含, __icontains代表忽略大小写包含\n</code></pre>\n<h4 id=\"常用过滤器lookup\"><a href=\"#常用过滤器lookup\" class=\"headerlink\" title=\"常用过滤器lookup\"></a>常用过滤器lookup</h4><ul>\n<li><code>range</code>: 查询范围, __range&#x3D;(10,20)</li>\n<li><code>contains</code>,<code>icontains</code>:包含关键字</li>\n<li><code>in</code>,<code>gt</code>,<code>gte</code>,<code>lt</code>,<code>lte</code>: 在范围内, &gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;</li>\n<li><code>start/endwith</code>:以xxx开始或结尾的,同样可以使用<code>i</code>前缀忽略大小写</li>\n<li><code>isnull</code>: 空值判断</li>\n<li><code>regex</code>:正则</li>\n</ul>\n<p>等等, 详细文档连线:<a href=\"https://docs.djangoproject.com/en/4.2/ref/models/querysets/#field-lookups\">QuerySet API</a></p>\n<h4 id=\"复合查询\"><a href=\"#复合查询\" class=\"headerlink\" title=\"复合查询\"></a>复合查询</h4><p>可以向filter()传递多个关键字参数,以实现符合查询,如:</p>\n<pre><code class=\"python\"># health &gt; 50k and ap &gt; 10k\nquery_set = Character.objects.filter(health__gt=50000,\n                                         attack_power__gt=10000)\n\n# 也可以写成\nquery_set = Character.objects.filter(health__gt=50000).filter(attack_power__gt=100000)\n</code></pre>\n<p>对应的SQL:</p>\n<pre><code class=\"sql\">SELECT *\n  FROM `characters_character`\n WHERE (`characters_character`.`attack_power` &gt; 10000 AND `characters_character`.`health` &gt; 50000)\n</code></pre>\n<h4 id=\"使用Q进行复合逻辑查询\"><a href=\"#使用Q进行复合逻辑查询\" class=\"headerlink\" title=\"使用Q进行复合逻辑查询\"></a>使用<code>Q</code>进行复合逻辑查询</h4><p>django提供一个专用来处理查询条件的类<code>Q</code>, 每一个<code>Q</code>对象对应一个查询条件, 在多个<code>Q</code>对象之间可以使用逻辑运算符进行链接, 通常用来处理<code>OR</code>和<code>NOT</code> 关键字的查询, 如</p>\n<pre><code class=\"python\">query_set = Character.objects.filter(Q(health__gt=50000) &amp;\n                                         Q(health__lt=70000))\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">SELECT *\n  FROM `characters_character`\n WHERE (`characters_character`.`health` &gt; 50000 AND `characters_character`.`health` &lt; 70000)\n</code></pre>\n<p>或者:</p>\n<pre><code class=\"python\">query_set = Character.objects.filter(Q(attack_power__lt=50000) |\n                                         ~Q(health__gt=50000))\n</code></pre>\n<p>对应的SQL:</p>\n<pre><code class=\"sql\">SELECT *\n  FROM `characters_character`\n WHERE (`characters_character`.`attack_power` &lt; 50000 OR NOT (`characters_character`.`health` &gt; 50000))\n</code></pre>\n<h4 id=\"使用F对象进行查询\"><a href=\"#使用F对象进行查询\" class=\"headerlink\" title=\"使用F对象进行查询\"></a>使用F对象进行查询</h4><p>F代表字段引用, 在查询条件为表中某个字段的值时使用, 如:</p>\n<pre><code class=\"python\">query_set = Character.objects.filter(attack_power__gt=F(&#39;defense&#39;))\n</code></pre>\n<p>对应的SQL:</p>\n<pre><code class=\"sql\">SELECT *\n  FROM `characters_character`\n WHERE `characters_character`.`attack_power` &gt; (`characters_character`.`defense`)\n</code></pre>\n<p>在关联字段查询时经常用到<code>F</code>对象</p>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>通过<code>order_by</code>方法来对结果集进行排序, 直接输入字段名为正序, 添加<code>-</code>为倒序, 并且可以依据多个字段进行排序, 如:</p>\n<pre><code class=\"python\"># 基于等级倒序, 按名称正序排列\nquery_set = Character.objects.order_by(&#39;-level&#39;, &#39;name&#39;)\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">SELECT *\n  FROM `characters_character`\n ORDER BY `characters_character`.`level` DESC,\n          `characters_character`.`name` ASC\n</code></pre>\n<p><code>reverse()</code> 反转排序条件</p>\n<h3 id=\"分页\"><a href=\"#分页\" class=\"headerlink\" title=\"分页\"></a>分页</h3><p>django中的分页十分方便, 直接使用python的切片语法即可, 如:</p>\n<pre><code class=\"python\">def characters_ap_ranking_list(page, page_count=10):\n    query_set = Character.objects.order_by(&#39;-attack_power&#39;)\n    return query_set[page_count*(page-1):page_count * page]\n</code></pre>\n<p>对应的SQL:</p>\n<pre><code class=\"sql\">SELECT *\n  FROM `characters_character`\n ORDER BY `characters_character`.`attack_power` DESC\n LIMIT 10\nOFFSET 20\n</code></pre>\n<h3 id=\"指定数据与关联查询\"><a href=\"#指定数据与关联查询\" class=\"headerlink\" title=\"指定数据与关联查询\"></a>指定数据与关联查询</h3><p>通过<code>values()</code>方法可以指定要进行查询的字段, 而非获取所有字段的数据以提升效率, 如</p>\n<pre><code class=\"python\">query_set = Character.objects.filter(id__lt=10).values(&#39;name&#39;, &#39;level&#39;)\n</code></pre>\n<p>对应SQL</p>\n<pre><code class=\"sql\">SELECT `characters_character`.`name`,\n       `characters_character`.`level`\n  FROM `characters_character`\n WHERE `characters_character`.`id` &lt; 10\n</code></pre>\n<p>同时可以进行关联查询, 在model1中存在外键关联到model2, 则可以直接通过改外键查询到关联表的字段值,如:</p>\n<pre><code class=\"python\"># 其中 Character 模型存在一个外键, 对应 Club 类\n# club = models.ForeignKey(Club, on_delete=models.SET_NULL, null=True)\n\nquery_set = Character.objects.filter(id__lt=10)\nquery_set = query_set.values(&#39;name&#39;, &#39;level&#39;, &#39;club__name&#39;)\n</code></pre>\n<p>对应SQL</p>\n<pre><code class=\"sql\">SELECT `characters_character`.`name`,\n       `characters_character`.`level`,\n       `characters_club`.`name`\n  FROM `characters_character`\n  LEFT OUTER JOIN `characters_club`\n    ON (`characters_character`.`club_id` = `characters_club`.`id`)\n WHERE `characters_character`.`id` &lt; 10\n</code></pre>\n<p><code>values()</code>指定的字段名将直接作为查询结果ORM对象的字段名, 查询打印结果如下:</p>\n<pre><code class=\"zsh\">&lt;QuerySet [\n&#123;&#39;name&#39;: &#39;Alec Rois&#39;, &#39;level&#39;: 95, &#39;club__name&#39;: &#39;Harris-Towne&#39;&#125;, \n&#123;&#39;name&#39;: &#39;Fairlie Champagne&#39;, &#39;level&#39;: 219, &#39;club__name&#39;: &#39;Lesch-Jacobson&#39;&#125;,\n&#123;&#39;name&#39;: &#39;Gard Scargill&#39;, &#39;level&#39;: 218, &#39;club__name&#39;: &#39;Goldner-Kris&#39;&#125;, \n&#123;&#39;name&#39;: &#39;Bordie Domingues&#39;, &#39;level&#39;: 6, &#39;club__name&#39;: &#39;Harris-Towne&#39;&#125;, \n&#123;&#39;name&#39;: &#39;Renate Lamlin&#39;, &#39;level&#39;: 54, &#39;club__name&#39;: &#39;Huels, Wintheiser and Wisozk&#39;&#125;, \n&#123;&#39;name&#39;: &#39;Marsha Pellatt&#39;, &#39;level&#39;: 173, &#39;club__name&#39;: &#39;Skiles, Heathcote and Leannon&#39;&#125;, \n&#123;&#39;name&#39;: &#39;Luella Jakeway&#39;, &#39;level&#39;: 200, &#39;club__name&#39;: &#39;Skiles, Heathcote and Leannon&#39;&#125;, \n&#123;&#39;name&#39;: &#39;Gustavus Colliber&#39;, &#39;level&#39;: 80, &#39;club__name&#39;: &#39;Reinger LLC&#39;&#125;, \n&#123;&#39;name&#39;: &#39;Araldo Prosh&#39;, &#39;level&#39;: 193, &#39;club__name&#39;: &#39;Lesch-Jacobson&#39;&#125;]&gt;\n</code></pre>\n<p><code>values()</code> 方法返回的是词典集合, 而不是orm对象集合, 参数列表便是词典的<code>key</code></p>\n<p><code>values_list()</code>: 方法则是返回包含全部值的元组, 即没有字段名, 仅有数据</p>\n<p>** <code>only()</code>: 方法的效果与values()类似, 区别在于返回的不是词典, 而是模型对象, 也就具备后续操作的能力, 如果通过模型对象获取一个没有在only查询中列出的字段, 则会自动进行额外的数据库查询.</p>\n<h3 id=\"distinct去重\"><a href=\"#distinct去重\" class=\"headerlink\" title=\"distinct去重\"></a>distinct去重</h3><p>通过<code>distinct()</code>方法可以去除重复的数据行, 如</p>\n<pre><code class=\"python\">query_set = Character.objects.values(&#39;level&#39;).distinct().order_by(&#39;level&#39;)\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">SELECT DISTINCT `characters_character`.`level`\n  FROM `characters_character`\n ORDER BY `characters_character`.`level` ASC\n</code></pre>\n<p>去重操作可以用来确定一个范围, 比如:</p>\n<pre><code class=\"python\"># 在人物表字段`club_id`上进行去重查询\nquery_set = Character.objects.values(&#39;club_id&#39;).distinct()\n# 查询club表, 并以上述查询作为范围, 以获取包含任务的club\nclub_set = Club.objects.filter(id__in=query_set)\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">SELECT *\n  FROM `characters_club`\n WHERE `characters_club`.`id` IN (\n        SELECT DISTINCT U0.`club_id`\n          FROM `characters_character` U0\n       )\n</code></pre>\n<h3 id=\"预加载数据\"><a href=\"#预加载数据\" class=\"headerlink\" title=\"预加载数据\"></a>预加载数据</h3><p>django在获取orm对象时, 默认只加载当前表的数据, 对于外链表的数据并不会载入, 但是依然可以通过数据模型直接进行关联查询, 如</p>\n<pre><code class=\"python\"># views.py\nquery_set = Character.objects.all()\n</code></pre>\n<p>在模板页面中通过orm对象获取关联表数据:</p>\n<pre><code class=\"html\"># template.html\n&lt;td&gt;&#123;&#123;obj.club.name&#125;&#125;&lt;/td&gt;\n</code></pre>\n<p>此时, 代码不会出现任何问题, 但是会产生大量额外用来查询关联表的SQL</p>\n<pre><code class=\"sql\">SELECT *\n  FROM `characters_character`\n        --由于关联查询而产生的额外sql\nSELECT `characters_club`.`id`,\n        --fields ...\n  FROM `characters_club`\n WHERE `characters_club`.`id` = 26\n LIMIT 21\n \nSELECT `characters_club`.`id`,\n        --fields ...\n  FROM `characters_club`\n WHERE `characters_club`.`id` = 5\n LIMIT 21\n \n --...\n</code></pre>\n<p>为了解决这一问题, 可以使用预加载</p>\n<pre><code class=\"python\">query_set = Character.objects.select_related(&#39;club&#39;).all()\n</code></pre>\n<p>对应的SQL:</p>\n<pre><code class=\"sql\">SELECT -- fields ...\n       `characters_club`.`id`,\n       `characters_club`.`name`,\n        -- fields ...\n  FROM `characters_character`\n  LEFT OUTER JOIN `characters_club`\n    ON (`characters_character`.`club_id` = `characters_club`.`id`)\n</code></pre>\n<p>如此渲染同样的模板便不会产生额外的sql查询了</p>\n<p><code>select_related</code>: 用于加载多一或者一对一的关系</p>\n<p><code>prefetch_related</code>:用于加载多对多</p>\n<h3 id=\"数据统计\"><a href=\"#数据统计\" class=\"headerlink\" title=\"数据统计\"></a>数据统计</h3><p>通过<code>aggreate</code>方法来进行数据统计</p>\n<pre><code class=\"python\">from django.db.models.aggregates import Count, Max, Min, Avg\n\nresult = Character.objects.aggregate(count=Count(&#39;name&#39;),\n                                         avg_level=Avg(&#39;level&#39;),\n                                         max_ap=Max(&#39;attack_power&#39;),\n                                         min_health=Min(&#39;health&#39;))\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">SELECT COUNT(`characters_character`.`name`) AS `count`,\n       AVG(`characters_character`.`level`) AS `avg_level`,\n       MAX(`characters_character`.`attack_power`) AS `max_ap`,\n       MIN(`characters_character`.`health`) AS `min_health`\n  FROM `characters_character`\n</code></pre>\n<h3 id=\"添加注解字段\"><a href=\"#添加注解字段\" class=\"headerlink\" title=\"添加注解字段\"></a>添加注解字段</h3><p>可以通过<code>annotate()</code>方法在结果集中加入自定义的字段,如</p>\n<pre><code class=\"python\">from django.db.models import F, Value\n\n# 注解字段的值不能使基本类型, 必须是表达式对象\n# 可以是`Value`, `F`, `Func`, `Aggregate`\ntemp = Character.objects.filter(level=254).values(\n    &#39;id&#39;, &#39;name&#39;, &#39;level&#39;\n).annotate(\n    max_level=Value(True)\n).annotate(\n    test=Value(&quot;test&quot;)\n).annotate(\n    club_owner_id=F(&#39;club__owner&#39;)\n).annotate(\n    club_owner_name=F(&#39;club__owner__name&#39;)\n).annotate(\n    ap_avg_dev=F(&#39;attack_power&#39;) - avg_attack_power[&#39;avg_ap&#39;]\n)\n</code></pre>\n<p>对应的sql</p>\n<pre><code class=\"sql\">SELECT `characters_character`.`id`,\n       `characters_character`.`name`,\n       `characters_character`.`level`,\n       1 AS `max_level`,\n       &#39;test&#39; AS `test`,\n       `characters_club`.`owner_id` AS `club_owner_id`,\n       T3.`name` AS `club_owner_name`,\n       (`characters_character`.`attack_power` - 50049.574e0) AS `ap_avg_dev`\n  FROM `characters_character`\n  LEFT OUTER JOIN `characters_club`\n    ON (`characters_character`.`club_id` = `characters_club`.`id`)\n  LEFT OUTER JOIN `characters_character` T3\n    ON (`characters_club`.`owner_id` = T3.`id`)\n WHERE `characters_character`.`level` = 254\n</code></pre>\n<h2 id=\"添加数据\"><a href=\"#添加数据\" class=\"headerlink\" title=\"添加数据\"></a>添加数据</h2><p>django的数据添加可以直接通过模型对象完成, 如:</p>\n<pre><code class=\"python\">  p = Product()\n  p.name = &quot;some product&quot;\n  p.description = &quot;description of this product...&quot;\n  p.price = 0.99\n  p.save()\n</code></pre>\n<p>也可以通过模型类的构造函数或者使用create语句:</p>\n<pre><code class=\"python\">Product.objects.create(name=&quot;p1&quot;,\n                       description=&quot;description of this product&quot;,\n                       price=0.99)\n</code></pre>\n<p>但是通过关键字参数创建数据会存在一些问题:</p>\n<ul>\n<li>在编码时没有代码提示,需要纯手动键入, 容易出现错误</li>\n<li>在通过重命名进行重构字段时, 关键字参数不会被重命名, 导致引发异常</li>\n</ul>\n<p>因此建议在任何时候都实用对象赋值的方式进行数据添加</p>\n<h2 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h2><p>与添加数据的操作类似, 仅需要通过<code>id</code>或者其他字段确定需要更新的数据, 然后修改其对应的数据并<code>save()</code>即可, 如:</p>\n<pre><code class=\"python\"># 更新id位2的数据的name字段\np = Product(pk=2)\np.name = &quot;update product name&quot;\np.save()\n</code></pre>\n<p>但在实际运行中会出现问题, 因为p对象的其他字段的值皆为<code>None</code>, 如果表存在非空约束的字段, 那么会直接报错, 如果没有非空约束, 那么原始数据会被更新为空.</p>\n<p>因此, 正确的更新方式应该是优先通过ORM获取原始数据, 以保证所有的字段数据都在ORM对象之中, 然后更新其中的数据, 代码如下:</p>\n<pre><code class=\"python\">p = Product.objects.get(pk=2)\np.name = &quot;update product name&quot;\np.save()\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">SELECT `playground_product`.`id`,\n       `playground_product`.`name`,\n       `playground_product`.`description`,\n       `playground_product`.`price`,\n       `playground_product`.`create_at`\n  FROM `playground_product`\n WHERE `playground_product`.`id` = 2\n LIMIT 21\n\nUPDATE `playground_product`\n   SET `name` = &#39;update product name&#39;,\n        -- 以下为数据库中的原始数据\n       `description` = &#39;description of this product&#39;,\n       `price` = 0.99,\n       `create_at` = &#39;2023-11-08 12:09:37.122549&#39;\n WHERE `playground_product`.`id` = 2\n</code></pre>\n<p>为了避免额外进行一次数据库读取的操作,可以通过<code>update</code>方法直接进行更新</p>\n<pre><code class=\"python\">Product.objects.filter(pk=2).update(name=&quot;new name by update&quot;)\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">UPDATE `playground_product`\n   SET `name` = &#39;new name by update&#39;\n WHERE `playground_product`.`id` = 2\n</code></pre>\n<p>没有前置的数据读取, 也没有额外的数据写入, 但是仅有一个问题. 就是在对字段名进行重命名重构时关键字参数不会被重构, 从而存在出现bug的风险.</p>\n<h2 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h2><p>直接通过ORM对象删除或者通过查询删除皆可, 如:</p>\n<pre><code class=\"python\">Product(pk=1).delete()\n\nProduct.objects.filter(pk__lt=100).delete()\n</code></pre>\n<h2 id=\"事务-Transection-管理\"><a href=\"#事务-Transection-管理\" class=\"headerlink\" title=\"事务(Transection)管理\"></a>事务(Transection)管理</h2><p>多条数据库操作一并执行, 要么全部成功, 要么全部失败</p>\n<pre><code class=\"python\">from django.db import transaction\n\n# 装饰函数的所有内容放入同一个事务中进行管理\n@transaction.atomic()\ndef test_transaction():\n    p1 = Product()\n    p1.name = &quot;new product&quot;\n    p1.description = &quot;insert in transaction&quot;\n    p1.price = 1.2\n    p1.save()\n\n    p2 = Product(pk=3)\n    p2.name = &quot;new product&quot;\n    p2.description = &#39;already in database&#39;\n    p2.price = 5\n    p2.save()\n</code></pre>\n<p>由于p2已经存在于数据库中, 相当于执行了update操作, 但是存在非空字段, 故而更新失败.</p>\n<p>所以同属一个事务的p1也不会保存到数据库中</p>\n<p>也可以对方法的部分内容进行事务管理, 如下:</p>\n<pre><code class=\"python\">def test_transaction():\n    # some code...\n    with transaction.atomic():\n        p1 = Product()\n        p1.name = &quot;new product&quot;\n        p1.description = &quot;insert in transaction&quot;\n        p1.price = 1.2\n        p1.save()\n\n        p2 = Product(pk=3)\n        p2.name = &quot;new product&quot;\n        p2.description = &#39;already in database&#39;\n        p2.price = 5\n        p2.save()\n</code></pre>\n<h2 id=\"执行原生SQL\"><a href=\"#执行原生SQL\" class=\"headerlink\" title=\"执行原生SQL\"></a>执行原生SQL</h2><p>可以通过ORM对象直接调用原生SQL语句</p>\n<pre><code class=\"python\">query_set = Product.objects.raw(&quot;select * from playground_product&quot;)\n</code></pre>\n<p>对应的SQL</p>\n<pre><code class=\"sql\">select *\n  from playground_product\n</code></pre>\n<p>对于简单的SQL语句完全没有必要, Django orm可以很好的生成这些语句</p>\n<p>但是某些情况下, 需要处理的查询比较复杂, 通过orm编写较为困难,或者容易产生性能瓶颈, 便可以直接通过原生SQL语句进行优化.</p>\n<p>对于执行原生SQL的情况, ORM模型并非是必须的环节, 可以直接通过数据库直连来执行, 如下:</p>\n<pre><code class=\"python\">from django.db import connection\n\ncursor = connection.cursor()\ncursor.execute(&quot;select * from playground_product&quot;)\ncursor.close()\n\n# 由于cursor必须手动关闭, 通常结合with一同使用\nwith connection.cursor() as cursor:\n    # 执行sql语句\n    cursor.execute(&quot;select * from playground_product&quot;)\n    # 执行存储过程\n    cursor.callproc(&#39;get_product&#39;, [1, 2, 3])\n</code></pre>\n"},{"title":"9. 为已有的Django app制作插件","date":"2023-12-13T08:41:08.347Z","_content":"\n可以通过类似插件的方式将彼此时间相互独立的app通过contenttype进行结合使用\n\n1. 创建插件app\n\n   ```python\n   python manage.py startapp store_plugin \n   ```\n\n2. 编辑`store_plugin/admin.py`\n\n   ```python\n   from django.contrib import admin\n   from django.contrib.contenttypes.admin import GenericTabularInline\n   \n   from store.admin import ProductAdmin\n   from store.models import Product\n   from tags.admin import TagAdmin\n   from tags.models import TaggedItem\n   \n   \n   class TagInlin(GenericTabularInline):\n       \"\"\"\n       创建`TaggedItem`模型的内联插件\n       \"\"\"\n       autocomplete_fields = ['tag']\n       model = TaggedItem\n       extra = 0\n   \n   \n   class ProdcutPluginAdmin(ProductAdmin):\n       \"\"\"\n       继承`store`模块的ProductAdmin, 为其添加内联插件\n       \"\"\"\n       inlines = [TagInlin]\n   \n   # 注销原本的Product\n   admin.site.unregister(Product)\n   # 通过插件重新注册\n   admin.site.register(Product, ProdcutPluginAdmin)\n   \n   ```\n\n3. 载入插件\n\n   ```python\n   INSTALLED_APPS = [\n       'store',\n       'store_plugin',\n       'tags',\n   ]\n   # 如此一来可以随时通过Installed_apps打开或者关闭Tag功能\n   ```\n","source":"_posts/django/9-extending-pluggable-apps.md","raw":"---\ntitle: 9. 为已有的Django app制作插件\ndate: 2023-11-8 02:19:28 +08000\ncategories: [笔记, Django]\ntags: [python, django, backend]\n---\n\n可以通过类似插件的方式将彼此时间相互独立的app通过contenttype进行结合使用\n\n1. 创建插件app\n\n   ```python\n   python manage.py startapp store_plugin \n   ```\n\n2. 编辑`store_plugin/admin.py`\n\n   ```python\n   from django.contrib import admin\n   from django.contrib.contenttypes.admin import GenericTabularInline\n   \n   from store.admin import ProductAdmin\n   from store.models import Product\n   from tags.admin import TagAdmin\n   from tags.models import TaggedItem\n   \n   \n   class TagInlin(GenericTabularInline):\n       \"\"\"\n       创建`TaggedItem`模型的内联插件\n       \"\"\"\n       autocomplete_fields = ['tag']\n       model = TaggedItem\n       extra = 0\n   \n   \n   class ProdcutPluginAdmin(ProductAdmin):\n       \"\"\"\n       继承`store`模块的ProductAdmin, 为其添加内联插件\n       \"\"\"\n       inlines = [TagInlin]\n   \n   # 注销原本的Product\n   admin.site.unregister(Product)\n   # 通过插件重新注册\n   admin.site.register(Product, ProdcutPluginAdmin)\n   \n   ```\n\n3. 载入插件\n\n   ```python\n   INSTALLED_APPS = [\n       'store',\n       'store_plugin',\n       'tags',\n   ]\n   # 如此一来可以随时通过Installed_apps打开或者关闭Tag功能\n   ```\n","slug":"django-9-extending-pluggable-apps","published":1,"updated":"2023-12-13T08:41:08.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v1001ei3er283u9k9n","content":"<p>可以通过类似插件的方式将彼此时间相互独立的app通过contenttype进行结合使用</p>\n<ol>\n<li><p>创建插件app</p>\n<pre><code class=\"python\">python manage.py startapp store_plugin \n</code></pre>\n</li>\n<li><p>编辑<code>store_plugin/admin.py</code></p>\n<pre><code class=\"python\">from django.contrib import admin\nfrom django.contrib.contenttypes.admin import GenericTabularInline\n\nfrom store.admin import ProductAdmin\nfrom store.models import Product\nfrom tags.admin import TagAdmin\nfrom tags.models import TaggedItem\n\n\nclass TagInlin(GenericTabularInline):\n    &quot;&quot;&quot;\n    创建`TaggedItem`模型的内联插件\n    &quot;&quot;&quot;\n    autocomplete_fields = [&#39;tag&#39;]\n    model = TaggedItem\n    extra = 0\n\n\nclass ProdcutPluginAdmin(ProductAdmin):\n    &quot;&quot;&quot;\n    继承`store`模块的ProductAdmin, 为其添加内联插件\n    &quot;&quot;&quot;\n    inlines = [TagInlin]\n\n# 注销原本的Product\nadmin.site.unregister(Product)\n# 通过插件重新注册\nadmin.site.register(Product, ProdcutPluginAdmin)\n</code></pre>\n</li>\n<li><p>载入插件</p>\n<pre><code class=\"python\">INSTALLED_APPS = [\n    &#39;store&#39;,\n    &#39;store_plugin&#39;,\n    &#39;tags&#39;,\n]\n# 如此一来可以随时通过Installed_apps打开或者关闭Tag功能\n</code></pre>\n</li>\n</ol>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>可以通过类似插件的方式将彼此时间相互独立的app通过contenttype进行结合使用</p>\n<ol>\n<li><p>创建插件app</p>\n<pre><code class=\"python\">python manage.py startapp store_plugin \n</code></pre>\n</li>\n<li><p>编辑<code>store_plugin/admin.py</code></p>\n<pre><code class=\"python\">from django.contrib import admin\nfrom django.contrib.contenttypes.admin import GenericTabularInline\n\nfrom store.admin import ProductAdmin\nfrom store.models import Product\nfrom tags.admin import TagAdmin\nfrom tags.models import TaggedItem\n\n\nclass TagInlin(GenericTabularInline):\n    &quot;&quot;&quot;\n    创建`TaggedItem`模型的内联插件\n    &quot;&quot;&quot;\n    autocomplete_fields = [&#39;tag&#39;]\n    model = TaggedItem\n    extra = 0\n\n\nclass ProdcutPluginAdmin(ProductAdmin):\n    &quot;&quot;&quot;\n    继承`store`模块的ProductAdmin, 为其添加内联插件\n    &quot;&quot;&quot;\n    inlines = [TagInlin]\n\n# 注销原本的Product\nadmin.site.unregister(Product)\n# 通过插件重新注册\nadmin.site.register(Product, ProdcutPluginAdmin)\n</code></pre>\n</li>\n<li><p>载入插件</p>\n<pre><code class=\"python\">INSTALLED_APPS = [\n    &#39;store&#39;,\n    &#39;store_plugin&#39;,\n    &#39;tags&#39;,\n]\n# 如此一来可以随时通过Installed_apps打开或者关闭Tag功能\n</code></pre>\n</li>\n</ol>\n"},{"title":"15. Django 视图类","date":"2023-11-12T11:48:01.000Z","_content":"\n在之前的代码中, 所有的请求都是通过python方法来进行处理的, 这会使得项目代码可维护性很差.\n\n在实际应用中, 更多的则是使用视图类来对接口进行封装.\n\n1. `store`文件夹下创建一个新的 `views` 包.\n2. 创建两个文件`products_api.py`和`collections_api.py`\n\n并对之前的视图方法进行重构, 结果如下:\n\n```python\n\n# collections_api.py\nfrom django.shortcuts import render, get_object_or_404\nfrom django.db.models import Count\n\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework.request import Request\nfrom rest_framework import status\n\nfrom ..models import Collection\nfrom ..serializers import CollectionSerializer\n\n\nclass CollectionList(APIView):\n\n    def get(self, request: Request):\n        queryset = Collection.objects.all().annotate(products_count=Count('products'))\n        serializer = CollectionSerializer(queryset, many=True)\n        return Response(serializer.data)\n\n    def post(self, request: Request):\n        serializer = CollectionSerializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data, status=status.HTTP_201_CREATED)\n\n\nclass CollectionDetail(APIView):\n\n    def get_collection(self, pk) -> Collection:\n        return get_object_or_404(\n            Collection.objects.annotate(products_count=Count('products')), pk=pk)\n\n    def get(self, request, pk):\n        collection: Collection = self.get_collection(pk)\n        serializer = CollectionSerializer(collection)\n        return Response(serializer.data)\n\n    def put(self, request, pk):\n        collection = self.get_collection(pk)\n        serializer = CollectionSerializer(collection,\n                                          data=request.data,\n                                          partial=request.method == 'PATCH')\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    def patch(self, request, pk):\n        return self.put(request, pk)\n\n    def delete(self, request, pk):\n        collection = self.get_collection(pk)\n        if collection.products.count() > 0:\n            return Response({\"error\": \"Collection have more than one product.\"},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n        collection.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n```\n\n```python\nfrom django.shortcuts import render, get_object_or_404\n\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\n\nfrom ..serializers import ProductSerializer\nfrom ..models import Product\n\n\nclass ProductList(APIView):\n\n    def get(self, request):\n        queryset = Product.objects.all()\n        serializer = ProductSerializer(queryset, many=True,\n                                       context={'request': request})\n        return Response(serializer.data)\n\n    def post(self, request):\n        if request.method == 'POST':\n            serializer = ProductSerializer(data=request.data)\n            serializer.is_valid(raise_exception=True)\n            serializer.save()\n            print(serializer.validated_data)\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n\n\nclass ProdcutDetail(APIView):\n\n    def get(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        serializer = ProductSerializer(product)\n        return Response(serializer.data)\n\n    def put(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        serializer = ProductSerializer(product,\n                                       data=request.data,\n                                       partial=request.method == 'PATCH')\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    def patch(self, request, product_id):\n        return self.put(request, product_id)\n\n    def delete(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        if product.orderitem_set.count() > 0:\n            return Response({'error': 'Product has been ordered.'},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n```\n\n完成后的结构为`store.model_api.APIView`, 如此一来, 便可以将相关的视图方法封装到同一个python模块中统一维护\n\n同时一个雷对应了一个路由, 通过路由视图类的方法实现来确定可以接受的请求类型, 代码整体就变得清晰明了.\n\n同时, 还需要编辑`store/urls.py`配置文件, 使路由能够找到对应的视图类:\n\n```python\nfrom django.urls import path, include\nfrom .views import product_api, collection_api\n\nurlpatterns = [\n    # path('', views.index),\n    path('products/', product_api.ProductList.as_view()),\n    path('products/<int:product_id>/', product_api.ProdcutDetail.as_view()),\n    path('collections/', collection_api.CollectionList.as_view()),\n    path('collections/<int:pk>',\n         collection_api.CollectionDetail.as_view(),\n         name='collection-detail')\n]\n\n```\n","source":"_posts/django/rest-apiview.md","raw":"---\ntitle: 15. Django 视图类\ndate: 2023-11-12 19:48:01 +0800\ncategories: [笔记, Django]\ntags: [python, django, backend]\n---\n\n在之前的代码中, 所有的请求都是通过python方法来进行处理的, 这会使得项目代码可维护性很差.\n\n在实际应用中, 更多的则是使用视图类来对接口进行封装.\n\n1. `store`文件夹下创建一个新的 `views` 包.\n2. 创建两个文件`products_api.py`和`collections_api.py`\n\n并对之前的视图方法进行重构, 结果如下:\n\n```python\n\n# collections_api.py\nfrom django.shortcuts import render, get_object_or_404\nfrom django.db.models import Count\n\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework.request import Request\nfrom rest_framework import status\n\nfrom ..models import Collection\nfrom ..serializers import CollectionSerializer\n\n\nclass CollectionList(APIView):\n\n    def get(self, request: Request):\n        queryset = Collection.objects.all().annotate(products_count=Count('products'))\n        serializer = CollectionSerializer(queryset, many=True)\n        return Response(serializer.data)\n\n    def post(self, request: Request):\n        serializer = CollectionSerializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data, status=status.HTTP_201_CREATED)\n\n\nclass CollectionDetail(APIView):\n\n    def get_collection(self, pk) -> Collection:\n        return get_object_or_404(\n            Collection.objects.annotate(products_count=Count('products')), pk=pk)\n\n    def get(self, request, pk):\n        collection: Collection = self.get_collection(pk)\n        serializer = CollectionSerializer(collection)\n        return Response(serializer.data)\n\n    def put(self, request, pk):\n        collection = self.get_collection(pk)\n        serializer = CollectionSerializer(collection,\n                                          data=request.data,\n                                          partial=request.method == 'PATCH')\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    def patch(self, request, pk):\n        return self.put(request, pk)\n\n    def delete(self, request, pk):\n        collection = self.get_collection(pk)\n        if collection.products.count() > 0:\n            return Response({\"error\": \"Collection have more than one product.\"},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n        collection.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n```\n\n```python\nfrom django.shortcuts import render, get_object_or_404\n\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\n\nfrom ..serializers import ProductSerializer\nfrom ..models import Product\n\n\nclass ProductList(APIView):\n\n    def get(self, request):\n        queryset = Product.objects.all()\n        serializer = ProductSerializer(queryset, many=True,\n                                       context={'request': request})\n        return Response(serializer.data)\n\n    def post(self, request):\n        if request.method == 'POST':\n            serializer = ProductSerializer(data=request.data)\n            serializer.is_valid(raise_exception=True)\n            serializer.save()\n            print(serializer.validated_data)\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n\n\nclass ProdcutDetail(APIView):\n\n    def get(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        serializer = ProductSerializer(product)\n        return Response(serializer.data)\n\n    def put(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        serializer = ProductSerializer(product,\n                                       data=request.data,\n                                       partial=request.method == 'PATCH')\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    def patch(self, request, product_id):\n        return self.put(request, product_id)\n\n    def delete(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        if product.orderitem_set.count() > 0:\n            return Response({'error': 'Product has been ordered.'},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n```\n\n完成后的结构为`store.model_api.APIView`, 如此一来, 便可以将相关的视图方法封装到同一个python模块中统一维护\n\n同时一个雷对应了一个路由, 通过路由视图类的方法实现来确定可以接受的请求类型, 代码整体就变得清晰明了.\n\n同时, 还需要编辑`store/urls.py`配置文件, 使路由能够找到对应的视图类:\n\n```python\nfrom django.urls import path, include\nfrom .views import product_api, collection_api\n\nurlpatterns = [\n    # path('', views.index),\n    path('products/', product_api.ProductList.as_view()),\n    path('products/<int:product_id>/', product_api.ProdcutDetail.as_view()),\n    path('collections/', collection_api.CollectionList.as_view()),\n    path('collections/<int:pk>',\n         collection_api.CollectionDetail.as_view(),\n         name='collection-detail')\n]\n\n```\n","slug":"django-rest-apiview","published":1,"updated":"2023-12-13T08:41:08.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v1001fi3er667q225p","content":"<p>在之前的代码中, 所有的请求都是通过python方法来进行处理的, 这会使得项目代码可维护性很差.</p>\n<p>在实际应用中, 更多的则是使用视图类来对接口进行封装.</p>\n<ol>\n<li><code>store</code>文件夹下创建一个新的 <code>views</code> 包.</li>\n<li>创建两个文件<code>products_api.py</code>和<code>collections_api.py</code></li>\n</ol>\n<p>并对之前的视图方法进行重构, 结果如下:</p>\n<pre><code class=\"python\">\n# collections_api.py\nfrom django.shortcuts import render, get_object_or_404\nfrom django.db.models import Count\n\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework.request import Request\nfrom rest_framework import status\n\nfrom ..models import Collection\nfrom ..serializers import CollectionSerializer\n\n\nclass CollectionList(APIView):\n\n    def get(self, request: Request):\n        queryset = Collection.objects.all().annotate(products_count=Count(&#39;products&#39;))\n        serializer = CollectionSerializer(queryset, many=True)\n        return Response(serializer.data)\n\n    def post(self, request: Request):\n        serializer = CollectionSerializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data, status=status.HTTP_201_CREATED)\n\n\nclass CollectionDetail(APIView):\n\n    def get_collection(self, pk) -&gt; Collection:\n        return get_object_or_404(\n            Collection.objects.annotate(products_count=Count(&#39;products&#39;)), pk=pk)\n\n    def get(self, request, pk):\n        collection: Collection = self.get_collection(pk)\n        serializer = CollectionSerializer(collection)\n        return Response(serializer.data)\n\n    def put(self, request, pk):\n        collection = self.get_collection(pk)\n        serializer = CollectionSerializer(collection,\n                                          data=request.data,\n                                          partial=request.method == &#39;PATCH&#39;)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    def patch(self, request, pk):\n        return self.put(request, pk)\n\n    def delete(self, request, pk):\n        collection = self.get_collection(pk)\n        if collection.products.count() &gt; 0:\n            return Response(&#123;&quot;error&quot;: &quot;Collection have more than one product.&quot;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n        collection.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<pre><code class=\"python\">from django.shortcuts import render, get_object_or_404\n\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\n\nfrom ..serializers import ProductSerializer\nfrom ..models import Product\n\n\nclass ProductList(APIView):\n\n    def get(self, request):\n        queryset = Product.objects.all()\n        serializer = ProductSerializer(queryset, many=True,\n                                       context=&#123;&#39;request&#39;: request&#125;)\n        return Response(serializer.data)\n\n    def post(self, request):\n        if request.method == &#39;POST&#39;:\n            serializer = ProductSerializer(data=request.data)\n            serializer.is_valid(raise_exception=True)\n            serializer.save()\n            print(serializer.validated_data)\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n\n\nclass ProdcutDetail(APIView):\n\n    def get(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        serializer = ProductSerializer(product)\n        return Response(serializer.data)\n\n    def put(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        serializer = ProductSerializer(product,\n                                       data=request.data,\n                                       partial=request.method == &#39;PATCH&#39;)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    def patch(self, request, product_id):\n        return self.put(request, product_id)\n\n    def delete(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        if product.orderitem_set.count() &gt; 0:\n            return Response(&#123;&#39;error&#39;: &#39;Product has been ordered.&#39;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>完成后的结构为<code>store.model_api.APIView</code>, 如此一来, 便可以将相关的视图方法封装到同一个python模块中统一维护</p>\n<p>同时一个雷对应了一个路由, 通过路由视图类的方法实现来确定可以接受的请求类型, 代码整体就变得清晰明了.</p>\n<p>同时, 还需要编辑<code>store/urls.py</code>配置文件, 使路由能够找到对应的视图类:</p>\n<pre><code class=\"python\">from django.urls import path, include\nfrom .views import product_api, collection_api\n\nurlpatterns = [\n    # path(&#39;&#39;, views.index),\n    path(&#39;products/&#39;, product_api.ProductList.as_view()),\n    path(&#39;products/&lt;int:product_id&gt;/&#39;, product_api.ProdcutDetail.as_view()),\n    path(&#39;collections/&#39;, collection_api.CollectionList.as_view()),\n    path(&#39;collections/&lt;int:pk&gt;&#39;,\n         collection_api.CollectionDetail.as_view(),\n         name=&#39;collection-detail&#39;)\n]\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>在之前的代码中, 所有的请求都是通过python方法来进行处理的, 这会使得项目代码可维护性很差.</p>\n<p>在实际应用中, 更多的则是使用视图类来对接口进行封装.</p>\n<ol>\n<li><code>store</code>文件夹下创建一个新的 <code>views</code> 包.</li>\n<li>创建两个文件<code>products_api.py</code>和<code>collections_api.py</code></li>\n</ol>\n<p>并对之前的视图方法进行重构, 结果如下:</p>\n<pre><code class=\"python\">\n# collections_api.py\nfrom django.shortcuts import render, get_object_or_404\nfrom django.db.models import Count\n\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework.request import Request\nfrom rest_framework import status\n\nfrom ..models import Collection\nfrom ..serializers import CollectionSerializer\n\n\nclass CollectionList(APIView):\n\n    def get(self, request: Request):\n        queryset = Collection.objects.all().annotate(products_count=Count(&#39;products&#39;))\n        serializer = CollectionSerializer(queryset, many=True)\n        return Response(serializer.data)\n\n    def post(self, request: Request):\n        serializer = CollectionSerializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data, status=status.HTTP_201_CREATED)\n\n\nclass CollectionDetail(APIView):\n\n    def get_collection(self, pk) -&gt; Collection:\n        return get_object_or_404(\n            Collection.objects.annotate(products_count=Count(&#39;products&#39;)), pk=pk)\n\n    def get(self, request, pk):\n        collection: Collection = self.get_collection(pk)\n        serializer = CollectionSerializer(collection)\n        return Response(serializer.data)\n\n    def put(self, request, pk):\n        collection = self.get_collection(pk)\n        serializer = CollectionSerializer(collection,\n                                          data=request.data,\n                                          partial=request.method == &#39;PATCH&#39;)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    def patch(self, request, pk):\n        return self.put(request, pk)\n\n    def delete(self, request, pk):\n        collection = self.get_collection(pk)\n        if collection.products.count() &gt; 0:\n            return Response(&#123;&quot;error&quot;: &quot;Collection have more than one product.&quot;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n        collection.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<pre><code class=\"python\">from django.shortcuts import render, get_object_or_404\n\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\n\nfrom ..serializers import ProductSerializer\nfrom ..models import Product\n\n\nclass ProductList(APIView):\n\n    def get(self, request):\n        queryset = Product.objects.all()\n        serializer = ProductSerializer(queryset, many=True,\n                                       context=&#123;&#39;request&#39;: request&#125;)\n        return Response(serializer.data)\n\n    def post(self, request):\n        if request.method == &#39;POST&#39;:\n            serializer = ProductSerializer(data=request.data)\n            serializer.is_valid(raise_exception=True)\n            serializer.save()\n            print(serializer.validated_data)\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n\n\nclass ProdcutDetail(APIView):\n\n    def get(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        serializer = ProductSerializer(product)\n        return Response(serializer.data)\n\n    def put(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        serializer = ProductSerializer(product,\n                                       data=request.data,\n                                       partial=request.method == &#39;PATCH&#39;)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    def patch(self, request, product_id):\n        return self.put(request, product_id)\n\n    def delete(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        if product.orderitem_set.count() &gt; 0:\n            return Response(&#123;&#39;error&#39;: &#39;Product has been ordered.&#39;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>完成后的结构为<code>store.model_api.APIView</code>, 如此一来, 便可以将相关的视图方法封装到同一个python模块中统一维护</p>\n<p>同时一个雷对应了一个路由, 通过路由视图类的方法实现来确定可以接受的请求类型, 代码整体就变得清晰明了.</p>\n<p>同时, 还需要编辑<code>store/urls.py</code>配置文件, 使路由能够找到对应的视图类:</p>\n<pre><code class=\"python\">from django.urls import path, include\nfrom .views import product_api, collection_api\n\nurlpatterns = [\n    # path(&#39;&#39;, views.index),\n    path(&#39;products/&#39;, product_api.ProductList.as_view()),\n    path(&#39;products/&lt;int:product_id&gt;/&#39;, product_api.ProdcutDetail.as_view()),\n    path(&#39;collections/&#39;, collection_api.CollectionList.as_view()),\n    path(&#39;collections/&lt;int:pk&gt;&#39;,\n         collection_api.CollectionDetail.as_view(),\n         name=&#39;collection-detail&#39;)\n]\n</code></pre>\n"},{"title":"Django 常用命令","date":"2023-12-13T08:41:08.347Z","_content":"\n## 创建django项目\n\n```bash\ndjango-admin startproject name\n```\n\n## 启动服务\n\n```bash\ndjango-admin runserver\npython manage.py runserver [port]\n```\n\n## 创建应用\n\n```bash\npython manage.py startapp appname\n```\n\n## 创建数据迁移文件\n\n```bash\npython manage.py makemigrations\n```\n\n## 执行数据库迁移\n\n```bash\npython manage.py migrate\n```\n","source":"_posts/django/admin-cli.md","raw":"---\ntitle: Django 常用命令\ndate: 2023-11-11 14:07:02 +08000\ncategories: [速查, 工具]\ntags: [django]\n---\n\n## 创建django项目\n\n```bash\ndjango-admin startproject name\n```\n\n## 启动服务\n\n```bash\ndjango-admin runserver\npython manage.py runserver [port]\n```\n\n## 创建应用\n\n```bash\npython manage.py startapp appname\n```\n\n## 创建数据迁移文件\n\n```bash\npython manage.py makemigrations\n```\n\n## 执行数据库迁移\n\n```bash\npython manage.py migrate\n```\n","slug":"django-admin-cli","published":1,"updated":"2023-12-13T08:41:08.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v2001ii3erg39he2m2","content":"<h2 id=\"创建django项目\"><a href=\"#创建django项目\" class=\"headerlink\" title=\"创建django项目\"></a>创建django项目</h2><pre><code class=\"bash\">django-admin startproject name\n</code></pre>\n<h2 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h2><pre><code class=\"bash\">django-admin runserver\npython manage.py runserver [port]\n</code></pre>\n<h2 id=\"创建应用\"><a href=\"#创建应用\" class=\"headerlink\" title=\"创建应用\"></a>创建应用</h2><pre><code class=\"bash\">python manage.py startapp appname\n</code></pre>\n<h2 id=\"创建数据迁移文件\"><a href=\"#创建数据迁移文件\" class=\"headerlink\" title=\"创建数据迁移文件\"></a>创建数据迁移文件</h2><pre><code class=\"bash\">python manage.py makemigrations\n</code></pre>\n<h2 id=\"执行数据库迁移\"><a href=\"#执行数据库迁移\" class=\"headerlink\" title=\"执行数据库迁移\"></a>执行数据库迁移</h2><pre><code class=\"bash\">python manage.py migrate\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"创建django项目\"><a href=\"#创建django项目\" class=\"headerlink\" title=\"创建django项目\"></a>创建django项目</h2><pre><code class=\"bash\">django-admin startproject name\n</code></pre>\n<h2 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h2><pre><code class=\"bash\">django-admin runserver\npython manage.py runserver [port]\n</code></pre>\n<h2 id=\"创建应用\"><a href=\"#创建应用\" class=\"headerlink\" title=\"创建应用\"></a>创建应用</h2><pre><code class=\"bash\">python manage.py startapp appname\n</code></pre>\n<h2 id=\"创建数据迁移文件\"><a href=\"#创建数据迁移文件\" class=\"headerlink\" title=\"创建数据迁移文件\"></a>创建数据迁移文件</h2><pre><code class=\"bash\">python manage.py makemigrations\n</code></pre>\n<h2 id=\"执行数据库迁移\"><a href=\"#执行数据库迁移\" class=\"headerlink\" title=\"执行数据库迁移\"></a>执行数据库迁移</h2><pre><code class=\"bash\">python manage.py migrate\n</code></pre>\n"},{"title":"17. 自定义通用视图","date":"2023-11-12T17:22:11.000Z","_content":"\n当REST framework所提供的通用视图不能很好的满足需求是, 也可以创建自定义的通用视图. 以`ProductDetail`为例, 原始代码如下:\n\n```python\nclass ProdcutDetail(APIView):\n\n    def get(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        serializer = ProductSerializer(product)\n        return Response(serializer.data)\n\n    def put(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        serializer = ProductSerializer(product,\n                                       data=request.data,\n                                       partial=request.method == 'PATCH')\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    def patch(self, request, product_id):\n        return self.put(request, product_id)\n\n    def delete(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        if product.orderitem_set.count() > 0:\n            return Response({'error': 'Product has been ordered.'},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n```\n\n由于接口需要处理`GET`,`PUT`, `PATCH`和`DELETE`, 我们可以通过继承通用视图`RetrieveUpdateDestroyAPIView`\n\n显然, `get`, `put`, `patch`三个方法都没有额外的逻辑, 只有在`delete`时需要进行额外处理. 修改后的代码如下:\n\n```python\nclass ProductDetail(generics.RetrieveUpdateDestroyAPIView):\n\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    def delete(self, request, *args, **kwargs):\n        product = get_object_or_404(Product, *args, **kwargs)\n        if product.orderitem_set.count() > 0:\n            return Response({'error': 'Product has been ordered.'},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n\n同样也可以通过继承`GenericView`和所需的`Mixin`来实现, 与rest现有的通用视图方式相同, 代码如下:\n\n```python\nclass RetrieveDestroyAPIView(mixins.RetrieveModelMixin,\n                             mixins.DestroyModelMixin,\n                             GenericAPIView):\n    \"\"\"\n    Concrete view for retrieving or deleting a model instance.\n    \"\"\"\n    def get(self, request, *args, **kwargs):\n        return self.retrieve(request, *args, **kwargs)\n\n    def delete(self, request, *args, **kwargs):\n        return self.destroy(request, *args, **kwargs)\n```\n","source":"_posts/django/rest-custom-generic-view.md","raw":"---\ntitle: 17. 自定义通用视图\ndate: 2023-11-13 01:22:11 +0800\ncategories: [笔记, Django]\ntags: [python, django, backend, REST]\n---\n\n当REST framework所提供的通用视图不能很好的满足需求是, 也可以创建自定义的通用视图. 以`ProductDetail`为例, 原始代码如下:\n\n```python\nclass ProdcutDetail(APIView):\n\n    def get(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        serializer = ProductSerializer(product)\n        return Response(serializer.data)\n\n    def put(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        serializer = ProductSerializer(product,\n                                       data=request.data,\n                                       partial=request.method == 'PATCH')\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    def patch(self, request, product_id):\n        return self.put(request, product_id)\n\n    def delete(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        if product.orderitem_set.count() > 0:\n            return Response({'error': 'Product has been ordered.'},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n```\n\n由于接口需要处理`GET`,`PUT`, `PATCH`和`DELETE`, 我们可以通过继承通用视图`RetrieveUpdateDestroyAPIView`\n\n显然, `get`, `put`, `patch`三个方法都没有额外的逻辑, 只有在`delete`时需要进行额外处理. 修改后的代码如下:\n\n```python\nclass ProductDetail(generics.RetrieveUpdateDestroyAPIView):\n\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    def delete(self, request, *args, **kwargs):\n        product = get_object_or_404(Product, *args, **kwargs)\n        if product.orderitem_set.count() > 0:\n            return Response({'error': 'Product has been ordered.'},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n\n同样也可以通过继承`GenericView`和所需的`Mixin`来实现, 与rest现有的通用视图方式相同, 代码如下:\n\n```python\nclass RetrieveDestroyAPIView(mixins.RetrieveModelMixin,\n                             mixins.DestroyModelMixin,\n                             GenericAPIView):\n    \"\"\"\n    Concrete view for retrieving or deleting a model instance.\n    \"\"\"\n    def get(self, request, *args, **kwargs):\n        return self.retrieve(request, *args, **kwargs)\n\n    def delete(self, request, *args, **kwargs):\n        return self.destroy(request, *args, **kwargs)\n```\n","slug":"django-rest-custom-generic-view","published":1,"updated":"2023-12-13T08:41:08.348Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v2001mi3eresfz5nxp","content":"<p>当REST framework所提供的通用视图不能很好的满足需求是, 也可以创建自定义的通用视图. 以<code>ProductDetail</code>为例, 原始代码如下:</p>\n<pre><code class=\"python\">class ProdcutDetail(APIView):\n\n    def get(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        serializer = ProductSerializer(product)\n        return Response(serializer.data)\n\n    def put(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        serializer = ProductSerializer(product,\n                                       data=request.data,\n                                       partial=request.method == &#39;PATCH&#39;)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    def patch(self, request, product_id):\n        return self.put(request, product_id)\n\n    def delete(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        if product.orderitem_set.count() &gt; 0:\n            return Response(&#123;&#39;error&#39;: &#39;Product has been ordered.&#39;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>由于接口需要处理<code>GET</code>,<code>PUT</code>, <code>PATCH</code>和<code>DELETE</code>, 我们可以通过继承通用视图<code>RetrieveUpdateDestroyAPIView</code></p>\n<p>显然, <code>get</code>, <code>put</code>, <code>patch</code>三个方法都没有额外的逻辑, 只有在<code>delete</code>时需要进行额外处理. 修改后的代码如下:</p>\n<pre><code class=\"python\">class ProductDetail(generics.RetrieveUpdateDestroyAPIView):\n\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    def delete(self, request, *args, **kwargs):\n        product = get_object_or_404(Product, *args, **kwargs)\n        if product.orderitem_set.count() &gt; 0:\n            return Response(&#123;&#39;error&#39;: &#39;Product has been ordered.&#39;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>同样也可以通过继承<code>GenericView</code>和所需的<code>Mixin</code>来实现, 与rest现有的通用视图方式相同, 代码如下:</p>\n<pre><code class=\"python\">class RetrieveDestroyAPIView(mixins.RetrieveModelMixin,\n                             mixins.DestroyModelMixin,\n                             GenericAPIView):\n    &quot;&quot;&quot;\n    Concrete view for retrieving or deleting a model instance.\n    &quot;&quot;&quot;\n    def get(self, request, *args, **kwargs):\n        return self.retrieve(request, *args, **kwargs)\n\n    def delete(self, request, *args, **kwargs):\n        return self.destroy(request, *args, **kwargs)\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>当REST framework所提供的通用视图不能很好的满足需求是, 也可以创建自定义的通用视图. 以<code>ProductDetail</code>为例, 原始代码如下:</p>\n<pre><code class=\"python\">class ProdcutDetail(APIView):\n\n    def get(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        serializer = ProductSerializer(product)\n        return Response(serializer.data)\n\n    def put(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        serializer = ProductSerializer(product,\n                                       data=request.data,\n                                       partial=request.method == &#39;PATCH&#39;)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    def patch(self, request, product_id):\n        return self.put(request, product_id)\n\n    def delete(self, request, product_id):\n        product = get_object_or_404(Product, pk=product_id)\n        if product.orderitem_set.count() &gt; 0:\n            return Response(&#123;&#39;error&#39;: &#39;Product has been ordered.&#39;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>由于接口需要处理<code>GET</code>,<code>PUT</code>, <code>PATCH</code>和<code>DELETE</code>, 我们可以通过继承通用视图<code>RetrieveUpdateDestroyAPIView</code></p>\n<p>显然, <code>get</code>, <code>put</code>, <code>patch</code>三个方法都没有额外的逻辑, 只有在<code>delete</code>时需要进行额外处理. 修改后的代码如下:</p>\n<pre><code class=\"python\">class ProductDetail(generics.RetrieveUpdateDestroyAPIView):\n\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    def delete(self, request, *args, **kwargs):\n        product = get_object_or_404(Product, *args, **kwargs)\n        if product.orderitem_set.count() &gt; 0:\n            return Response(&#123;&#39;error&#39;: &#39;Product has been ordered.&#39;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>同样也可以通过继承<code>GenericView</code>和所需的<code>Mixin</code>来实现, 与rest现有的通用视图方式相同, 代码如下:</p>\n<pre><code class=\"python\">class RetrieveDestroyAPIView(mixins.RetrieveModelMixin,\n                             mixins.DestroyModelMixin,\n                             GenericAPIView):\n    &quot;&quot;&quot;\n    Concrete view for retrieving or deleting a model instance.\n    &quot;&quot;&quot;\n    def get(self, request, *args, **kwargs):\n        return self.retrieve(request, *args, **kwargs)\n\n    def delete(self, request, *args, **kwargs):\n        return self.destroy(request, *args, **kwargs)\n</code></pre>\n"},{"title":"20. 为REST API 添加过滤器, 搜索, 排序, 分页功能","date":"2023-11-13T11:53:59.000Z","_content":"\n通过`ProdcutViewSet`已经实现了对产品模型的增删改查操作, 但是在查询时的结果集则是数据库中的全部数据.\n\n现在的`ProdcutViewSet`代码如下:\n\n```python\nclass ProductViewSet(ModelViewSet):\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    def destroy(self, request, *args, **kwargs):\n        product = self.get_object()\n        if product.orderitem_set.count() > 0:\n            return Response({'error': 'Product has been ordered.'},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n\n在此基础上要为其添加基于collection的过滤器, 则需要为`queryset`添加额外的逻辑, 这就需要重写`get_queryset`方法.\n\n```python\ndef get_queryset(self):\n    queryset = Product.objects.all()\n\n    collection_id = self.request.query_params.get('collection_id')\n    if collection_id:\n        queryset = queryset.filter(collection_id=collection_id)\n\n    return queryset\n```\n\n> 在重写了`get_queryset`方法后, 如果删除了`queryset`成员则必须修改`urls.py`中的配置\n>\n> `router.register('products', viewset_api.ProductViewSet, basename='products')`\n>\n> 增加`basename='products`参数, 作用是为路由指定前缀.\n>\n> 由于路由对象在生成接口时是一句`queryset`成员指定的模型名称来创建的, 即`Prodcut.object.all()`会自动生成`products`前缀.\n>\n> 在没有`queryset`成员的情况下就必须收订指定`basename`参数.\n>\n{: .prompt-info}\n\n此时访问API: `store/producsts/?collection_id=3` 便可得到结果\n\n```python\n# HTTP 200 OK\n# Allow: GET, POST, HEAD, OPTIONS\n# Content-Type: application/json\n# Vary: Accept\n\n[\n    {\n        \"id\": 2,\n        \"title\": \"Island Oasis - Raspberry\",\n        \"inventory\": 40,\n        \"price\": 84.64,\n        \"price_with_tax\": 99.02879999999999,\n        \"collection_id\": 3,\n        \"collection\": \"http://127.0.0.1:8000/store/collectons/3/\"\n    },\n    # ...\n]\n```\n\n## 通用过滤器\n\n现在完成了针对`collection_id`的过滤, 但如果还需要其他的过滤字段或者其他过滤方式, 代码逻辑就会变得极其复杂.\n\n可以通过使用`django-filter`来更好的处理接口过滤.\n\n[Github](https://github.com/carltongibson/django-filter)\n[Gitee镜像](https://gitee.com/mirrors_alex/django-filter)\n[django-filter文档](https://django-filter.readthedocs.io/en/stable/)\n\n## 安装 django-filter\n\n```bash\npipenv install django-filter\n```\n\n在`INSTALLEDAPP`中加载过滤器\n\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    # here\n    'django_filters',\n    # ...\n]\n```\n\n## 配置过滤器\n\n如果仅需要定值筛选, 那么通过简单的配置便可以直接完成\n\n```python\nfrom django_filters.rest_framework import DjangoFilterBackend\n\nclass ProductViewSet(ModelViewSet):\n\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    filter_backends = [DjangoFilterBackend]\n    filterset_fields = ['collection_id']\n```\n\n再次访问接口: `store/products/?collection_id=3` 便可以顺利获取数据.\n\n但是在对其他字段进行筛选时, 比如价格, 显然不能用确定价格额进行筛选, 而是要设定价格区间.\n\n## 自定义过滤器对象\n\n在`store`目录下创建一个`filters.py`文件, 代码如下:\n\n```python\nfrom django_filters.rest_framework import FilterSet\n\nfrom .models import Product\n\nclass ProductFilter(FilterSet):\n\n    class Meta:\n        model = Product\n        fields = {\n            'collection_id': ['exact', 'in'],\n            'unit_price': ['gt', 'lt', 'gte', 'lte'],\n            'inventory': ['exact', 'gt', 'lt'],\n            'title': ['icontains', 'istartswith', 'iendswith']\n        }\n```\n\n通过定义过滤器类可以快速设定不同字段的过滤方式, 本质上就是对Django自身的lookup进行的引用.\n\n详见[Django lookup 文档](https://docs.djangoproject.com/en/4.2/ref/models/querysets/#field-lookups)\n\n在编写完过滤器对象后, 需要在ViewSet中进行对应的配置\n\n```python\nclass ProductViewSet(ModelViewSet):\n\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    filter_backends = [DjangoFilterBackend]\n    filterset_class = ProductFilter\n```\n\n![preview](/assets/img/img_202311131814429529.png){: .right}\n\n此时访问接口 `/store/products/`, 会自动提供一个`过滤器`按钮.\n\n可以根据我们定义的过滤器类, 自动的创建一个过滤器表单, 在里面便可以直接根据可用的方式设置过滤数据, 如下图所示:\n\n![filter](/assets/img/img_202311131817332685.png)\n__过滤器表单__\n\n提交表单, 我们得到的请求地址则变成了:\n\n```text\nGET /store/products/?collection_id=2&collection_id__in=&unit_price__gt=30&unit_price__lt=50&unit_price__gte=&unit_price__lte=&inventory=&inventory__gt=0&inventory__lt=&title__icontains=&title__istartswith=&title__iendswith=\n```\n\n## 添加搜索过滤器\n\n搜索和过滤作用相似, REST Framework本身也提供了基础过滤器, 只是没有`Django-filter`强大, 但是相对而言搜索功能已经够用了.\n\n在`ProductViewSet`中加入以下代码\n\n```python\nfrom rest_framework.filters import SearchFilter\n\nclass ProductViewSet(ModelViewSet):\n\n    # code ...\n\n    filter_backends = [DjangoFilterBackend, SearchFilter]\n    search_fields = ['title', 'description']\n\n    # code ...\n```\n\n重新访问接口, 便可以在过滤器按钮中找到搜索功能. 提交搜索关键字`bread mus`, 可以看到请求信息:\n\n```text\n/store/products/?search=bread+mus\n```\n\n## 数据排序\n\n一个奇怪的命名和分组, 但是REST Framework确实把排序和搜索以及过滤器放倒了一起...\n\n实现方式与搜索功能类似, 代码如下:\n\n```python\nfrom rest_framework.filters import SearchFilter, OrderingFilter\n\nclass ProductViewSet(ModelViewSet):\n\n    # code ...\n\n    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]\n    search_fields = ['title', 'description']\n    ordering_fields = ['unit_price', 'last_update']\n\n    # code ...\n```\n\n通过过滤器表单请求按照更新时间倒序排列的数据, 可以看到请求信息为:\n\n```text\nGET /store/products/?ordering=-last_update\n```\n\n## 处理数据分页\n\n同样利用REST Framework提供的分页类即可快速实现数据分页的功能.\n\n```python\nfrom rest_framework.pagination import PageNumberPagination\nclass ProductViewSet(ModelViewSet):\n\n    # other code ...\n    pagination_class = PageNumberPagination\n```\n\n为了确定每页数据的数量, 还需要在项目的`settings.py`文件中进行一个参数配置\n\n```python\nREST_FRAMEWORK = {\n    'COERCE_DECIMAL_TO_STRING': False, # Decimal数字自动转化为字符串\n    'PAGE_SIZE': 10 # 分页大小\n}\n```\n\n重新访问接口 `/store/products/`, 可以看到结果集发生了变化:\n\n![result](/assets/img/img_202311131941497659.png)\n\n系统自动添加了`count`,`next`,`previous`数据, 同时原有的结果集被放倒了`results`之中.\n\n> 在仅设置`PAGE_SIZE`的情况系下会在后台引发一个警告:\n>\n> > ```bash\n> > ?: (rest_framework.W001) You have specified a default PAGE_SIZE pagination rest_framework setting, \n> > without specifying also a DEFAULT_PAGINATION_CLASS.\n> > HINT: The default for DEFAULT_PAGINATION_CLASS is None. In previous versions this was PageNumberPagination. \n> > If you wish to define PAGE_SIZE globally whilst defining pagination_class on a per-view basis you may silence this check.\n> > ```\n>\n> 原因在于定义了全局的`PAGE_SIZE`但是没有定义全局的分页类.\n> 由于并不是所有数据都需要分页, 且不同app的分页规则同样不同, 可以通过自定义分页类, 并定义其成员变量的方式避免全局配置:\n>\n> ```python\n> from rest_framework.pagination import PageNumberPagination\n> \n> class DefaultPagination(PageNumberPagination):\n>   page_size = 10\n> \n> ```\n>\n> 当进行了分页类的自定义后, 即可以添加其他的逻辑, 也可以将分页大小等数据放到配置文件里. 最后用该类替换之前的分页类即可.\n>\n{: .prompt-tip}\n","source":"_posts/django/rest-filters-search-ordering-pagination.md","raw":"---\ntitle: 20. 为REST API 添加过滤器, 搜索, 排序, 分页功能\ndate: 2023-11-13 19:53:59 +0800\ncategories: [笔记, Django]\ntags: [python, django, backend]\n---\n\n通过`ProdcutViewSet`已经实现了对产品模型的增删改查操作, 但是在查询时的结果集则是数据库中的全部数据.\n\n现在的`ProdcutViewSet`代码如下:\n\n```python\nclass ProductViewSet(ModelViewSet):\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    def destroy(self, request, *args, **kwargs):\n        product = self.get_object()\n        if product.orderitem_set.count() > 0:\n            return Response({'error': 'Product has been ordered.'},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n\n在此基础上要为其添加基于collection的过滤器, 则需要为`queryset`添加额外的逻辑, 这就需要重写`get_queryset`方法.\n\n```python\ndef get_queryset(self):\n    queryset = Product.objects.all()\n\n    collection_id = self.request.query_params.get('collection_id')\n    if collection_id:\n        queryset = queryset.filter(collection_id=collection_id)\n\n    return queryset\n```\n\n> 在重写了`get_queryset`方法后, 如果删除了`queryset`成员则必须修改`urls.py`中的配置\n>\n> `router.register('products', viewset_api.ProductViewSet, basename='products')`\n>\n> 增加`basename='products`参数, 作用是为路由指定前缀.\n>\n> 由于路由对象在生成接口时是一句`queryset`成员指定的模型名称来创建的, 即`Prodcut.object.all()`会自动生成`products`前缀.\n>\n> 在没有`queryset`成员的情况下就必须收订指定`basename`参数.\n>\n{: .prompt-info}\n\n此时访问API: `store/producsts/?collection_id=3` 便可得到结果\n\n```python\n# HTTP 200 OK\n# Allow: GET, POST, HEAD, OPTIONS\n# Content-Type: application/json\n# Vary: Accept\n\n[\n    {\n        \"id\": 2,\n        \"title\": \"Island Oasis - Raspberry\",\n        \"inventory\": 40,\n        \"price\": 84.64,\n        \"price_with_tax\": 99.02879999999999,\n        \"collection_id\": 3,\n        \"collection\": \"http://127.0.0.1:8000/store/collectons/3/\"\n    },\n    # ...\n]\n```\n\n## 通用过滤器\n\n现在完成了针对`collection_id`的过滤, 但如果还需要其他的过滤字段或者其他过滤方式, 代码逻辑就会变得极其复杂.\n\n可以通过使用`django-filter`来更好的处理接口过滤.\n\n[Github](https://github.com/carltongibson/django-filter)\n[Gitee镜像](https://gitee.com/mirrors_alex/django-filter)\n[django-filter文档](https://django-filter.readthedocs.io/en/stable/)\n\n## 安装 django-filter\n\n```bash\npipenv install django-filter\n```\n\n在`INSTALLEDAPP`中加载过滤器\n\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    # here\n    'django_filters',\n    # ...\n]\n```\n\n## 配置过滤器\n\n如果仅需要定值筛选, 那么通过简单的配置便可以直接完成\n\n```python\nfrom django_filters.rest_framework import DjangoFilterBackend\n\nclass ProductViewSet(ModelViewSet):\n\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    filter_backends = [DjangoFilterBackend]\n    filterset_fields = ['collection_id']\n```\n\n再次访问接口: `store/products/?collection_id=3` 便可以顺利获取数据.\n\n但是在对其他字段进行筛选时, 比如价格, 显然不能用确定价格额进行筛选, 而是要设定价格区间.\n\n## 自定义过滤器对象\n\n在`store`目录下创建一个`filters.py`文件, 代码如下:\n\n```python\nfrom django_filters.rest_framework import FilterSet\n\nfrom .models import Product\n\nclass ProductFilter(FilterSet):\n\n    class Meta:\n        model = Product\n        fields = {\n            'collection_id': ['exact', 'in'],\n            'unit_price': ['gt', 'lt', 'gte', 'lte'],\n            'inventory': ['exact', 'gt', 'lt'],\n            'title': ['icontains', 'istartswith', 'iendswith']\n        }\n```\n\n通过定义过滤器类可以快速设定不同字段的过滤方式, 本质上就是对Django自身的lookup进行的引用.\n\n详见[Django lookup 文档](https://docs.djangoproject.com/en/4.2/ref/models/querysets/#field-lookups)\n\n在编写完过滤器对象后, 需要在ViewSet中进行对应的配置\n\n```python\nclass ProductViewSet(ModelViewSet):\n\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    filter_backends = [DjangoFilterBackend]\n    filterset_class = ProductFilter\n```\n\n![preview](/assets/img/img_202311131814429529.png){: .right}\n\n此时访问接口 `/store/products/`, 会自动提供一个`过滤器`按钮.\n\n可以根据我们定义的过滤器类, 自动的创建一个过滤器表单, 在里面便可以直接根据可用的方式设置过滤数据, 如下图所示:\n\n![filter](/assets/img/img_202311131817332685.png)\n__过滤器表单__\n\n提交表单, 我们得到的请求地址则变成了:\n\n```text\nGET /store/products/?collection_id=2&collection_id__in=&unit_price__gt=30&unit_price__lt=50&unit_price__gte=&unit_price__lte=&inventory=&inventory__gt=0&inventory__lt=&title__icontains=&title__istartswith=&title__iendswith=\n```\n\n## 添加搜索过滤器\n\n搜索和过滤作用相似, REST Framework本身也提供了基础过滤器, 只是没有`Django-filter`强大, 但是相对而言搜索功能已经够用了.\n\n在`ProductViewSet`中加入以下代码\n\n```python\nfrom rest_framework.filters import SearchFilter\n\nclass ProductViewSet(ModelViewSet):\n\n    # code ...\n\n    filter_backends = [DjangoFilterBackend, SearchFilter]\n    search_fields = ['title', 'description']\n\n    # code ...\n```\n\n重新访问接口, 便可以在过滤器按钮中找到搜索功能. 提交搜索关键字`bread mus`, 可以看到请求信息:\n\n```text\n/store/products/?search=bread+mus\n```\n\n## 数据排序\n\n一个奇怪的命名和分组, 但是REST Framework确实把排序和搜索以及过滤器放倒了一起...\n\n实现方式与搜索功能类似, 代码如下:\n\n```python\nfrom rest_framework.filters import SearchFilter, OrderingFilter\n\nclass ProductViewSet(ModelViewSet):\n\n    # code ...\n\n    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]\n    search_fields = ['title', 'description']\n    ordering_fields = ['unit_price', 'last_update']\n\n    # code ...\n```\n\n通过过滤器表单请求按照更新时间倒序排列的数据, 可以看到请求信息为:\n\n```text\nGET /store/products/?ordering=-last_update\n```\n\n## 处理数据分页\n\n同样利用REST Framework提供的分页类即可快速实现数据分页的功能.\n\n```python\nfrom rest_framework.pagination import PageNumberPagination\nclass ProductViewSet(ModelViewSet):\n\n    # other code ...\n    pagination_class = PageNumberPagination\n```\n\n为了确定每页数据的数量, 还需要在项目的`settings.py`文件中进行一个参数配置\n\n```python\nREST_FRAMEWORK = {\n    'COERCE_DECIMAL_TO_STRING': False, # Decimal数字自动转化为字符串\n    'PAGE_SIZE': 10 # 分页大小\n}\n```\n\n重新访问接口 `/store/products/`, 可以看到结果集发生了变化:\n\n![result](/assets/img/img_202311131941497659.png)\n\n系统自动添加了`count`,`next`,`previous`数据, 同时原有的结果集被放倒了`results`之中.\n\n> 在仅设置`PAGE_SIZE`的情况系下会在后台引发一个警告:\n>\n> > ```bash\n> > ?: (rest_framework.W001) You have specified a default PAGE_SIZE pagination rest_framework setting, \n> > without specifying also a DEFAULT_PAGINATION_CLASS.\n> > HINT: The default for DEFAULT_PAGINATION_CLASS is None. In previous versions this was PageNumberPagination. \n> > If you wish to define PAGE_SIZE globally whilst defining pagination_class on a per-view basis you may silence this check.\n> > ```\n>\n> 原因在于定义了全局的`PAGE_SIZE`但是没有定义全局的分页类.\n> 由于并不是所有数据都需要分页, 且不同app的分页规则同样不同, 可以通过自定义分页类, 并定义其成员变量的方式避免全局配置:\n>\n> ```python\n> from rest_framework.pagination import PageNumberPagination\n> \n> class DefaultPagination(PageNumberPagination):\n>   page_size = 10\n> \n> ```\n>\n> 当进行了分页类的自定义后, 即可以添加其他的逻辑, 也可以将分页大小等数据放到配置文件里. 最后用该类替换之前的分页类即可.\n>\n{: .prompt-tip}\n","slug":"django-rest-filters-search-ordering-pagination","published":1,"updated":"2023-12-13T08:41:08.348Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v2001pi3erfchh77jc","content":"<p>通过<code>ProdcutViewSet</code>已经实现了对产品模型的增删改查操作, 但是在查询时的结果集则是数据库中的全部数据.</p>\n<p>现在的<code>ProdcutViewSet</code>代码如下:</p>\n<pre><code class=\"python\">class ProductViewSet(ModelViewSet):\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    def destroy(self, request, *args, **kwargs):\n        product = self.get_object()\n        if product.orderitem_set.count() &gt; 0:\n            return Response(&#123;&#39;error&#39;: &#39;Product has been ordered.&#39;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>在此基础上要为其添加基于collection的过滤器, 则需要为<code>queryset</code>添加额外的逻辑, 这就需要重写<code>get_queryset</code>方法.</p>\n<pre><code class=\"python\">def get_queryset(self):\n    queryset = Product.objects.all()\n\n    collection_id = self.request.query_params.get(&#39;collection_id&#39;)\n    if collection_id:\n        queryset = queryset.filter(collection_id=collection_id)\n\n    return queryset\n</code></pre>\n<blockquote>\n<p>在重写了<code>get_queryset</code>方法后, 如果删除了<code>queryset</code>成员则必须修改<code>urls.py</code>中的配置</p>\n<p><code>router.register(&#39;products&#39;, viewset_api.ProductViewSet, basename=&#39;products&#39;)</code></p>\n<p>增加<code>basename=&#39;products</code>参数, 作用是为路由指定前缀.</p>\n<p>由于路由对象在生成接口时是一句<code>queryset</code>成员指定的模型名称来创建的, 即<code>Prodcut.object.all()</code>会自动生成<code>products</code>前缀.</p>\n<p>在没有<code>queryset</code>成员的情况下就必须收订指定<code>basename</code>参数.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<p>此时访问API: <code>store/producsts/?collection_id=3</code> 便可得到结果</p>\n<pre><code class=\"python\"># HTTP 200 OK\n# Allow: GET, POST, HEAD, OPTIONS\n# Content-Type: application/json\n# Vary: Accept\n\n[\n    &#123;\n        &quot;id&quot;: 2,\n        &quot;title&quot;: &quot;Island Oasis - Raspberry&quot;,\n        &quot;inventory&quot;: 40,\n        &quot;price&quot;: 84.64,\n        &quot;price_with_tax&quot;: 99.02879999999999,\n        &quot;collection_id&quot;: 3,\n        &quot;collection&quot;: &quot;http://127.0.0.1:8000/store/collectons/3/&quot;\n    &#125;,\n    # ...\n]\n</code></pre>\n<h2 id=\"通用过滤器\"><a href=\"#通用过滤器\" class=\"headerlink\" title=\"通用过滤器\"></a>通用过滤器</h2><p>现在完成了针对<code>collection_id</code>的过滤, 但如果还需要其他的过滤字段或者其他过滤方式, 代码逻辑就会变得极其复杂.</p>\n<p>可以通过使用<code>django-filter</code>来更好的处理接口过滤.</p>\n<p><a href=\"https://github.com/carltongibson/django-filter\">Github</a><br><a href=\"https://gitee.com/mirrors_alex/django-filter\">Gitee镜像</a><br><a href=\"https://django-filter.readthedocs.io/en/stable/\">django-filter文档</a></p>\n<h2 id=\"安装-django-filter\"><a href=\"#安装-django-filter\" class=\"headerlink\" title=\"安装 django-filter\"></a>安装 django-filter</h2><pre><code class=\"bash\">pipenv install django-filter\n</code></pre>\n<p>在<code>INSTALLEDAPP</code>中加载过滤器</p>\n<pre><code class=\"python\">INSTALLED_APPS = [\n    &#39;django.contrib.admin&#39;,\n    &#39;django.contrib.auth&#39;,\n    &#39;django.contrib.contenttypes&#39;,\n    &#39;django.contrib.sessions&#39;,\n    &#39;django.contrib.messages&#39;,\n    &#39;django.contrib.staticfiles&#39;,\n    # here\n    &#39;django_filters&#39;,\n    # ...\n]\n</code></pre>\n<h2 id=\"配置过滤器\"><a href=\"#配置过滤器\" class=\"headerlink\" title=\"配置过滤器\"></a>配置过滤器</h2><p>如果仅需要定值筛选, 那么通过简单的配置便可以直接完成</p>\n<pre><code class=\"python\">from django_filters.rest_framework import DjangoFilterBackend\n\nclass ProductViewSet(ModelViewSet):\n\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    filter_backends = [DjangoFilterBackend]\n    filterset_fields = [&#39;collection_id&#39;]\n</code></pre>\n<p>再次访问接口: <code>store/products/?collection_id=3</code> 便可以顺利获取数据.</p>\n<p>但是在对其他字段进行筛选时, 比如价格, 显然不能用确定价格额进行筛选, 而是要设定价格区间.</p>\n<h2 id=\"自定义过滤器对象\"><a href=\"#自定义过滤器对象\" class=\"headerlink\" title=\"自定义过滤器对象\"></a>自定义过滤器对象</h2><p>在<code>store</code>目录下创建一个<code>filters.py</code>文件, 代码如下:</p>\n<pre><code class=\"python\">from django_filters.rest_framework import FilterSet\n\nfrom .models import Product\n\nclass ProductFilter(FilterSet):\n\n    class Meta:\n        model = Product\n        fields = &#123;\n            &#39;collection_id&#39;: [&#39;exact&#39;, &#39;in&#39;],\n            &#39;unit_price&#39;: [&#39;gt&#39;, &#39;lt&#39;, &#39;gte&#39;, &#39;lte&#39;],\n            &#39;inventory&#39;: [&#39;exact&#39;, &#39;gt&#39;, &#39;lt&#39;],\n            &#39;title&#39;: [&#39;icontains&#39;, &#39;istartswith&#39;, &#39;iendswith&#39;]\n        &#125;\n</code></pre>\n<p>通过定义过滤器类可以快速设定不同字段的过滤方式, 本质上就是对Django自身的lookup进行的引用.</p>\n<p>详见<a href=\"https://docs.djangoproject.com/en/4.2/ref/models/querysets/#field-lookups\">Django lookup 文档</a></p>\n<p>在编写完过滤器对象后, 需要在ViewSet中进行对应的配置</p>\n<pre><code class=\"python\">class ProductViewSet(ModelViewSet):\n\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    filter_backends = [DjangoFilterBackend]\n    filterset_class = ProductFilter\n</code></pre>\n<p><img src=\"/assets/img/img_202311131814429529.png\" alt=\"preview\">{: .right}</p>\n<p>此时访问接口 <code>/store/products/</code>, 会自动提供一个<code>过滤器</code>按钮.</p>\n<p>可以根据我们定义的过滤器类, 自动的创建一个过滤器表单, 在里面便可以直接根据可用的方式设置过滤数据, 如下图所示:</p>\n<p><img src=\"/assets/img/img_202311131817332685.png\" alt=\"filter\"><br><strong>过滤器表单</strong></p>\n<p>提交表单, 我们得到的请求地址则变成了:</p>\n<pre><code class=\"text\">GET /store/products/?collection_id=2&amp;collection_id__in=&amp;unit_price__gt=30&amp;unit_price__lt=50&amp;unit_price__gte=&amp;unit_price__lte=&amp;inventory=&amp;inventory__gt=0&amp;inventory__lt=&amp;title__icontains=&amp;title__istartswith=&amp;title__iendswith=\n</code></pre>\n<h2 id=\"添加搜索过滤器\"><a href=\"#添加搜索过滤器\" class=\"headerlink\" title=\"添加搜索过滤器\"></a>添加搜索过滤器</h2><p>搜索和过滤作用相似, REST Framework本身也提供了基础过滤器, 只是没有<code>Django-filter</code>强大, 但是相对而言搜索功能已经够用了.</p>\n<p>在<code>ProductViewSet</code>中加入以下代码</p>\n<pre><code class=\"python\">from rest_framework.filters import SearchFilter\n\nclass ProductViewSet(ModelViewSet):\n\n    # code ...\n\n    filter_backends = [DjangoFilterBackend, SearchFilter]\n    search_fields = [&#39;title&#39;, &#39;description&#39;]\n\n    # code ...\n</code></pre>\n<p>重新访问接口, 便可以在过滤器按钮中找到搜索功能. 提交搜索关键字<code>bread mus</code>, 可以看到请求信息:</p>\n<pre><code class=\"text\">/store/products/?search=bread+mus\n</code></pre>\n<h2 id=\"数据排序\"><a href=\"#数据排序\" class=\"headerlink\" title=\"数据排序\"></a>数据排序</h2><p>一个奇怪的命名和分组, 但是REST Framework确实把排序和搜索以及过滤器放倒了一起…</p>\n<p>实现方式与搜索功能类似, 代码如下:</p>\n<pre><code class=\"python\">from rest_framework.filters import SearchFilter, OrderingFilter\n\nclass ProductViewSet(ModelViewSet):\n\n    # code ...\n\n    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]\n    search_fields = [&#39;title&#39;, &#39;description&#39;]\n    ordering_fields = [&#39;unit_price&#39;, &#39;last_update&#39;]\n\n    # code ...\n</code></pre>\n<p>通过过滤器表单请求按照更新时间倒序排列的数据, 可以看到请求信息为:</p>\n<pre><code class=\"text\">GET /store/products/?ordering=-last_update\n</code></pre>\n<h2 id=\"处理数据分页\"><a href=\"#处理数据分页\" class=\"headerlink\" title=\"处理数据分页\"></a>处理数据分页</h2><p>同样利用REST Framework提供的分页类即可快速实现数据分页的功能.</p>\n<pre><code class=\"python\">from rest_framework.pagination import PageNumberPagination\nclass ProductViewSet(ModelViewSet):\n\n    # other code ...\n    pagination_class = PageNumberPagination\n</code></pre>\n<p>为了确定每页数据的数量, 还需要在项目的<code>settings.py</code>文件中进行一个参数配置</p>\n<pre><code class=\"python\">REST_FRAMEWORK = &#123;\n    &#39;COERCE_DECIMAL_TO_STRING&#39;: False, # Decimal数字自动转化为字符串\n    &#39;PAGE_SIZE&#39;: 10 # 分页大小\n&#125;\n</code></pre>\n<p>重新访问接口 <code>/store/products/</code>, 可以看到结果集发生了变化:</p>\n<p><img src=\"/assets/img/img_202311131941497659.png\" alt=\"result\"></p>\n<p>系统自动添加了<code>count</code>,<code>next</code>,<code>previous</code>数据, 同时原有的结果集被放倒了<code>results</code>之中.</p>\n<blockquote>\n<p>在仅设置<code>PAGE_SIZE</code>的情况系下会在后台引发一个警告:</p>\n<blockquote>\n<pre><code class=\"bash\">?: (rest_framework.W001) You have specified a default PAGE_SIZE pagination rest_framework setting, \nwithout specifying also a DEFAULT_PAGINATION_CLASS.\nHINT: The default for DEFAULT_PAGINATION_CLASS is None. In previous versions this was PageNumberPagination. \nIf you wish to define PAGE_SIZE globally whilst defining pagination_class on a per-view basis you may silence this check.\n</code></pre>\n</blockquote>\n<p>原因在于定义了全局的<code>PAGE_SIZE</code>但是没有定义全局的分页类.<br>由于并不是所有数据都需要分页, 且不同app的分页规则同样不同, 可以通过自定义分页类, 并定义其成员变量的方式避免全局配置:</p>\n<pre><code class=\"python\">from rest_framework.pagination import PageNumberPagination\n\nclass DefaultPagination(PageNumberPagination):\n  page_size = 10\n</code></pre>\n<p>当进行了分页类的自定义后, 即可以添加其他的逻辑, 也可以将分页大小等数据放到配置文件里. 最后用该类替换之前的分页类即可.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>通过<code>ProdcutViewSet</code>已经实现了对产品模型的增删改查操作, 但是在查询时的结果集则是数据库中的全部数据.</p>\n<p>现在的<code>ProdcutViewSet</code>代码如下:</p>\n<pre><code class=\"python\">class ProductViewSet(ModelViewSet):\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    def destroy(self, request, *args, **kwargs):\n        product = self.get_object()\n        if product.orderitem_set.count() &gt; 0:\n            return Response(&#123;&#39;error&#39;: &#39;Product has been ordered.&#39;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>在此基础上要为其添加基于collection的过滤器, 则需要为<code>queryset</code>添加额外的逻辑, 这就需要重写<code>get_queryset</code>方法.</p>\n<pre><code class=\"python\">def get_queryset(self):\n    queryset = Product.objects.all()\n\n    collection_id = self.request.query_params.get(&#39;collection_id&#39;)\n    if collection_id:\n        queryset = queryset.filter(collection_id=collection_id)\n\n    return queryset\n</code></pre>\n<blockquote>\n<p>在重写了<code>get_queryset</code>方法后, 如果删除了<code>queryset</code>成员则必须修改<code>urls.py</code>中的配置</p>\n<p><code>router.register(&#39;products&#39;, viewset_api.ProductViewSet, basename=&#39;products&#39;)</code></p>\n<p>增加<code>basename=&#39;products</code>参数, 作用是为路由指定前缀.</p>\n<p>由于路由对象在生成接口时是一句<code>queryset</code>成员指定的模型名称来创建的, 即<code>Prodcut.object.all()</code>会自动生成<code>products</code>前缀.</p>\n<p>在没有<code>queryset</code>成员的情况下就必须收订指定<code>basename</code>参数.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<p>此时访问API: <code>store/producsts/?collection_id=3</code> 便可得到结果</p>\n<pre><code class=\"python\"># HTTP 200 OK\n# Allow: GET, POST, HEAD, OPTIONS\n# Content-Type: application/json\n# Vary: Accept\n\n[\n    &#123;\n        &quot;id&quot;: 2,\n        &quot;title&quot;: &quot;Island Oasis - Raspberry&quot;,\n        &quot;inventory&quot;: 40,\n        &quot;price&quot;: 84.64,\n        &quot;price_with_tax&quot;: 99.02879999999999,\n        &quot;collection_id&quot;: 3,\n        &quot;collection&quot;: &quot;http://127.0.0.1:8000/store/collectons/3/&quot;\n    &#125;,\n    # ...\n]\n</code></pre>\n<h2 id=\"通用过滤器\"><a href=\"#通用过滤器\" class=\"headerlink\" title=\"通用过滤器\"></a>通用过滤器</h2><p>现在完成了针对<code>collection_id</code>的过滤, 但如果还需要其他的过滤字段或者其他过滤方式, 代码逻辑就会变得极其复杂.</p>\n<p>可以通过使用<code>django-filter</code>来更好的处理接口过滤.</p>\n<p><a href=\"https://github.com/carltongibson/django-filter\">Github</a><br><a href=\"https://gitee.com/mirrors_alex/django-filter\">Gitee镜像</a><br><a href=\"https://django-filter.readthedocs.io/en/stable/\">django-filter文档</a></p>\n<h2 id=\"安装-django-filter\"><a href=\"#安装-django-filter\" class=\"headerlink\" title=\"安装 django-filter\"></a>安装 django-filter</h2><pre><code class=\"bash\">pipenv install django-filter\n</code></pre>\n<p>在<code>INSTALLEDAPP</code>中加载过滤器</p>\n<pre><code class=\"python\">INSTALLED_APPS = [\n    &#39;django.contrib.admin&#39;,\n    &#39;django.contrib.auth&#39;,\n    &#39;django.contrib.contenttypes&#39;,\n    &#39;django.contrib.sessions&#39;,\n    &#39;django.contrib.messages&#39;,\n    &#39;django.contrib.staticfiles&#39;,\n    # here\n    &#39;django_filters&#39;,\n    # ...\n]\n</code></pre>\n<h2 id=\"配置过滤器\"><a href=\"#配置过滤器\" class=\"headerlink\" title=\"配置过滤器\"></a>配置过滤器</h2><p>如果仅需要定值筛选, 那么通过简单的配置便可以直接完成</p>\n<pre><code class=\"python\">from django_filters.rest_framework import DjangoFilterBackend\n\nclass ProductViewSet(ModelViewSet):\n\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    filter_backends = [DjangoFilterBackend]\n    filterset_fields = [&#39;collection_id&#39;]\n</code></pre>\n<p>再次访问接口: <code>store/products/?collection_id=3</code> 便可以顺利获取数据.</p>\n<p>但是在对其他字段进行筛选时, 比如价格, 显然不能用确定价格额进行筛选, 而是要设定价格区间.</p>\n<h2 id=\"自定义过滤器对象\"><a href=\"#自定义过滤器对象\" class=\"headerlink\" title=\"自定义过滤器对象\"></a>自定义过滤器对象</h2><p>在<code>store</code>目录下创建一个<code>filters.py</code>文件, 代码如下:</p>\n<pre><code class=\"python\">from django_filters.rest_framework import FilterSet\n\nfrom .models import Product\n\nclass ProductFilter(FilterSet):\n\n    class Meta:\n        model = Product\n        fields = &#123;\n            &#39;collection_id&#39;: [&#39;exact&#39;, &#39;in&#39;],\n            &#39;unit_price&#39;: [&#39;gt&#39;, &#39;lt&#39;, &#39;gte&#39;, &#39;lte&#39;],\n            &#39;inventory&#39;: [&#39;exact&#39;, &#39;gt&#39;, &#39;lt&#39;],\n            &#39;title&#39;: [&#39;icontains&#39;, &#39;istartswith&#39;, &#39;iendswith&#39;]\n        &#125;\n</code></pre>\n<p>通过定义过滤器类可以快速设定不同字段的过滤方式, 本质上就是对Django自身的lookup进行的引用.</p>\n<p>详见<a href=\"https://docs.djangoproject.com/en/4.2/ref/models/querysets/#field-lookups\">Django lookup 文档</a></p>\n<p>在编写完过滤器对象后, 需要在ViewSet中进行对应的配置</p>\n<pre><code class=\"python\">class ProductViewSet(ModelViewSet):\n\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    filter_backends = [DjangoFilterBackend]\n    filterset_class = ProductFilter\n</code></pre>\n<p><img src=\"/assets/img/img_202311131814429529.png\" alt=\"preview\">{: .right}</p>\n<p>此时访问接口 <code>/store/products/</code>, 会自动提供一个<code>过滤器</code>按钮.</p>\n<p>可以根据我们定义的过滤器类, 自动的创建一个过滤器表单, 在里面便可以直接根据可用的方式设置过滤数据, 如下图所示:</p>\n<p><img src=\"/assets/img/img_202311131817332685.png\" alt=\"filter\"><br><strong>过滤器表单</strong></p>\n<p>提交表单, 我们得到的请求地址则变成了:</p>\n<pre><code class=\"text\">GET /store/products/?collection_id=2&amp;collection_id__in=&amp;unit_price__gt=30&amp;unit_price__lt=50&amp;unit_price__gte=&amp;unit_price__lte=&amp;inventory=&amp;inventory__gt=0&amp;inventory__lt=&amp;title__icontains=&amp;title__istartswith=&amp;title__iendswith=\n</code></pre>\n<h2 id=\"添加搜索过滤器\"><a href=\"#添加搜索过滤器\" class=\"headerlink\" title=\"添加搜索过滤器\"></a>添加搜索过滤器</h2><p>搜索和过滤作用相似, REST Framework本身也提供了基础过滤器, 只是没有<code>Django-filter</code>强大, 但是相对而言搜索功能已经够用了.</p>\n<p>在<code>ProductViewSet</code>中加入以下代码</p>\n<pre><code class=\"python\">from rest_framework.filters import SearchFilter\n\nclass ProductViewSet(ModelViewSet):\n\n    # code ...\n\n    filter_backends = [DjangoFilterBackend, SearchFilter]\n    search_fields = [&#39;title&#39;, &#39;description&#39;]\n\n    # code ...\n</code></pre>\n<p>重新访问接口, 便可以在过滤器按钮中找到搜索功能. 提交搜索关键字<code>bread mus</code>, 可以看到请求信息:</p>\n<pre><code class=\"text\">/store/products/?search=bread+mus\n</code></pre>\n<h2 id=\"数据排序\"><a href=\"#数据排序\" class=\"headerlink\" title=\"数据排序\"></a>数据排序</h2><p>一个奇怪的命名和分组, 但是REST Framework确实把排序和搜索以及过滤器放倒了一起…</p>\n<p>实现方式与搜索功能类似, 代码如下:</p>\n<pre><code class=\"python\">from rest_framework.filters import SearchFilter, OrderingFilter\n\nclass ProductViewSet(ModelViewSet):\n\n    # code ...\n\n    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]\n    search_fields = [&#39;title&#39;, &#39;description&#39;]\n    ordering_fields = [&#39;unit_price&#39;, &#39;last_update&#39;]\n\n    # code ...\n</code></pre>\n<p>通过过滤器表单请求按照更新时间倒序排列的数据, 可以看到请求信息为:</p>\n<pre><code class=\"text\">GET /store/products/?ordering=-last_update\n</code></pre>\n<h2 id=\"处理数据分页\"><a href=\"#处理数据分页\" class=\"headerlink\" title=\"处理数据分页\"></a>处理数据分页</h2><p>同样利用REST Framework提供的分页类即可快速实现数据分页的功能.</p>\n<pre><code class=\"python\">from rest_framework.pagination import PageNumberPagination\nclass ProductViewSet(ModelViewSet):\n\n    # other code ...\n    pagination_class = PageNumberPagination\n</code></pre>\n<p>为了确定每页数据的数量, 还需要在项目的<code>settings.py</code>文件中进行一个参数配置</p>\n<pre><code class=\"python\">REST_FRAMEWORK = &#123;\n    &#39;COERCE_DECIMAL_TO_STRING&#39;: False, # Decimal数字自动转化为字符串\n    &#39;PAGE_SIZE&#39;: 10 # 分页大小\n&#125;\n</code></pre>\n<p>重新访问接口 <code>/store/products/</code>, 可以看到结果集发生了变化:</p>\n<p><img src=\"/assets/img/img_202311131941497659.png\" alt=\"result\"></p>\n<p>系统自动添加了<code>count</code>,<code>next</code>,<code>previous</code>数据, 同时原有的结果集被放倒了<code>results</code>之中.</p>\n<blockquote>\n<p>在仅设置<code>PAGE_SIZE</code>的情况系下会在后台引发一个警告:</p>\n<blockquote>\n<pre><code class=\"bash\">?: (rest_framework.W001) You have specified a default PAGE_SIZE pagination rest_framework setting, \nwithout specifying also a DEFAULT_PAGINATION_CLASS.\nHINT: The default for DEFAULT_PAGINATION_CLASS is None. In previous versions this was PageNumberPagination. \nIf you wish to define PAGE_SIZE globally whilst defining pagination_class on a per-view basis you may silence this check.\n</code></pre>\n</blockquote>\n<p>原因在于定义了全局的<code>PAGE_SIZE</code>但是没有定义全局的分页类.<br>由于并不是所有数据都需要分页, 且不同app的分页规则同样不同, 可以通过自定义分页类, 并定义其成员变量的方式避免全局配置:</p>\n<pre><code class=\"python\">from rest_framework.pagination import PageNumberPagination\n\nclass DefaultPagination(PageNumberPagination):\n  page_size = 10\n</code></pre>\n<p>当进行了分页类的自定义后, 即可以添加其他的逻辑, 也可以将分页大小等数据放到配置文件里. 最后用该类替换之前的分页类即可.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n"},{"title":"16. REST Framework GenericView 通用视图","date":"2023-11-12T12:26:04.000Z","_content":"\n在之前的代码中, 基本实现了对于`Prodcut`和`Collection`的增删改查接口.\n\n但是在API的实现代码中存在着大量几乎相同的代码, 如:\n\n```python\n# ProductList\ndef get(self, request):\n        queryset = Product.objects.all()\n        serializer = ProductSerializer(queryset, many=True,\n                                       context={'request': request})\n        return Response(serializer.data)\n\n# CollectionList\ndef get(self, request: Request):\n        queryset = Collection.objects.all().annotate(products_count=Count('products'))\n        serializer = CollectionSerializer(queryset, many=True)\n        return Response(serializer.data)\n```\n\n他们本质上是相同的功能, 只是处理的目标对象不同, 而编码模式也是几乎一样.\n\n为了减少这种类似的重复编码, 就可以使用`rest Framework`所提供的`generic view`来实现\n\n## 通用视图\n\nrest framework提供了多种通用视图, 统一封装在 `rest_framework.generic` 包下.\n\n[详细官方文档](https://www.django-rest-framework.org/api-guide/generic-views/#generic-views)\n\n以`ProductList`视图为例, 由于接口能够处理`GET`和`POST`请求, 同时返回的是一个结果集, 就可以直接使用`ListCreateAPIView`来快速实现:\n\n```python\nclass ProductList(generics.ListCreateAPIView):\n\n    serializer_class = ProductSerializer\n    queryset = Product.objects.select_related('collection').all()\n```\n\n> 注意: `serializer_class`的值是类而不是对象, 不能加`()`\n{: .prompt-warning}\n\n由于`products/`路由在查询时需要查询关联的`collection`, 所以需要重写`get_queryset`方法来完善代码逻辑.\n\n如果在查询时存在其他的业务需求, 比如根据用户类型和权限进行不同的查询等等, 则需要重写`get_queryset`方法:\n\n```python\ndef get_queryset(self):\n        # logic code here\n        queryset = Model.objects.all()\n        return queryset\n```\n\n`serializer_class`同理, 可以通过重写`get_serializer_class`方法添加额外业务处理.\n\n`get_serializer_cotext`方法指定了序列化的上下文, 如在进行超链接关系字段的序列化时就需要用到上下文中的`request`, 但是`GenericView`已经对其进行了更为完善的封装, 在仅需要设定`request`上下文的情况下无需进行更改. 查看父类的`get_serializer_context`可知:\n\n```python\n\n# GenericAPIView\n\ndef get_serializer_context(self):\n        \"\"\"\n        Extra context provided to the serializer class.\n        \"\"\"\n        return {\n                'request': self.request,\n                'format': self.format_kwarg,\n                'view': self\n}\n```\n\n通过GenericView, 之前的视图方法被压缩到仅仅两行, 除此之外, GenericView还会为`POST`请求自动生成一个表单, 如图所示:\n![form](/assets/img/img_202311122320571347.png)\n\n对于这类接口, 甚至仅需要做一下配置便可以快速完成, 不需要额外代码:\n\n```python\n# `store/urls.py`\nurlpatterns = [\n    path('products/', generics.ListCreateAPIView.as_view(\n        queryset=Product.objects.select_related('collection').all(),\n        serializer_class=ProductSerializer\n    )),\n    # other routes...\n]\n```\n\n> 虽然可以通过路由配置文件直接实现通用视图接口, 但不建议这么使用.\n>\n> 1. 后续可能会增加业务逻辑, 一旦增加那么还是要提取到单独的视图类中\n> 2. 配置文件中会引入逻辑代码, 以及额外的导入似的后期不便于维护\n>\n> 仅当临时测试新建接口时用一用就可以了.\n>\n{: .prompt-tip}\n","source":"_posts/django/rest-generic-view.md","raw":"---\ntitle: 16. REST Framework GenericView 通用视图\ndate: 2023-11-12 20:26:04 +0800\ncategories: [笔记, Django]\ntags: [python, django, backend]\n---\n\n在之前的代码中, 基本实现了对于`Prodcut`和`Collection`的增删改查接口.\n\n但是在API的实现代码中存在着大量几乎相同的代码, 如:\n\n```python\n# ProductList\ndef get(self, request):\n        queryset = Product.objects.all()\n        serializer = ProductSerializer(queryset, many=True,\n                                       context={'request': request})\n        return Response(serializer.data)\n\n# CollectionList\ndef get(self, request: Request):\n        queryset = Collection.objects.all().annotate(products_count=Count('products'))\n        serializer = CollectionSerializer(queryset, many=True)\n        return Response(serializer.data)\n```\n\n他们本质上是相同的功能, 只是处理的目标对象不同, 而编码模式也是几乎一样.\n\n为了减少这种类似的重复编码, 就可以使用`rest Framework`所提供的`generic view`来实现\n\n## 通用视图\n\nrest framework提供了多种通用视图, 统一封装在 `rest_framework.generic` 包下.\n\n[详细官方文档](https://www.django-rest-framework.org/api-guide/generic-views/#generic-views)\n\n以`ProductList`视图为例, 由于接口能够处理`GET`和`POST`请求, 同时返回的是一个结果集, 就可以直接使用`ListCreateAPIView`来快速实现:\n\n```python\nclass ProductList(generics.ListCreateAPIView):\n\n    serializer_class = ProductSerializer\n    queryset = Product.objects.select_related('collection').all()\n```\n\n> 注意: `serializer_class`的值是类而不是对象, 不能加`()`\n{: .prompt-warning}\n\n由于`products/`路由在查询时需要查询关联的`collection`, 所以需要重写`get_queryset`方法来完善代码逻辑.\n\n如果在查询时存在其他的业务需求, 比如根据用户类型和权限进行不同的查询等等, 则需要重写`get_queryset`方法:\n\n```python\ndef get_queryset(self):\n        # logic code here\n        queryset = Model.objects.all()\n        return queryset\n```\n\n`serializer_class`同理, 可以通过重写`get_serializer_class`方法添加额外业务处理.\n\n`get_serializer_cotext`方法指定了序列化的上下文, 如在进行超链接关系字段的序列化时就需要用到上下文中的`request`, 但是`GenericView`已经对其进行了更为完善的封装, 在仅需要设定`request`上下文的情况下无需进行更改. 查看父类的`get_serializer_context`可知:\n\n```python\n\n# GenericAPIView\n\ndef get_serializer_context(self):\n        \"\"\"\n        Extra context provided to the serializer class.\n        \"\"\"\n        return {\n                'request': self.request,\n                'format': self.format_kwarg,\n                'view': self\n}\n```\n\n通过GenericView, 之前的视图方法被压缩到仅仅两行, 除此之外, GenericView还会为`POST`请求自动生成一个表单, 如图所示:\n![form](/assets/img/img_202311122320571347.png)\n\n对于这类接口, 甚至仅需要做一下配置便可以快速完成, 不需要额外代码:\n\n```python\n# `store/urls.py`\nurlpatterns = [\n    path('products/', generics.ListCreateAPIView.as_view(\n        queryset=Product.objects.select_related('collection').all(),\n        serializer_class=ProductSerializer\n    )),\n    # other routes...\n]\n```\n\n> 虽然可以通过路由配置文件直接实现通用视图接口, 但不建议这么使用.\n>\n> 1. 后续可能会增加业务逻辑, 一旦增加那么还是要提取到单独的视图类中\n> 2. 配置文件中会引入逻辑代码, 以及额外的导入似的后期不便于维护\n>\n> 仅当临时测试新建接口时用一用就可以了.\n>\n{: .prompt-tip}\n","slug":"django-rest-generic-view","published":1,"updated":"2023-12-13T08:41:08.348Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v2001si3ere06y0anh","content":"<p>在之前的代码中, 基本实现了对于<code>Prodcut</code>和<code>Collection</code>的增删改查接口.</p>\n<p>但是在API的实现代码中存在着大量几乎相同的代码, 如:</p>\n<pre><code class=\"python\"># ProductList\ndef get(self, request):\n        queryset = Product.objects.all()\n        serializer = ProductSerializer(queryset, many=True,\n                                       context=&#123;&#39;request&#39;: request&#125;)\n        return Response(serializer.data)\n\n# CollectionList\ndef get(self, request: Request):\n        queryset = Collection.objects.all().annotate(products_count=Count(&#39;products&#39;))\n        serializer = CollectionSerializer(queryset, many=True)\n        return Response(serializer.data)\n</code></pre>\n<p>他们本质上是相同的功能, 只是处理的目标对象不同, 而编码模式也是几乎一样.</p>\n<p>为了减少这种类似的重复编码, 就可以使用<code>rest Framework</code>所提供的<code>generic view</code>来实现</p>\n<h2 id=\"通用视图\"><a href=\"#通用视图\" class=\"headerlink\" title=\"通用视图\"></a>通用视图</h2><p>rest framework提供了多种通用视图, 统一封装在 <code>rest_framework.generic</code> 包下.</p>\n<p><a href=\"https://www.django-rest-framework.org/api-guide/generic-views/#generic-views\">详细官方文档</a></p>\n<p>以<code>ProductList</code>视图为例, 由于接口能够处理<code>GET</code>和<code>POST</code>请求, 同时返回的是一个结果集, 就可以直接使用<code>ListCreateAPIView</code>来快速实现:</p>\n<pre><code class=\"python\">class ProductList(generics.ListCreateAPIView):\n\n    serializer_class = ProductSerializer\n    queryset = Product.objects.select_related(&#39;collection&#39;).all()\n</code></pre>\n<blockquote>\n<p>注意: <code>serializer_class</code>的值是类而不是对象, 不能加<code>()</code><br>{: .prompt-warning}</p>\n</blockquote>\n<p>由于<code>products/</code>路由在查询时需要查询关联的<code>collection</code>, 所以需要重写<code>get_queryset</code>方法来完善代码逻辑.</p>\n<p>如果在查询时存在其他的业务需求, 比如根据用户类型和权限进行不同的查询等等, 则需要重写<code>get_queryset</code>方法:</p>\n<pre><code class=\"python\">def get_queryset(self):\n        # logic code here\n        queryset = Model.objects.all()\n        return queryset\n</code></pre>\n<p><code>serializer_class</code>同理, 可以通过重写<code>get_serializer_class</code>方法添加额外业务处理.</p>\n<p><code>get_serializer_cotext</code>方法指定了序列化的上下文, 如在进行超链接关系字段的序列化时就需要用到上下文中的<code>request</code>, 但是<code>GenericView</code>已经对其进行了更为完善的封装, 在仅需要设定<code>request</code>上下文的情况下无需进行更改. 查看父类的<code>get_serializer_context</code>可知:</p>\n<pre><code class=\"python\">\n# GenericAPIView\n\ndef get_serializer_context(self):\n        &quot;&quot;&quot;\n        Extra context provided to the serializer class.\n        &quot;&quot;&quot;\n        return &#123;\n                &#39;request&#39;: self.request,\n                &#39;format&#39;: self.format_kwarg,\n                &#39;view&#39;: self\n&#125;\n</code></pre>\n<p>通过GenericView, 之前的视图方法被压缩到仅仅两行, 除此之外, GenericView还会为<code>POST</code>请求自动生成一个表单, 如图所示:<br><img src=\"/assets/img/img_202311122320571347.png\" alt=\"form\"></p>\n<p>对于这类接口, 甚至仅需要做一下配置便可以快速完成, 不需要额外代码:</p>\n<pre><code class=\"python\"># `store/urls.py`\nurlpatterns = [\n    path(&#39;products/&#39;, generics.ListCreateAPIView.as_view(\n        queryset=Product.objects.select_related(&#39;collection&#39;).all(),\n        serializer_class=ProductSerializer\n    )),\n    # other routes...\n]\n</code></pre>\n<blockquote>\n<p>虽然可以通过路由配置文件直接实现通用视图接口, 但不建议这么使用.</p>\n<ol>\n<li>后续可能会增加业务逻辑, 一旦增加那么还是要提取到单独的视图类中</li>\n<li>配置文件中会引入逻辑代码, 以及额外的导入似的后期不便于维护</li>\n</ol>\n<p>仅当临时测试新建接口时用一用就可以了.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>在之前的代码中, 基本实现了对于<code>Prodcut</code>和<code>Collection</code>的增删改查接口.</p>\n<p>但是在API的实现代码中存在着大量几乎相同的代码, 如:</p>\n<pre><code class=\"python\"># ProductList\ndef get(self, request):\n        queryset = Product.objects.all()\n        serializer = ProductSerializer(queryset, many=True,\n                                       context=&#123;&#39;request&#39;: request&#125;)\n        return Response(serializer.data)\n\n# CollectionList\ndef get(self, request: Request):\n        queryset = Collection.objects.all().annotate(products_count=Count(&#39;products&#39;))\n        serializer = CollectionSerializer(queryset, many=True)\n        return Response(serializer.data)\n</code></pre>\n<p>他们本质上是相同的功能, 只是处理的目标对象不同, 而编码模式也是几乎一样.</p>\n<p>为了减少这种类似的重复编码, 就可以使用<code>rest Framework</code>所提供的<code>generic view</code>来实现</p>\n<h2 id=\"通用视图\"><a href=\"#通用视图\" class=\"headerlink\" title=\"通用视图\"></a>通用视图</h2><p>rest framework提供了多种通用视图, 统一封装在 <code>rest_framework.generic</code> 包下.</p>\n<p><a href=\"https://www.django-rest-framework.org/api-guide/generic-views/#generic-views\">详细官方文档</a></p>\n<p>以<code>ProductList</code>视图为例, 由于接口能够处理<code>GET</code>和<code>POST</code>请求, 同时返回的是一个结果集, 就可以直接使用<code>ListCreateAPIView</code>来快速实现:</p>\n<pre><code class=\"python\">class ProductList(generics.ListCreateAPIView):\n\n    serializer_class = ProductSerializer\n    queryset = Product.objects.select_related(&#39;collection&#39;).all()\n</code></pre>\n<blockquote>\n<p>注意: <code>serializer_class</code>的值是类而不是对象, 不能加<code>()</code><br>{: .prompt-warning}</p>\n</blockquote>\n<p>由于<code>products/</code>路由在查询时需要查询关联的<code>collection</code>, 所以需要重写<code>get_queryset</code>方法来完善代码逻辑.</p>\n<p>如果在查询时存在其他的业务需求, 比如根据用户类型和权限进行不同的查询等等, 则需要重写<code>get_queryset</code>方法:</p>\n<pre><code class=\"python\">def get_queryset(self):\n        # logic code here\n        queryset = Model.objects.all()\n        return queryset\n</code></pre>\n<p><code>serializer_class</code>同理, 可以通过重写<code>get_serializer_class</code>方法添加额外业务处理.</p>\n<p><code>get_serializer_cotext</code>方法指定了序列化的上下文, 如在进行超链接关系字段的序列化时就需要用到上下文中的<code>request</code>, 但是<code>GenericView</code>已经对其进行了更为完善的封装, 在仅需要设定<code>request</code>上下文的情况下无需进行更改. 查看父类的<code>get_serializer_context</code>可知:</p>\n<pre><code class=\"python\">\n# GenericAPIView\n\ndef get_serializer_context(self):\n        &quot;&quot;&quot;\n        Extra context provided to the serializer class.\n        &quot;&quot;&quot;\n        return &#123;\n                &#39;request&#39;: self.request,\n                &#39;format&#39;: self.format_kwarg,\n                &#39;view&#39;: self\n&#125;\n</code></pre>\n<p>通过GenericView, 之前的视图方法被压缩到仅仅两行, 除此之外, GenericView还会为<code>POST</code>请求自动生成一个表单, 如图所示:<br><img src=\"/assets/img/img_202311122320571347.png\" alt=\"form\"></p>\n<p>对于这类接口, 甚至仅需要做一下配置便可以快速完成, 不需要额外代码:</p>\n<pre><code class=\"python\"># `store/urls.py`\nurlpatterns = [\n    path(&#39;products/&#39;, generics.ListCreateAPIView.as_view(\n        queryset=Product.objects.select_related(&#39;collection&#39;).all(),\n        serializer_class=ProductSerializer\n    )),\n    # other routes...\n]\n</code></pre>\n<blockquote>\n<p>虽然可以通过路由配置文件直接实现通用视图接口, 但不建议这么使用.</p>\n<ol>\n<li>后续可能会增加业务逻辑, 一旦增加那么还是要提取到单独的视图类中</li>\n<li>配置文件中会引入逻辑代码, 以及额外的导入似的后期不便于维护</li>\n</ol>\n<p>仅当临时测试新建接口时用一用就可以了.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n"},{"title":"12. REST 模型序列化","date":"2023-12-13T08:41:08.348Z","_content":"\n之前的序列化对象继承自`serializers.Serializer`, 功能很强大, 但问题在于重复代码太多.\n\n在Product模型中定义了`title = models.CharField(max_length=255)`\n\n而在ProductSerializer中则要定义`title = serializers.CharField(max_length=255)`\n\n几乎一样的代码, 只是类型发生变化, 但却实实在在的需要写两遍, 而且一旦修改模型, 序列化对象也要一同修改.\n\n显然这并不是一个好的解决方案. 事实上, `serializers.Serializer`本身便是为了序列化普通的Python对象而存在的.\n\n而对于Django模型类, Django REST Framework提供了另外一种方式: `ModelSerializer`.\n\n[官方文档](https://www.django-rest-framework.org/api-guide/serializers/#modelserializer)\n\n---\n\n## 创建模型序列化对象\n\n```python\nclass CollectionSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Collection\n        fields = ['id', 'title']\n```\n\n只是单纯的对`id`和`title`进行了序列化, 与之前定义的`CollectionSerializer`类的功能完全一样.\n\n仅需要简单的声明`class Meta`, 并列出需要的字段即可.\n\n与之相比, ProductSerializer则会相对复杂一些, 重写后的代码如下:\n\n```python\nclass ProductSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Product\n        fields = ['id', 'title', 'price', 'price_with_tax', 'collection']\n\n    # 对`unit_price` 字段进行了重名民\n    price = serializers.DecimalField(max_digits=6,\n                                     decimal_places=2,\n                                     source=\"unit_price\")\n\n    # 添加了模型类中不存在的字段, 并定义了其数据生成方法\n    price_with_tax = serializers.SerializerMethodField(\n        method_name=\"calc_price_with_tax\")\n\n    # 修改了字段的数据类型\n    collection = serializers.HyperlinkedRelatedField(\n        read_only=True,\n        view_name='collection-detail'\n    )\n\n    def calc_price_with_tax(self, product: Product):\n        return product.unit_price * Decimal(1.17)\n\n```\n\n可以看出, 模型序列化可以简化大量的编码.\n\n* 对于同名, 同类型的字段, 仅需要在字段列表中列出即可.\n* 不同名但是同值的字段, 在列表中定义字段名, 编写成员变量, 并为其指定模型字段\n* 模型中不存在的字段, 在列表中声明, 然后定义同名的成员变量\n* 模型和字段列表中都有, 但是声明了同名成员变量的字段, 以成员变量的序列化声明为准.\n\n> 对于`fields`成员, 可以使用`__all__`来声明包含全部的模型字段.\n> 但这是一种非常不好的习惯, 看似简单方便之下隐藏着重大隐患.\n>\n> * 模型的全部字段将暴露在接口之中, 可能泄露隐藏信息\n> * 模型类修改后, 接口也会发生变动, 破坏了接口不变原则\n>\n> > *Only lazy programmers will do that. You don't want to be one of them.\n>\n{: .prompt-warning}\n\n> 但是对于字段较多的模型, 同样有简化的方法:\n>\n> 通过`exclude=[fields]`来排除特定字段,同时包含其余字段即可.\n>\n{: .prompt-tip}\n","source":"_posts/django/rest-model-serializer.md","raw":"---\ntitle: 12. REST 模型序列化\ndate: 2023-11-12 00:10:52 +08000\ncategories: [笔记, Django]\ntags: [python, django, backend]\n---\n\n之前的序列化对象继承自`serializers.Serializer`, 功能很强大, 但问题在于重复代码太多.\n\n在Product模型中定义了`title = models.CharField(max_length=255)`\n\n而在ProductSerializer中则要定义`title = serializers.CharField(max_length=255)`\n\n几乎一样的代码, 只是类型发生变化, 但却实实在在的需要写两遍, 而且一旦修改模型, 序列化对象也要一同修改.\n\n显然这并不是一个好的解决方案. 事实上, `serializers.Serializer`本身便是为了序列化普通的Python对象而存在的.\n\n而对于Django模型类, Django REST Framework提供了另外一种方式: `ModelSerializer`.\n\n[官方文档](https://www.django-rest-framework.org/api-guide/serializers/#modelserializer)\n\n---\n\n## 创建模型序列化对象\n\n```python\nclass CollectionSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Collection\n        fields = ['id', 'title']\n```\n\n只是单纯的对`id`和`title`进行了序列化, 与之前定义的`CollectionSerializer`类的功能完全一样.\n\n仅需要简单的声明`class Meta`, 并列出需要的字段即可.\n\n与之相比, ProductSerializer则会相对复杂一些, 重写后的代码如下:\n\n```python\nclass ProductSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Product\n        fields = ['id', 'title', 'price', 'price_with_tax', 'collection']\n\n    # 对`unit_price` 字段进行了重名民\n    price = serializers.DecimalField(max_digits=6,\n                                     decimal_places=2,\n                                     source=\"unit_price\")\n\n    # 添加了模型类中不存在的字段, 并定义了其数据生成方法\n    price_with_tax = serializers.SerializerMethodField(\n        method_name=\"calc_price_with_tax\")\n\n    # 修改了字段的数据类型\n    collection = serializers.HyperlinkedRelatedField(\n        read_only=True,\n        view_name='collection-detail'\n    )\n\n    def calc_price_with_tax(self, product: Product):\n        return product.unit_price * Decimal(1.17)\n\n```\n\n可以看出, 模型序列化可以简化大量的编码.\n\n* 对于同名, 同类型的字段, 仅需要在字段列表中列出即可.\n* 不同名但是同值的字段, 在列表中定义字段名, 编写成员变量, 并为其指定模型字段\n* 模型中不存在的字段, 在列表中声明, 然后定义同名的成员变量\n* 模型和字段列表中都有, 但是声明了同名成员变量的字段, 以成员变量的序列化声明为准.\n\n> 对于`fields`成员, 可以使用`__all__`来声明包含全部的模型字段.\n> 但这是一种非常不好的习惯, 看似简单方便之下隐藏着重大隐患.\n>\n> * 模型的全部字段将暴露在接口之中, 可能泄露隐藏信息\n> * 模型类修改后, 接口也会发生变动, 破坏了接口不变原则\n>\n> > *Only lazy programmers will do that. You don't want to be one of them.\n>\n{: .prompt-warning}\n\n> 但是对于字段较多的模型, 同样有简化的方法:\n>\n> 通过`exclude=[fields]`来排除特定字段,同时包含其余字段即可.\n>\n{: .prompt-tip}\n","slug":"django-rest-model-serializer","published":1,"updated":"2023-12-13T08:41:08.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v3001vi3erc4qf2j23","content":"<p>之前的序列化对象继承自<code>serializers.Serializer</code>, 功能很强大, 但问题在于重复代码太多.</p>\n<p>在Product模型中定义了<code>title = models.CharField(max_length=255)</code></p>\n<p>而在ProductSerializer中则要定义<code>title = serializers.CharField(max_length=255)</code></p>\n<p>几乎一样的代码, 只是类型发生变化, 但却实实在在的需要写两遍, 而且一旦修改模型, 序列化对象也要一同修改.</p>\n<p>显然这并不是一个好的解决方案. 事实上, <code>serializers.Serializer</code>本身便是为了序列化普通的Python对象而存在的.</p>\n<p>而对于Django模型类, Django REST Framework提供了另外一种方式: <code>ModelSerializer</code>.</p>\n<p><a href=\"https://www.django-rest-framework.org/api-guide/serializers/#modelserializer\">官方文档</a></p>\n<hr>\n<h2 id=\"创建模型序列化对象\"><a href=\"#创建模型序列化对象\" class=\"headerlink\" title=\"创建模型序列化对象\"></a>创建模型序列化对象</h2><pre><code class=\"python\">class CollectionSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Collection\n        fields = [&#39;id&#39;, &#39;title&#39;]\n</code></pre>\n<p>只是单纯的对<code>id</code>和<code>title</code>进行了序列化, 与之前定义的<code>CollectionSerializer</code>类的功能完全一样.</p>\n<p>仅需要简单的声明<code>class Meta</code>, 并列出需要的字段即可.</p>\n<p>与之相比, ProductSerializer则会相对复杂一些, 重写后的代码如下:</p>\n<pre><code class=\"python\">class ProductSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Product\n        fields = [&#39;id&#39;, &#39;title&#39;, &#39;price&#39;, &#39;price_with_tax&#39;, &#39;collection&#39;]\n\n    # 对`unit_price` 字段进行了重名民\n    price = serializers.DecimalField(max_digits=6,\n                                     decimal_places=2,\n                                     source=&quot;unit_price&quot;)\n\n    # 添加了模型类中不存在的字段, 并定义了其数据生成方法\n    price_with_tax = serializers.SerializerMethodField(\n        method_name=&quot;calc_price_with_tax&quot;)\n\n    # 修改了字段的数据类型\n    collection = serializers.HyperlinkedRelatedField(\n        read_only=True,\n        view_name=&#39;collection-detail&#39;\n    )\n\n    def calc_price_with_tax(self, product: Product):\n        return product.unit_price * Decimal(1.17)\n</code></pre>\n<p>可以看出, 模型序列化可以简化大量的编码.</p>\n<ul>\n<li>对于同名, 同类型的字段, 仅需要在字段列表中列出即可.</li>\n<li>不同名但是同值的字段, 在列表中定义字段名, 编写成员变量, 并为其指定模型字段</li>\n<li>模型中不存在的字段, 在列表中声明, 然后定义同名的成员变量</li>\n<li>模型和字段列表中都有, 但是声明了同名成员变量的字段, 以成员变量的序列化声明为准.</li>\n</ul>\n<blockquote>\n<p>对于<code>fields</code>成员, 可以使用<code>__all__</code>来声明包含全部的模型字段.<br>但这是一种非常不好的习惯, 看似简单方便之下隐藏着重大隐患.</p>\n<ul>\n<li>模型的全部字段将暴露在接口之中, 可能泄露隐藏信息</li>\n<li>模型类修改后, 接口也会发生变动, 破坏了接口不变原则</li>\n</ul>\n<blockquote>\n<p>*Only lazy programmers will do that. You don’t want to be one of them.</p>\n</blockquote>\n</blockquote>\n<p>{: .prompt-warning}</p>\n<blockquote>\n<p>但是对于字段较多的模型, 同样有简化的方法:</p>\n<p>通过<code>exclude=[fields]</code>来排除特定字段,同时包含其余字段即可.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>之前的序列化对象继承自<code>serializers.Serializer</code>, 功能很强大, 但问题在于重复代码太多.</p>\n<p>在Product模型中定义了<code>title = models.CharField(max_length=255)</code></p>\n<p>而在ProductSerializer中则要定义<code>title = serializers.CharField(max_length=255)</code></p>\n<p>几乎一样的代码, 只是类型发生变化, 但却实实在在的需要写两遍, 而且一旦修改模型, 序列化对象也要一同修改.</p>\n<p>显然这并不是一个好的解决方案. 事实上, <code>serializers.Serializer</code>本身便是为了序列化普通的Python对象而存在的.</p>\n<p>而对于Django模型类, Django REST Framework提供了另外一种方式: <code>ModelSerializer</code>.</p>\n<p><a href=\"https://www.django-rest-framework.org/api-guide/serializers/#modelserializer\">官方文档</a></p>\n<hr>\n<h2 id=\"创建模型序列化对象\"><a href=\"#创建模型序列化对象\" class=\"headerlink\" title=\"创建模型序列化对象\"></a>创建模型序列化对象</h2><pre><code class=\"python\">class CollectionSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Collection\n        fields = [&#39;id&#39;, &#39;title&#39;]\n</code></pre>\n<p>只是单纯的对<code>id</code>和<code>title</code>进行了序列化, 与之前定义的<code>CollectionSerializer</code>类的功能完全一样.</p>\n<p>仅需要简单的声明<code>class Meta</code>, 并列出需要的字段即可.</p>\n<p>与之相比, ProductSerializer则会相对复杂一些, 重写后的代码如下:</p>\n<pre><code class=\"python\">class ProductSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Product\n        fields = [&#39;id&#39;, &#39;title&#39;, &#39;price&#39;, &#39;price_with_tax&#39;, &#39;collection&#39;]\n\n    # 对`unit_price` 字段进行了重名民\n    price = serializers.DecimalField(max_digits=6,\n                                     decimal_places=2,\n                                     source=&quot;unit_price&quot;)\n\n    # 添加了模型类中不存在的字段, 并定义了其数据生成方法\n    price_with_tax = serializers.SerializerMethodField(\n        method_name=&quot;calc_price_with_tax&quot;)\n\n    # 修改了字段的数据类型\n    collection = serializers.HyperlinkedRelatedField(\n        read_only=True,\n        view_name=&#39;collection-detail&#39;\n    )\n\n    def calc_price_with_tax(self, product: Product):\n        return product.unit_price * Decimal(1.17)\n</code></pre>\n<p>可以看出, 模型序列化可以简化大量的编码.</p>\n<ul>\n<li>对于同名, 同类型的字段, 仅需要在字段列表中列出即可.</li>\n<li>不同名但是同值的字段, 在列表中定义字段名, 编写成员变量, 并为其指定模型字段</li>\n<li>模型中不存在的字段, 在列表中声明, 然后定义同名的成员变量</li>\n<li>模型和字段列表中都有, 但是声明了同名成员变量的字段, 以成员变量的序列化声明为准.</li>\n</ul>\n<blockquote>\n<p>对于<code>fields</code>成员, 可以使用<code>__all__</code>来声明包含全部的模型字段.<br>但这是一种非常不好的习惯, 看似简单方便之下隐藏着重大隐患.</p>\n<ul>\n<li>模型的全部字段将暴露在接口之中, 可能泄露隐藏信息</li>\n<li>模型类修改后, 接口也会发生变动, 破坏了接口不变原则</li>\n</ul>\n<blockquote>\n<p>*Only lazy programmers will do that. You don’t want to be one of them.</p>\n</blockquote>\n</blockquote>\n<p>{: .prompt-warning}</p>\n<blockquote>\n<p>但是对于字段较多的模型, 同样有简化的方法:</p>\n<p>通过<code>exclude=[fields]</code>来排除特定字段,同时包含其余字段即可.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n"},{"title":"Django 常用基础配置","date":"2023-12-13T08:41:08.347Z","_content":"\n## django-debug-toolbar基础配置\n\n```python\n# settings.py\nINSTALLED_APPS = [\n    # ...\n    \"debug_toolbar\",\n    # ...\n]\n\nMIDDLEWARE = [\n    \"debug_toolbar.middleware.DebugToolbarMiddleware\",\n    # ...\n]\n\n# 直接添加在`settings.py`文件中 \nINTERNAL_IPS = [\n    \"127.0.0.1\",\n]\n\n# urls.py\nfrom django.urls import include, path\n\nurlpatterns = [\n    # ...\n    path(\"__debug__/\", include(\"debug_toolbar.urls\")),\n]\n\n```\n\n## MySQL基础配置\n\n```python\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'storefront',\n        'HOST': 'localhost',\n        \"USER\": 'root',\n        \"PASSWORD\": 'pass'\n    }\n}\n```\n","source":"_posts/django/basic-config.md","raw":"---\ntitle: Django 常用基础配置\ndate: 2023-11-11 13:59:45 +08000\ncategories: [速查, 配置]\ntags: [django, config]\n---\n\n## django-debug-toolbar基础配置\n\n```python\n# settings.py\nINSTALLED_APPS = [\n    # ...\n    \"debug_toolbar\",\n    # ...\n]\n\nMIDDLEWARE = [\n    \"debug_toolbar.middleware.DebugToolbarMiddleware\",\n    # ...\n]\n\n# 直接添加在`settings.py`文件中 \nINTERNAL_IPS = [\n    \"127.0.0.1\",\n]\n\n# urls.py\nfrom django.urls import include, path\n\nurlpatterns = [\n    # ...\n    path(\"__debug__/\", include(\"debug_toolbar.urls\")),\n]\n\n```\n\n## MySQL基础配置\n\n```python\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'storefront',\n        'HOST': 'localhost',\n        \"USER\": 'root',\n        \"PASSWORD\": 'pass'\n    }\n}\n```\n","slug":"django-basic-config","published":1,"updated":"2023-12-13T08:41:08.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v3001yi3er3s8x7vrc","content":"<h2 id=\"django-debug-toolbar基础配置\"><a href=\"#django-debug-toolbar基础配置\" class=\"headerlink\" title=\"django-debug-toolbar基础配置\"></a>django-debug-toolbar基础配置</h2><pre><code class=\"python\"># settings.py\nINSTALLED_APPS = [\n    # ...\n    &quot;debug_toolbar&quot;,\n    # ...\n]\n\nMIDDLEWARE = [\n    &quot;debug_toolbar.middleware.DebugToolbarMiddleware&quot;,\n    # ...\n]\n\n# 直接添加在`settings.py`文件中 \nINTERNAL_IPS = [\n    &quot;127.0.0.1&quot;,\n]\n\n# urls.py\nfrom django.urls import include, path\n\nurlpatterns = [\n    # ...\n    path(&quot;__debug__/&quot;, include(&quot;debug_toolbar.urls&quot;)),\n]\n</code></pre>\n<h2 id=\"MySQL基础配置\"><a href=\"#MySQL基础配置\" class=\"headerlink\" title=\"MySQL基础配置\"></a>MySQL基础配置</h2><pre><code class=\"python\">DATABASES = &#123;\n    &#39;default&#39;: &#123;\n        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,\n        &#39;NAME&#39;: &#39;storefront&#39;,\n        &#39;HOST&#39;: &#39;localhost&#39;,\n        &quot;USER&quot;: &#39;root&#39;,\n        &quot;PASSWORD&quot;: &#39;pass&#39;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"django-debug-toolbar基础配置\"><a href=\"#django-debug-toolbar基础配置\" class=\"headerlink\" title=\"django-debug-toolbar基础配置\"></a>django-debug-toolbar基础配置</h2><pre><code class=\"python\"># settings.py\nINSTALLED_APPS = [\n    # ...\n    &quot;debug_toolbar&quot;,\n    # ...\n]\n\nMIDDLEWARE = [\n    &quot;debug_toolbar.middleware.DebugToolbarMiddleware&quot;,\n    # ...\n]\n\n# 直接添加在`settings.py`文件中 \nINTERNAL_IPS = [\n    &quot;127.0.0.1&quot;,\n]\n\n# urls.py\nfrom django.urls import include, path\n\nurlpatterns = [\n    # ...\n    path(&quot;__debug__/&quot;, include(&quot;debug_toolbar.urls&quot;)),\n]\n</code></pre>\n<h2 id=\"MySQL基础配置\"><a href=\"#MySQL基础配置\" class=\"headerlink\" title=\"MySQL基础配置\"></a>MySQL基础配置</h2><pre><code class=\"python\">DATABASES = &#123;\n    &#39;default&#39;: &#123;\n        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,\n        &#39;NAME&#39;: &#39;storefront&#39;,\n        &#39;HOST&#39;: &#39;localhost&#39;,\n        &quot;USER&quot;: &#39;root&#39;,\n        &quot;PASSWORD&quot;: &#39;pass&#39;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"14. Django REST framework 数据修改","date":"2023-11-12T08:18:57.000Z","_content":"\n## 保存数据\n\n对于简单数据的表单, rest framework 提供了很简单的数据保存方式.\n\n比如, 按照之前的内容, 新增一个`collection_list`视图方法, 用于对`Collection`进行获取和新增\n\n```python\n@api_view(['GET', 'POST'])\ndef collection_list(request):\n    if request.method == 'GET':\n        queryset = Collection.objects.all()\n        serializer = CollectionSerializer(queryset, many=True)\n        return Response(serializer.data)\n\n    if request.method == 'POST':\n        serializer = CollectionSerializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data, status=status.HTTP_201_CREATED)\n```\n\n通过URL:`/store/collections/`发送POST请求进行接口测试:\n\n```python\n# HTTP 201 Created\n# Allow: POST, OPTIONS, GET\n# Content-Type: application/json\n# Vary: Accept\n\n{\n    \"id\": 11,\n    \"title\": \"new collection\"\n}\n```\n\n通过模型类定义的数据库验证, 以及序列化对象定义的前段数据验证, `is_valid()`方法便可以保证数据的有效性, 并通过`sava()`方法直接进行保存.\n\n但有时仍然需要进行一些其他的操作, 比如处理前段不可见的隐藏字段, 生成日志文件等等.\n\n`ModelSeriallizer`提供了两个方法, 用于处理数据的新增和更新, 分别是`create`和`update`.\n\n仅需要重写这两个方法, RESTFramework会根据请求类型自动进行调用. 代码如下:\n\n```python\nclass CollectionSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Collection\n        fields = ['id', 'title']\n\n    def create(self, validated_data):\n        collection = Collection(**validated_data)\n        print(collection.title)\n        collection.save()\n        return collection\n\n    def update(self, instance, validated_data):\n        print(\"OLD TITLE:\", instance.title, \"-\",\n              \"NEW TITLE:\", validated_data.get('title'))\n        instance.title = validated_data.get('title')\n        instance.save()\n        return instance\n```\n\n## 更新数据\n\n数据的更新通过`PUT`和`PATCH`两种请求方式完成\n\n* `PUT`: PUT请求在传输时,要求一次性将请求所用的数据传输完成,即必须将所有的请求数据都完整地发送到服务器端.\n* `PATCH`: PATCH请求可以对资源进行部分修改,即客户端只需将要修改的部分发送给服务器,而无需将整个数据实体发送给服务器.因此,PATCH方法可以在节省带宽的同时提高效率,并可以支持增量更新.\n\n两种方式的区别在于:\n\n1. 数据传输方式不同: PUT请求要求一次性将请求所需的所有数据传输完毕,而PATCH请求只传输要修改的部分数据,节约了带宽和传输时间.\n2. 适用场景不同: PUT请求通常用于更新和替换整个资源,而PATCH请求则适用于对资源进行部分修改,可以在不修改整个资源的情况下实现增量更新.\n3. 安全性不同: 由于PUT请求要求一次性发送所有数据,因此可能会存在重复更新或错误更新等问题.而PATCH请求只更新要修改的部分数据,因此更加安全,不易出错.\n\n修改`product_detail`视图方法:\n\n```python\n@api_view(['GET', 'PUT', 'PATCH'])\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n\n    if request.method == 'GET':\n        serializer = ProductSerializer(product)\n        return Response(serializer.data)\n\n    if request.method == 'PUT':\n        serializer = ProductSerializer(product, data=request.data)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    if request.method == 'PATCH':\n        serializer = ProductSerializer(\n            product, data=request.data, partial=True)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n```\n\n`GET`方式的实现代码与之前没有太大区别, `PUT`与`PATCH`的实现代码也没有太大区别.\n\n但是`PATCH`方法在进行序列化对象初始化的时候有一个额外关键字参数: `partial=True`\n\n> 这一参数表示允许进行部分字段的更新! 如果没有声明这一参数, 那么`PUT`和`PATCH`的处理方式将完全相同.\n{: .prompt-info}\n\n通过`PUT`和`PATCH`两种请求向`store/product/1001`发送测试数据:\n\n```json\n{ \"price\": 100}\n```\n\n`PUT`请求结果:\n\n```python\n# HTTP 400 Bad Request\n# Allow: PATCH, GET, PUT, OPTIONS\n# Content-Type: application/json\n# Vary: Accept\n\n{\n    \"title\": [\n        \"该字段是必填项。\"\n    ],\n    \"inventory\": [\n        \"该字段是必填项。\"\n    ],\n    \"collection\": [\n        \"该字段是必填项。\"\n    ]\n}\n```\n\n`PATCH`请求结果:\n\n```python\n# HTTP 200 OK\n# Allow: PATCH, GET, PUT, OPTIONS\n# Content-Type: application/json\n# Vary: Accept\n\n{\n    \"id\": 1001,\n    \"title\": \"Dried Peach\",\n    \"inventory\": 39,\n    \"price\": 100.0,\n    \"price_with_tax\": 117.0,\n    \"collection\": 4\n}\n```\n\n假设一个用户更新昵称的需求, 显然其他的用户资料并没有变动, 仅仅只是修改了昵称\n\n虽然可以通过默认加载原始数据到表单中, 在发送更新数据时同时发送未修改的原始数据.\n\n但这无疑是对带宽和用户流量的浪费, 也造成了不必要的数据库读写.\n\n在`PUT`和`PATCH`的代码逻辑几乎一样的情况下, 可以把上面的代码进行一下优化:\n\n```python\n@api_view(['GET', 'PUT', 'PATCH', 'DELETE'])\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n    \n    # other code...\n\n    if request.method in ['PUT', 'PATCH']:\n        serializer = ProductSerializer(product,\n                                       data=request.data,\n                                       partial=request.method == 'PATCH')\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    # other code ...\n```\n\n## 删除数据\n\n删除数据作为一项危险操作, 应当进行充分的操作确认, 既要对用户进行删除操作确认, 对于重要内容的删除也可以进行密码确认.\n而在服务端进行删除之前同样要进行各种操作, 如是否可以删除的判断, 用户操作权限的查询等.\n\n但是排除所有的确认, 删除操作本身非常简单.\n\n```python\n@api_view(['GET', 'PUT', 'PATCH', 'DELETE'])\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n\n    # other code ...\n\n    if request.method == 'DELETE':\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n\n向`store/product/1`发送`DELETE`请求, 得到如下提示:\n\n```text\nProtectedError at /store/products/1/\n(\"Cannot delete some instances of model 'Product' \nbecause they are referenced through protected foreign keys: \n    'OrderItem.product'.\", {<OrderItem: OrderItem object (40)>, <OrderItem: OrderItem object (765)>})\n```\n\n其原因在于`OrderItem`类中定义了`Product`外键, 并组织了其删除操作:\n\n```python\nclass OrderItem(models.Model):\n    order = models.ForeignKey(Order, on_delete=models.PROTECT)\n    # here\n    product = models.ForeignKey(Product, on_delete=models.PROTECT)\n    quantity = models.PositiveSmallIntegerField()\n    unit_price = models.DecimalField(max_digits=6, decimal_places=2)\n```\n\n如果不进行任何处理便直接进行删除操作, 便有可能使得程序出现异常:\n\n![exception](/assets/img/img_202311121735237199.png)\n\n可以在删除前进行判断, 代码如下:\n\n```python\n@api_view(['GET', 'PUT', 'PATCH', 'DELETE'])\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n\n    # other code ...\n\n    if request.method == 'DELETE':\n        if product.orderitem_set.count() > 0:\n            return Response({'error': 'Product has been ordered.'},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n\n再次发送删除请求, 获得回复:\n\n```python\n# HTTP 405 Method Not Allowed\n# Allow: GET, DELETE, OPTIONS, PUT, PATCH\n# Content-Type: application/json\n# Vary: Accept\n\n{\n    \"error\": \"Product has been ordered.\"\n}\n```\n","source":"_posts/django/rest-save-update-delete.md","raw":"---\ntitle: 14. Django REST framework 数据修改\ndate: 2023-11-12 16:18:57 +0800\ncategories: [笔记, Django]\ntags: [python, django, backend, REST]\n---\n\n## 保存数据\n\n对于简单数据的表单, rest framework 提供了很简单的数据保存方式.\n\n比如, 按照之前的内容, 新增一个`collection_list`视图方法, 用于对`Collection`进行获取和新增\n\n```python\n@api_view(['GET', 'POST'])\ndef collection_list(request):\n    if request.method == 'GET':\n        queryset = Collection.objects.all()\n        serializer = CollectionSerializer(queryset, many=True)\n        return Response(serializer.data)\n\n    if request.method == 'POST':\n        serializer = CollectionSerializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data, status=status.HTTP_201_CREATED)\n```\n\n通过URL:`/store/collections/`发送POST请求进行接口测试:\n\n```python\n# HTTP 201 Created\n# Allow: POST, OPTIONS, GET\n# Content-Type: application/json\n# Vary: Accept\n\n{\n    \"id\": 11,\n    \"title\": \"new collection\"\n}\n```\n\n通过模型类定义的数据库验证, 以及序列化对象定义的前段数据验证, `is_valid()`方法便可以保证数据的有效性, 并通过`sava()`方法直接进行保存.\n\n但有时仍然需要进行一些其他的操作, 比如处理前段不可见的隐藏字段, 生成日志文件等等.\n\n`ModelSeriallizer`提供了两个方法, 用于处理数据的新增和更新, 分别是`create`和`update`.\n\n仅需要重写这两个方法, RESTFramework会根据请求类型自动进行调用. 代码如下:\n\n```python\nclass CollectionSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Collection\n        fields = ['id', 'title']\n\n    def create(self, validated_data):\n        collection = Collection(**validated_data)\n        print(collection.title)\n        collection.save()\n        return collection\n\n    def update(self, instance, validated_data):\n        print(\"OLD TITLE:\", instance.title, \"-\",\n              \"NEW TITLE:\", validated_data.get('title'))\n        instance.title = validated_data.get('title')\n        instance.save()\n        return instance\n```\n\n## 更新数据\n\n数据的更新通过`PUT`和`PATCH`两种请求方式完成\n\n* `PUT`: PUT请求在传输时,要求一次性将请求所用的数据传输完成,即必须将所有的请求数据都完整地发送到服务器端.\n* `PATCH`: PATCH请求可以对资源进行部分修改,即客户端只需将要修改的部分发送给服务器,而无需将整个数据实体发送给服务器.因此,PATCH方法可以在节省带宽的同时提高效率,并可以支持增量更新.\n\n两种方式的区别在于:\n\n1. 数据传输方式不同: PUT请求要求一次性将请求所需的所有数据传输完毕,而PATCH请求只传输要修改的部分数据,节约了带宽和传输时间.\n2. 适用场景不同: PUT请求通常用于更新和替换整个资源,而PATCH请求则适用于对资源进行部分修改,可以在不修改整个资源的情况下实现增量更新.\n3. 安全性不同: 由于PUT请求要求一次性发送所有数据,因此可能会存在重复更新或错误更新等问题.而PATCH请求只更新要修改的部分数据,因此更加安全,不易出错.\n\n修改`product_detail`视图方法:\n\n```python\n@api_view(['GET', 'PUT', 'PATCH'])\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n\n    if request.method == 'GET':\n        serializer = ProductSerializer(product)\n        return Response(serializer.data)\n\n    if request.method == 'PUT':\n        serializer = ProductSerializer(product, data=request.data)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    if request.method == 'PATCH':\n        serializer = ProductSerializer(\n            product, data=request.data, partial=True)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n```\n\n`GET`方式的实现代码与之前没有太大区别, `PUT`与`PATCH`的实现代码也没有太大区别.\n\n但是`PATCH`方法在进行序列化对象初始化的时候有一个额外关键字参数: `partial=True`\n\n> 这一参数表示允许进行部分字段的更新! 如果没有声明这一参数, 那么`PUT`和`PATCH`的处理方式将完全相同.\n{: .prompt-info}\n\n通过`PUT`和`PATCH`两种请求向`store/product/1001`发送测试数据:\n\n```json\n{ \"price\": 100}\n```\n\n`PUT`请求结果:\n\n```python\n# HTTP 400 Bad Request\n# Allow: PATCH, GET, PUT, OPTIONS\n# Content-Type: application/json\n# Vary: Accept\n\n{\n    \"title\": [\n        \"该字段是必填项。\"\n    ],\n    \"inventory\": [\n        \"该字段是必填项。\"\n    ],\n    \"collection\": [\n        \"该字段是必填项。\"\n    ]\n}\n```\n\n`PATCH`请求结果:\n\n```python\n# HTTP 200 OK\n# Allow: PATCH, GET, PUT, OPTIONS\n# Content-Type: application/json\n# Vary: Accept\n\n{\n    \"id\": 1001,\n    \"title\": \"Dried Peach\",\n    \"inventory\": 39,\n    \"price\": 100.0,\n    \"price_with_tax\": 117.0,\n    \"collection\": 4\n}\n```\n\n假设一个用户更新昵称的需求, 显然其他的用户资料并没有变动, 仅仅只是修改了昵称\n\n虽然可以通过默认加载原始数据到表单中, 在发送更新数据时同时发送未修改的原始数据.\n\n但这无疑是对带宽和用户流量的浪费, 也造成了不必要的数据库读写.\n\n在`PUT`和`PATCH`的代码逻辑几乎一样的情况下, 可以把上面的代码进行一下优化:\n\n```python\n@api_view(['GET', 'PUT', 'PATCH', 'DELETE'])\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n    \n    # other code...\n\n    if request.method in ['PUT', 'PATCH']:\n        serializer = ProductSerializer(product,\n                                       data=request.data,\n                                       partial=request.method == 'PATCH')\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    # other code ...\n```\n\n## 删除数据\n\n删除数据作为一项危险操作, 应当进行充分的操作确认, 既要对用户进行删除操作确认, 对于重要内容的删除也可以进行密码确认.\n而在服务端进行删除之前同样要进行各种操作, 如是否可以删除的判断, 用户操作权限的查询等.\n\n但是排除所有的确认, 删除操作本身非常简单.\n\n```python\n@api_view(['GET', 'PUT', 'PATCH', 'DELETE'])\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n\n    # other code ...\n\n    if request.method == 'DELETE':\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n\n向`store/product/1`发送`DELETE`请求, 得到如下提示:\n\n```text\nProtectedError at /store/products/1/\n(\"Cannot delete some instances of model 'Product' \nbecause they are referenced through protected foreign keys: \n    'OrderItem.product'.\", {<OrderItem: OrderItem object (40)>, <OrderItem: OrderItem object (765)>})\n```\n\n其原因在于`OrderItem`类中定义了`Product`外键, 并组织了其删除操作:\n\n```python\nclass OrderItem(models.Model):\n    order = models.ForeignKey(Order, on_delete=models.PROTECT)\n    # here\n    product = models.ForeignKey(Product, on_delete=models.PROTECT)\n    quantity = models.PositiveSmallIntegerField()\n    unit_price = models.DecimalField(max_digits=6, decimal_places=2)\n```\n\n如果不进行任何处理便直接进行删除操作, 便有可能使得程序出现异常:\n\n![exception](/assets/img/img_202311121735237199.png)\n\n可以在删除前进行判断, 代码如下:\n\n```python\n@api_view(['GET', 'PUT', 'PATCH', 'DELETE'])\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n\n    # other code ...\n\n    if request.method == 'DELETE':\n        if product.orderitem_set.count() > 0:\n            return Response({'error': 'Product has been ordered.'},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n\n再次发送删除请求, 获得回复:\n\n```python\n# HTTP 405 Method Not Allowed\n# Allow: GET, DELETE, OPTIONS, PUT, PATCH\n# Content-Type: application/json\n# Vary: Accept\n\n{\n    \"error\": \"Product has been ordered.\"\n}\n```\n","slug":"django-rest-save-update-delete","published":1,"updated":"2023-12-13T08:41:08.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v30021i3ercres23fu","content":"<h2 id=\"保存数据\"><a href=\"#保存数据\" class=\"headerlink\" title=\"保存数据\"></a>保存数据</h2><p>对于简单数据的表单, rest framework 提供了很简单的数据保存方式.</p>\n<p>比如, 按照之前的内容, 新增一个<code>collection_list</code>视图方法, 用于对<code>Collection</code>进行获取和新增</p>\n<pre><code class=\"python\">@api_view([&#39;GET&#39;, &#39;POST&#39;])\ndef collection_list(request):\n    if request.method == &#39;GET&#39;:\n        queryset = Collection.objects.all()\n        serializer = CollectionSerializer(queryset, many=True)\n        return Response(serializer.data)\n\n    if request.method == &#39;POST&#39;:\n        serializer = CollectionSerializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data, status=status.HTTP_201_CREATED)\n</code></pre>\n<p>通过URL:<code>/store/collections/</code>发送POST请求进行接口测试:</p>\n<pre><code class=\"python\"># HTTP 201 Created\n# Allow: POST, OPTIONS, GET\n# Content-Type: application/json\n# Vary: Accept\n\n&#123;\n    &quot;id&quot;: 11,\n    &quot;title&quot;: &quot;new collection&quot;\n&#125;\n</code></pre>\n<p>通过模型类定义的数据库验证, 以及序列化对象定义的前段数据验证, <code>is_valid()</code>方法便可以保证数据的有效性, 并通过<code>sava()</code>方法直接进行保存.</p>\n<p>但有时仍然需要进行一些其他的操作, 比如处理前段不可见的隐藏字段, 生成日志文件等等.</p>\n<p><code>ModelSeriallizer</code>提供了两个方法, 用于处理数据的新增和更新, 分别是<code>create</code>和<code>update</code>.</p>\n<p>仅需要重写这两个方法, RESTFramework会根据请求类型自动进行调用. 代码如下:</p>\n<pre><code class=\"python\">class CollectionSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Collection\n        fields = [&#39;id&#39;, &#39;title&#39;]\n\n    def create(self, validated_data):\n        collection = Collection(**validated_data)\n        print(collection.title)\n        collection.save()\n        return collection\n\n    def update(self, instance, validated_data):\n        print(&quot;OLD TITLE:&quot;, instance.title, &quot;-&quot;,\n              &quot;NEW TITLE:&quot;, validated_data.get(&#39;title&#39;))\n        instance.title = validated_data.get(&#39;title&#39;)\n        instance.save()\n        return instance\n</code></pre>\n<h2 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h2><p>数据的更新通过<code>PUT</code>和<code>PATCH</code>两种请求方式完成</p>\n<ul>\n<li><code>PUT</code>: PUT请求在传输时,要求一次性将请求所用的数据传输完成,即必须将所有的请求数据都完整地发送到服务器端.</li>\n<li><code>PATCH</code>: PATCH请求可以对资源进行部分修改,即客户端只需将要修改的部分发送给服务器,而无需将整个数据实体发送给服务器.因此,PATCH方法可以在节省带宽的同时提高效率,并可以支持增量更新.</li>\n</ul>\n<p>两种方式的区别在于:</p>\n<ol>\n<li>数据传输方式不同: PUT请求要求一次性将请求所需的所有数据传输完毕,而PATCH请求只传输要修改的部分数据,节约了带宽和传输时间.</li>\n<li>适用场景不同: PUT请求通常用于更新和替换整个资源,而PATCH请求则适用于对资源进行部分修改,可以在不修改整个资源的情况下实现增量更新.</li>\n<li>安全性不同: 由于PUT请求要求一次性发送所有数据,因此可能会存在重复更新或错误更新等问题.而PATCH请求只更新要修改的部分数据,因此更加安全,不易出错.</li>\n</ol>\n<p>修改<code>product_detail</code>视图方法:</p>\n<pre><code class=\"python\">@api_view([&#39;GET&#39;, &#39;PUT&#39;, &#39;PATCH&#39;])\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n\n    if request.method == &#39;GET&#39;:\n        serializer = ProductSerializer(product)\n        return Response(serializer.data)\n\n    if request.method == &#39;PUT&#39;:\n        serializer = ProductSerializer(product, data=request.data)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    if request.method == &#39;PATCH&#39;:\n        serializer = ProductSerializer(\n            product, data=request.data, partial=True)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n</code></pre>\n<p><code>GET</code>方式的实现代码与之前没有太大区别, <code>PUT</code>与<code>PATCH</code>的实现代码也没有太大区别.</p>\n<p>但是<code>PATCH</code>方法在进行序列化对象初始化的时候有一个额外关键字参数: <code>partial=True</code></p>\n<blockquote>\n<p>这一参数表示允许进行部分字段的更新! 如果没有声明这一参数, 那么<code>PUT</code>和<code>PATCH</code>的处理方式将完全相同.<br>{: .prompt-info}</p>\n</blockquote>\n<p>通过<code>PUT</code>和<code>PATCH</code>两种请求向<code>store/product/1001</code>发送测试数据:</p>\n<pre><code class=\"json\">&#123; &quot;price&quot;: 100&#125;\n</code></pre>\n<p><code>PUT</code>请求结果:</p>\n<pre><code class=\"python\"># HTTP 400 Bad Request\n# Allow: PATCH, GET, PUT, OPTIONS\n# Content-Type: application/json\n# Vary: Accept\n\n&#123;\n    &quot;title&quot;: [\n        &quot;该字段是必填项。&quot;\n    ],\n    &quot;inventory&quot;: [\n        &quot;该字段是必填项。&quot;\n    ],\n    &quot;collection&quot;: [\n        &quot;该字段是必填项。&quot;\n    ]\n&#125;\n</code></pre>\n<p><code>PATCH</code>请求结果:</p>\n<pre><code class=\"python\"># HTTP 200 OK\n# Allow: PATCH, GET, PUT, OPTIONS\n# Content-Type: application/json\n# Vary: Accept\n\n&#123;\n    &quot;id&quot;: 1001,\n    &quot;title&quot;: &quot;Dried Peach&quot;,\n    &quot;inventory&quot;: 39,\n    &quot;price&quot;: 100.0,\n    &quot;price_with_tax&quot;: 117.0,\n    &quot;collection&quot;: 4\n&#125;\n</code></pre>\n<p>假设一个用户更新昵称的需求, 显然其他的用户资料并没有变动, 仅仅只是修改了昵称</p>\n<p>虽然可以通过默认加载原始数据到表单中, 在发送更新数据时同时发送未修改的原始数据.</p>\n<p>但这无疑是对带宽和用户流量的浪费, 也造成了不必要的数据库读写.</p>\n<p>在<code>PUT</code>和<code>PATCH</code>的代码逻辑几乎一样的情况下, 可以把上面的代码进行一下优化:</p>\n<pre><code class=\"python\">@api_view([&#39;GET&#39;, &#39;PUT&#39;, &#39;PATCH&#39;, &#39;DELETE&#39;])\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n    \n    # other code...\n\n    if request.method in [&#39;PUT&#39;, &#39;PATCH&#39;]:\n        serializer = ProductSerializer(product,\n                                       data=request.data,\n                                       partial=request.method == &#39;PATCH&#39;)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    # other code ...\n</code></pre>\n<h2 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h2><p>删除数据作为一项危险操作, 应当进行充分的操作确认, 既要对用户进行删除操作确认, 对于重要内容的删除也可以进行密码确认.<br>而在服务端进行删除之前同样要进行各种操作, 如是否可以删除的判断, 用户操作权限的查询等.</p>\n<p>但是排除所有的确认, 删除操作本身非常简单.</p>\n<pre><code class=\"python\">@api_view([&#39;GET&#39;, &#39;PUT&#39;, &#39;PATCH&#39;, &#39;DELETE&#39;])\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n\n    # other code ...\n\n    if request.method == &#39;DELETE&#39;:\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>向<code>store/product/1</code>发送<code>DELETE</code>请求, 得到如下提示:</p>\n<pre><code class=\"text\">ProtectedError at /store/products/1/\n(&quot;Cannot delete some instances of model &#39;Product&#39; \nbecause they are referenced through protected foreign keys: \n    &#39;OrderItem.product&#39;.&quot;, &#123;&lt;OrderItem: OrderItem object (40)&gt;, &lt;OrderItem: OrderItem object (765)&gt;&#125;)\n</code></pre>\n<p>其原因在于<code>OrderItem</code>类中定义了<code>Product</code>外键, 并组织了其删除操作:</p>\n<pre><code class=\"python\">class OrderItem(models.Model):\n    order = models.ForeignKey(Order, on_delete=models.PROTECT)\n    # here\n    product = models.ForeignKey(Product, on_delete=models.PROTECT)\n    quantity = models.PositiveSmallIntegerField()\n    unit_price = models.DecimalField(max_digits=6, decimal_places=2)\n</code></pre>\n<p>如果不进行任何处理便直接进行删除操作, 便有可能使得程序出现异常:</p>\n<p><img src=\"/assets/img/img_202311121735237199.png\" alt=\"exception\"></p>\n<p>可以在删除前进行判断, 代码如下:</p>\n<pre><code class=\"python\">@api_view([&#39;GET&#39;, &#39;PUT&#39;, &#39;PATCH&#39;, &#39;DELETE&#39;])\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n\n    # other code ...\n\n    if request.method == &#39;DELETE&#39;:\n        if product.orderitem_set.count() &gt; 0:\n            return Response(&#123;&#39;error&#39;: &#39;Product has been ordered.&#39;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>再次发送删除请求, 获得回复:</p>\n<pre><code class=\"python\"># HTTP 405 Method Not Allowed\n# Allow: GET, DELETE, OPTIONS, PUT, PATCH\n# Content-Type: application/json\n# Vary: Accept\n\n&#123;\n    &quot;error&quot;: &quot;Product has been ordered.&quot;\n&#125;\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"保存数据\"><a href=\"#保存数据\" class=\"headerlink\" title=\"保存数据\"></a>保存数据</h2><p>对于简单数据的表单, rest framework 提供了很简单的数据保存方式.</p>\n<p>比如, 按照之前的内容, 新增一个<code>collection_list</code>视图方法, 用于对<code>Collection</code>进行获取和新增</p>\n<pre><code class=\"python\">@api_view([&#39;GET&#39;, &#39;POST&#39;])\ndef collection_list(request):\n    if request.method == &#39;GET&#39;:\n        queryset = Collection.objects.all()\n        serializer = CollectionSerializer(queryset, many=True)\n        return Response(serializer.data)\n\n    if request.method == &#39;POST&#39;:\n        serializer = CollectionSerializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data, status=status.HTTP_201_CREATED)\n</code></pre>\n<p>通过URL:<code>/store/collections/</code>发送POST请求进行接口测试:</p>\n<pre><code class=\"python\"># HTTP 201 Created\n# Allow: POST, OPTIONS, GET\n# Content-Type: application/json\n# Vary: Accept\n\n&#123;\n    &quot;id&quot;: 11,\n    &quot;title&quot;: &quot;new collection&quot;\n&#125;\n</code></pre>\n<p>通过模型类定义的数据库验证, 以及序列化对象定义的前段数据验证, <code>is_valid()</code>方法便可以保证数据的有效性, 并通过<code>sava()</code>方法直接进行保存.</p>\n<p>但有时仍然需要进行一些其他的操作, 比如处理前段不可见的隐藏字段, 生成日志文件等等.</p>\n<p><code>ModelSeriallizer</code>提供了两个方法, 用于处理数据的新增和更新, 分别是<code>create</code>和<code>update</code>.</p>\n<p>仅需要重写这两个方法, RESTFramework会根据请求类型自动进行调用. 代码如下:</p>\n<pre><code class=\"python\">class CollectionSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Collection\n        fields = [&#39;id&#39;, &#39;title&#39;]\n\n    def create(self, validated_data):\n        collection = Collection(**validated_data)\n        print(collection.title)\n        collection.save()\n        return collection\n\n    def update(self, instance, validated_data):\n        print(&quot;OLD TITLE:&quot;, instance.title, &quot;-&quot;,\n              &quot;NEW TITLE:&quot;, validated_data.get(&#39;title&#39;))\n        instance.title = validated_data.get(&#39;title&#39;)\n        instance.save()\n        return instance\n</code></pre>\n<h2 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h2><p>数据的更新通过<code>PUT</code>和<code>PATCH</code>两种请求方式完成</p>\n<ul>\n<li><code>PUT</code>: PUT请求在传输时,要求一次性将请求所用的数据传输完成,即必须将所有的请求数据都完整地发送到服务器端.</li>\n<li><code>PATCH</code>: PATCH请求可以对资源进行部分修改,即客户端只需将要修改的部分发送给服务器,而无需将整个数据实体发送给服务器.因此,PATCH方法可以在节省带宽的同时提高效率,并可以支持增量更新.</li>\n</ul>\n<p>两种方式的区别在于:</p>\n<ol>\n<li>数据传输方式不同: PUT请求要求一次性将请求所需的所有数据传输完毕,而PATCH请求只传输要修改的部分数据,节约了带宽和传输时间.</li>\n<li>适用场景不同: PUT请求通常用于更新和替换整个资源,而PATCH请求则适用于对资源进行部分修改,可以在不修改整个资源的情况下实现增量更新.</li>\n<li>安全性不同: 由于PUT请求要求一次性发送所有数据,因此可能会存在重复更新或错误更新等问题.而PATCH请求只更新要修改的部分数据,因此更加安全,不易出错.</li>\n</ol>\n<p>修改<code>product_detail</code>视图方法:</p>\n<pre><code class=\"python\">@api_view([&#39;GET&#39;, &#39;PUT&#39;, &#39;PATCH&#39;])\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n\n    if request.method == &#39;GET&#39;:\n        serializer = ProductSerializer(product)\n        return Response(serializer.data)\n\n    if request.method == &#39;PUT&#39;:\n        serializer = ProductSerializer(product, data=request.data)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    if request.method == &#39;PATCH&#39;:\n        serializer = ProductSerializer(\n            product, data=request.data, partial=True)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n</code></pre>\n<p><code>GET</code>方式的实现代码与之前没有太大区别, <code>PUT</code>与<code>PATCH</code>的实现代码也没有太大区别.</p>\n<p>但是<code>PATCH</code>方法在进行序列化对象初始化的时候有一个额外关键字参数: <code>partial=True</code></p>\n<blockquote>\n<p>这一参数表示允许进行部分字段的更新! 如果没有声明这一参数, 那么<code>PUT</code>和<code>PATCH</code>的处理方式将完全相同.<br>{: .prompt-info}</p>\n</blockquote>\n<p>通过<code>PUT</code>和<code>PATCH</code>两种请求向<code>store/product/1001</code>发送测试数据:</p>\n<pre><code class=\"json\">&#123; &quot;price&quot;: 100&#125;\n</code></pre>\n<p><code>PUT</code>请求结果:</p>\n<pre><code class=\"python\"># HTTP 400 Bad Request\n# Allow: PATCH, GET, PUT, OPTIONS\n# Content-Type: application/json\n# Vary: Accept\n\n&#123;\n    &quot;title&quot;: [\n        &quot;该字段是必填项。&quot;\n    ],\n    &quot;inventory&quot;: [\n        &quot;该字段是必填项。&quot;\n    ],\n    &quot;collection&quot;: [\n        &quot;该字段是必填项。&quot;\n    ]\n&#125;\n</code></pre>\n<p><code>PATCH</code>请求结果:</p>\n<pre><code class=\"python\"># HTTP 200 OK\n# Allow: PATCH, GET, PUT, OPTIONS\n# Content-Type: application/json\n# Vary: Accept\n\n&#123;\n    &quot;id&quot;: 1001,\n    &quot;title&quot;: &quot;Dried Peach&quot;,\n    &quot;inventory&quot;: 39,\n    &quot;price&quot;: 100.0,\n    &quot;price_with_tax&quot;: 117.0,\n    &quot;collection&quot;: 4\n&#125;\n</code></pre>\n<p>假设一个用户更新昵称的需求, 显然其他的用户资料并没有变动, 仅仅只是修改了昵称</p>\n<p>虽然可以通过默认加载原始数据到表单中, 在发送更新数据时同时发送未修改的原始数据.</p>\n<p>但这无疑是对带宽和用户流量的浪费, 也造成了不必要的数据库读写.</p>\n<p>在<code>PUT</code>和<code>PATCH</code>的代码逻辑几乎一样的情况下, 可以把上面的代码进行一下优化:</p>\n<pre><code class=\"python\">@api_view([&#39;GET&#39;, &#39;PUT&#39;, &#39;PATCH&#39;, &#39;DELETE&#39;])\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n    \n    # other code...\n\n    if request.method in [&#39;PUT&#39;, &#39;PATCH&#39;]:\n        serializer = ProductSerializer(product,\n                                       data=request.data,\n                                       partial=request.method == &#39;PATCH&#39;)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n\n    # other code ...\n</code></pre>\n<h2 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h2><p>删除数据作为一项危险操作, 应当进行充分的操作确认, 既要对用户进行删除操作确认, 对于重要内容的删除也可以进行密码确认.<br>而在服务端进行删除之前同样要进行各种操作, 如是否可以删除的判断, 用户操作权限的查询等.</p>\n<p>但是排除所有的确认, 删除操作本身非常简单.</p>\n<pre><code class=\"python\">@api_view([&#39;GET&#39;, &#39;PUT&#39;, &#39;PATCH&#39;, &#39;DELETE&#39;])\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n\n    # other code ...\n\n    if request.method == &#39;DELETE&#39;:\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>向<code>store/product/1</code>发送<code>DELETE</code>请求, 得到如下提示:</p>\n<pre><code class=\"text\">ProtectedError at /store/products/1/\n(&quot;Cannot delete some instances of model &#39;Product&#39; \nbecause they are referenced through protected foreign keys: \n    &#39;OrderItem.product&#39;.&quot;, &#123;&lt;OrderItem: OrderItem object (40)&gt;, &lt;OrderItem: OrderItem object (765)&gt;&#125;)\n</code></pre>\n<p>其原因在于<code>OrderItem</code>类中定义了<code>Product</code>外键, 并组织了其删除操作:</p>\n<pre><code class=\"python\">class OrderItem(models.Model):\n    order = models.ForeignKey(Order, on_delete=models.PROTECT)\n    # here\n    product = models.ForeignKey(Product, on_delete=models.PROTECT)\n    quantity = models.PositiveSmallIntegerField()\n    unit_price = models.DecimalField(max_digits=6, decimal_places=2)\n</code></pre>\n<p>如果不进行任何处理便直接进行删除操作, 便有可能使得程序出现异常:</p>\n<p><img src=\"/assets/img/img_202311121735237199.png\" alt=\"exception\"></p>\n<p>可以在删除前进行判断, 代码如下:</p>\n<pre><code class=\"python\">@api_view([&#39;GET&#39;, &#39;PUT&#39;, &#39;PATCH&#39;, &#39;DELETE&#39;])\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n\n    # other code ...\n\n    if request.method == &#39;DELETE&#39;:\n        if product.orderitem_set.count() &gt; 0:\n            return Response(&#123;&#39;error&#39;: &#39;Product has been ordered.&#39;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>再次发送删除请求, 获得回复:</p>\n<pre><code class=\"python\"># HTTP 405 Method Not Allowed\n# Allow: GET, DELETE, OPTIONS, PUT, PATCH\n# Content-Type: application/json\n# Vary: Accept\n\n&#123;\n    &quot;error&quot;: &quot;Product has been ordered.&quot;\n&#125;\n</code></pre>\n"},{"title":"19. 使用drf-nested-routers实现路由嵌套","date":"2023-11-13T08:30:20.000Z","_content":"\n在django中, 基础的路由配置格式为:\n\n```python\nurlpatterns = [\n    path('', views.index),\n    path('products/', generic_api.ProductList.as_view()),\n    path('products/<int:pk>/', generic_api.ProductDetail.as_view())\n]\n```\n\n但这需要为每一个公开的接口配置具体的路由, 且接口变动需要手动进行维护.\n\n通过rest的Router可以简化路由的配置.\n\n```python\nrouter = DefaultRouter()\nrouter.register('products', viewset_api.ProductViewSet)\nrouter.register('collectons', viewset_api.CollectionViewSet)\n\nurlpatterns = [\n    path('', include(router.urls)),\n    # other path you need.\n]\n```\n\n这样便可以动态的生成路由信息, 仅需要关注编码即可. 但缺乏多级路由的支持. 比如\n\n* `products/1/reviews`: id为1的产品的评论列表\n* `products/1/reviews/2` id为1的产品下id为2的评论详情\n\n根据REST的规则, 很容易便可以明白这些路由的含义, 但是在路由配置时, 通过REST Framework提供的路由便比较难以处理.\n\n为了更为方便的进行多级路由的配置, 可以使用`drf-nested-routers`\n\n## 安装 drf-nested-routers\n\n[Gitee镜像主页](https://gitee.com/mirrors_alanjds/drf-nested-routers)\n[Github主页](https://github.com/alanjds/drf-nested-routers)\n\n通过pipenv或者pip进行安装即可:\n\n```bash\npipenv install drf-nested-routers\n```\n\n## 配置嵌套路由\n\n在`store/urls.py`中对`Product`和`Review`配置路由:\n\n```python\nfrom django.urls import path, include\nfrom rest_framework_nested import routers\n\nfrom .views import viewset_api\n\nrouter = routers.DefaultRouter()\nrouter.register('products', viewset_api.ProductViewSet, basename='products')\nrouter.register('collectons', viewset_api.CollectionViewSet)\n\n# 参数\n# router - 所属的父路由对象\n# 'products' - 对应父路由对象中的哪一个路由, 便是之前通过 router.register()注册的内容\n# lookup - 查询前缀, 会自动生成一个`product-pk`键\nproducts_router = routers.NestedDefaultRouter(router, 'products', lookup='product')\nproducts_router.register(\n    'reviews', viewset_api.ReviewViewSet, basename='product-reviews')\n\nurlpatterns = [\n    path(r'', include(router.urls)),\n    path(r'', include(products_router.urls))\n]\n```\n\n> drf的路由嵌套并没有层级限制, 可以在次技术上进行更深层的嵌套.\n>\n> 比如为`review`再添加一个`reply`等等.\n>\n{: .prompt-tip}\n\n## 创建 Review 模型\n\n一个用于记录`Product`评论的简单表, 代码如下:\n\n```python\nclass Review(models.Model):\n    product = models.ForeignKey(\n        Product, on_delete=models.CASCADE, related_name=\"reviews\")\n    name = models.CharField(max_length=255)\n    description = models.TextField()\n    date = models.DateField(auto_now=True)\n```\n\n为了能够配置ViewSet, 还需要为`Review`创建一个序列化对象:\n\n```python\nclass ReviewSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Review\n        fields = ['id', 'name', 'date', 'description']\n\n    def create(self, validated_data):\n        product_id = self.context['product_id']\n        return Review.objects.create(product_id=product_id, **validated_data)\n```\n\n> 关于`create`方法.\n>\n> 在创建`Review`的具体数据时, 我们需要知道该数据时对应的哪一个product.\n>\n> 虽然可以通过手动输入`product_id`, 但实际上url之中便已经包含了具体的该值, 只需要从其中获取即可.\n> `self.context['product_id']`的作用便是从请求的上下文中获取具体的值.\n>\n{: .prompt-info}\n\n## 编写对应的Viewset\n\n```python\nclass ReviewViewSet(ModelViewSet):\n\n    serializer_class = ReviewSerializer\n\n    def get_queryset(self):\n        return Review.objects.filter(\n            product_id=self.kwargs['product_pk'])\n\n    def get_serializer_context(self):\n        context = super().get_serializer_context()\n        context['product_id'] = self.kwargs['product_pk']\n        return context\n```\n\n> 直接获取所有的Review操作没有实际意义, 必须知道产品的id才能获取其相应的review, 也就不能简单的使用`objects.all()`\n>\n> 由于增加了额外的逻辑, 便需要重写`get_queryset`方法. 添加对`product_id`的过滤器\n> 而`get_serializer_context`方法则是将URL中的id储存在上下文中供序列化对象使用.\n>\n{: .prompt-info}\n\n> 几个ID的对应关系:\n>\n> * `product_pk`, 由路由配置自动生成, `routers.NestedDefaultRouter(router, 'products', lookup='product')`\n> 作用是让`ViewSet`能够获取URL的参数.\n> * `product_id`, 序列化对象和模型类中外键字段名.\n>\n{: .prompt-tip}\n","source":"_posts/django/rest-drf-nested-router.md","raw":"---\ntitle: 19. 使用drf-nested-routers实现路由嵌套\ndate: 2023-11-13 16:30:20 +0800\ncategories: [笔记, Django]\ntags: [python, django, backend, REST]\n---\n\n在django中, 基础的路由配置格式为:\n\n```python\nurlpatterns = [\n    path('', views.index),\n    path('products/', generic_api.ProductList.as_view()),\n    path('products/<int:pk>/', generic_api.ProductDetail.as_view())\n]\n```\n\n但这需要为每一个公开的接口配置具体的路由, 且接口变动需要手动进行维护.\n\n通过rest的Router可以简化路由的配置.\n\n```python\nrouter = DefaultRouter()\nrouter.register('products', viewset_api.ProductViewSet)\nrouter.register('collectons', viewset_api.CollectionViewSet)\n\nurlpatterns = [\n    path('', include(router.urls)),\n    # other path you need.\n]\n```\n\n这样便可以动态的生成路由信息, 仅需要关注编码即可. 但缺乏多级路由的支持. 比如\n\n* `products/1/reviews`: id为1的产品的评论列表\n* `products/1/reviews/2` id为1的产品下id为2的评论详情\n\n根据REST的规则, 很容易便可以明白这些路由的含义, 但是在路由配置时, 通过REST Framework提供的路由便比较难以处理.\n\n为了更为方便的进行多级路由的配置, 可以使用`drf-nested-routers`\n\n## 安装 drf-nested-routers\n\n[Gitee镜像主页](https://gitee.com/mirrors_alanjds/drf-nested-routers)\n[Github主页](https://github.com/alanjds/drf-nested-routers)\n\n通过pipenv或者pip进行安装即可:\n\n```bash\npipenv install drf-nested-routers\n```\n\n## 配置嵌套路由\n\n在`store/urls.py`中对`Product`和`Review`配置路由:\n\n```python\nfrom django.urls import path, include\nfrom rest_framework_nested import routers\n\nfrom .views import viewset_api\n\nrouter = routers.DefaultRouter()\nrouter.register('products', viewset_api.ProductViewSet, basename='products')\nrouter.register('collectons', viewset_api.CollectionViewSet)\n\n# 参数\n# router - 所属的父路由对象\n# 'products' - 对应父路由对象中的哪一个路由, 便是之前通过 router.register()注册的内容\n# lookup - 查询前缀, 会自动生成一个`product-pk`键\nproducts_router = routers.NestedDefaultRouter(router, 'products', lookup='product')\nproducts_router.register(\n    'reviews', viewset_api.ReviewViewSet, basename='product-reviews')\n\nurlpatterns = [\n    path(r'', include(router.urls)),\n    path(r'', include(products_router.urls))\n]\n```\n\n> drf的路由嵌套并没有层级限制, 可以在次技术上进行更深层的嵌套.\n>\n> 比如为`review`再添加一个`reply`等等.\n>\n{: .prompt-tip}\n\n## 创建 Review 模型\n\n一个用于记录`Product`评论的简单表, 代码如下:\n\n```python\nclass Review(models.Model):\n    product = models.ForeignKey(\n        Product, on_delete=models.CASCADE, related_name=\"reviews\")\n    name = models.CharField(max_length=255)\n    description = models.TextField()\n    date = models.DateField(auto_now=True)\n```\n\n为了能够配置ViewSet, 还需要为`Review`创建一个序列化对象:\n\n```python\nclass ReviewSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Review\n        fields = ['id', 'name', 'date', 'description']\n\n    def create(self, validated_data):\n        product_id = self.context['product_id']\n        return Review.objects.create(product_id=product_id, **validated_data)\n```\n\n> 关于`create`方法.\n>\n> 在创建`Review`的具体数据时, 我们需要知道该数据时对应的哪一个product.\n>\n> 虽然可以通过手动输入`product_id`, 但实际上url之中便已经包含了具体的该值, 只需要从其中获取即可.\n> `self.context['product_id']`的作用便是从请求的上下文中获取具体的值.\n>\n{: .prompt-info}\n\n## 编写对应的Viewset\n\n```python\nclass ReviewViewSet(ModelViewSet):\n\n    serializer_class = ReviewSerializer\n\n    def get_queryset(self):\n        return Review.objects.filter(\n            product_id=self.kwargs['product_pk'])\n\n    def get_serializer_context(self):\n        context = super().get_serializer_context()\n        context['product_id'] = self.kwargs['product_pk']\n        return context\n```\n\n> 直接获取所有的Review操作没有实际意义, 必须知道产品的id才能获取其相应的review, 也就不能简单的使用`objects.all()`\n>\n> 由于增加了额外的逻辑, 便需要重写`get_queryset`方法. 添加对`product_id`的过滤器\n> 而`get_serializer_context`方法则是将URL中的id储存在上下文中供序列化对象使用.\n>\n{: .prompt-info}\n\n> 几个ID的对应关系:\n>\n> * `product_pk`, 由路由配置自动生成, `routers.NestedDefaultRouter(router, 'products', lookup='product')`\n> 作用是让`ViewSet`能够获取URL的参数.\n> * `product_id`, 序列化对象和模型类中外键字段名.\n>\n{: .prompt-tip}\n","slug":"django-rest-drf-nested-router","published":1,"updated":"2023-12-13T08:41:08.348Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v30025i3er6xzu46kl","content":"<p>在django中, 基础的路由配置格式为:</p>\n<pre><code class=\"python\">urlpatterns = [\n    path(&#39;&#39;, views.index),\n    path(&#39;products/&#39;, generic_api.ProductList.as_view()),\n    path(&#39;products/&lt;int:pk&gt;/&#39;, generic_api.ProductDetail.as_view())\n]\n</code></pre>\n<p>但这需要为每一个公开的接口配置具体的路由, 且接口变动需要手动进行维护.</p>\n<p>通过rest的Router可以简化路由的配置.</p>\n<pre><code class=\"python\">router = DefaultRouter()\nrouter.register(&#39;products&#39;, viewset_api.ProductViewSet)\nrouter.register(&#39;collectons&#39;, viewset_api.CollectionViewSet)\n\nurlpatterns = [\n    path(&#39;&#39;, include(router.urls)),\n    # other path you need.\n]\n</code></pre>\n<p>这样便可以动态的生成路由信息, 仅需要关注编码即可. 但缺乏多级路由的支持. 比如</p>\n<ul>\n<li><code>products/1/reviews</code>: id为1的产品的评论列表</li>\n<li><code>products/1/reviews/2</code> id为1的产品下id为2的评论详情</li>\n</ul>\n<p>根据REST的规则, 很容易便可以明白这些路由的含义, 但是在路由配置时, 通过REST Framework提供的路由便比较难以处理.</p>\n<p>为了更为方便的进行多级路由的配置, 可以使用<code>drf-nested-routers</code></p>\n<h2 id=\"安装-drf-nested-routers\"><a href=\"#安装-drf-nested-routers\" class=\"headerlink\" title=\"安装 drf-nested-routers\"></a>安装 drf-nested-routers</h2><p><a href=\"https://gitee.com/mirrors_alanjds/drf-nested-routers\">Gitee镜像主页</a><br><a href=\"https://github.com/alanjds/drf-nested-routers\">Github主页</a></p>\n<p>通过pipenv或者pip进行安装即可:</p>\n<pre><code class=\"bash\">pipenv install drf-nested-routers\n</code></pre>\n<h2 id=\"配置嵌套路由\"><a href=\"#配置嵌套路由\" class=\"headerlink\" title=\"配置嵌套路由\"></a>配置嵌套路由</h2><p>在<code>store/urls.py</code>中对<code>Product</code>和<code>Review</code>配置路由:</p>\n<pre><code class=\"python\">from django.urls import path, include\nfrom rest_framework_nested import routers\n\nfrom .views import viewset_api\n\nrouter = routers.DefaultRouter()\nrouter.register(&#39;products&#39;, viewset_api.ProductViewSet, basename=&#39;products&#39;)\nrouter.register(&#39;collectons&#39;, viewset_api.CollectionViewSet)\n\n# 参数\n# router - 所属的父路由对象\n# &#39;products&#39; - 对应父路由对象中的哪一个路由, 便是之前通过 router.register()注册的内容\n# lookup - 查询前缀, 会自动生成一个`product-pk`键\nproducts_router = routers.NestedDefaultRouter(router, &#39;products&#39;, lookup=&#39;product&#39;)\nproducts_router.register(\n    &#39;reviews&#39;, viewset_api.ReviewViewSet, basename=&#39;product-reviews&#39;)\n\nurlpatterns = [\n    path(r&#39;&#39;, include(router.urls)),\n    path(r&#39;&#39;, include(products_router.urls))\n]\n</code></pre>\n<blockquote>\n<p>drf的路由嵌套并没有层级限制, 可以在次技术上进行更深层的嵌套.</p>\n<p>比如为<code>review</code>再添加一个<code>reply</code>等等.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h2 id=\"创建-Review-模型\"><a href=\"#创建-Review-模型\" class=\"headerlink\" title=\"创建 Review 模型\"></a>创建 Review 模型</h2><p>一个用于记录<code>Product</code>评论的简单表, 代码如下:</p>\n<pre><code class=\"python\">class Review(models.Model):\n    product = models.ForeignKey(\n        Product, on_delete=models.CASCADE, related_name=&quot;reviews&quot;)\n    name = models.CharField(max_length=255)\n    description = models.TextField()\n    date = models.DateField(auto_now=True)\n</code></pre>\n<p>为了能够配置ViewSet, 还需要为<code>Review</code>创建一个序列化对象:</p>\n<pre><code class=\"python\">class ReviewSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Review\n        fields = [&#39;id&#39;, &#39;name&#39;, &#39;date&#39;, &#39;description&#39;]\n\n    def create(self, validated_data):\n        product_id = self.context[&#39;product_id&#39;]\n        return Review.objects.create(product_id=product_id, **validated_data)\n</code></pre>\n<blockquote>\n<p>关于<code>create</code>方法.</p>\n<p>在创建<code>Review</code>的具体数据时, 我们需要知道该数据时对应的哪一个product.</p>\n<p>虽然可以通过手动输入<code>product_id</code>, 但实际上url之中便已经包含了具体的该值, 只需要从其中获取即可.<br><code>self.context[&#39;product_id&#39;]</code>的作用便是从请求的上下文中获取具体的值.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<h2 id=\"编写对应的Viewset\"><a href=\"#编写对应的Viewset\" class=\"headerlink\" title=\"编写对应的Viewset\"></a>编写对应的Viewset</h2><pre><code class=\"python\">class ReviewViewSet(ModelViewSet):\n\n    serializer_class = ReviewSerializer\n\n    def get_queryset(self):\n        return Review.objects.filter(\n            product_id=self.kwargs[&#39;product_pk&#39;])\n\n    def get_serializer_context(self):\n        context = super().get_serializer_context()\n        context[&#39;product_id&#39;] = self.kwargs[&#39;product_pk&#39;]\n        return context\n</code></pre>\n<blockquote>\n<p>直接获取所有的Review操作没有实际意义, 必须知道产品的id才能获取其相应的review, 也就不能简单的使用<code>objects.all()</code></p>\n<p>由于增加了额外的逻辑, 便需要重写<code>get_queryset</code>方法. 添加对<code>product_id</code>的过滤器<br>而<code>get_serializer_context</code>方法则是将URL中的id储存在上下文中供序列化对象使用.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<blockquote>\n<p>几个ID的对应关系:</p>\n<ul>\n<li><code>product_pk</code>, 由路由配置自动生成, <code>routers.NestedDefaultRouter(router, &#39;products&#39;, lookup=&#39;product&#39;)</code><br>作用是让<code>ViewSet</code>能够获取URL的参数.</li>\n<li><code>product_id</code>, 序列化对象和模型类中外键字段名.</li>\n</ul>\n</blockquote>\n<p>{: .prompt-tip}</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>在django中, 基础的路由配置格式为:</p>\n<pre><code class=\"python\">urlpatterns = [\n    path(&#39;&#39;, views.index),\n    path(&#39;products/&#39;, generic_api.ProductList.as_view()),\n    path(&#39;products/&lt;int:pk&gt;/&#39;, generic_api.ProductDetail.as_view())\n]\n</code></pre>\n<p>但这需要为每一个公开的接口配置具体的路由, 且接口变动需要手动进行维护.</p>\n<p>通过rest的Router可以简化路由的配置.</p>\n<pre><code class=\"python\">router = DefaultRouter()\nrouter.register(&#39;products&#39;, viewset_api.ProductViewSet)\nrouter.register(&#39;collectons&#39;, viewset_api.CollectionViewSet)\n\nurlpatterns = [\n    path(&#39;&#39;, include(router.urls)),\n    # other path you need.\n]\n</code></pre>\n<p>这样便可以动态的生成路由信息, 仅需要关注编码即可. 但缺乏多级路由的支持. 比如</p>\n<ul>\n<li><code>products/1/reviews</code>: id为1的产品的评论列表</li>\n<li><code>products/1/reviews/2</code> id为1的产品下id为2的评论详情</li>\n</ul>\n<p>根据REST的规则, 很容易便可以明白这些路由的含义, 但是在路由配置时, 通过REST Framework提供的路由便比较难以处理.</p>\n<p>为了更为方便的进行多级路由的配置, 可以使用<code>drf-nested-routers</code></p>\n<h2 id=\"安装-drf-nested-routers\"><a href=\"#安装-drf-nested-routers\" class=\"headerlink\" title=\"安装 drf-nested-routers\"></a>安装 drf-nested-routers</h2><p><a href=\"https://gitee.com/mirrors_alanjds/drf-nested-routers\">Gitee镜像主页</a><br><a href=\"https://github.com/alanjds/drf-nested-routers\">Github主页</a></p>\n<p>通过pipenv或者pip进行安装即可:</p>\n<pre><code class=\"bash\">pipenv install drf-nested-routers\n</code></pre>\n<h2 id=\"配置嵌套路由\"><a href=\"#配置嵌套路由\" class=\"headerlink\" title=\"配置嵌套路由\"></a>配置嵌套路由</h2><p>在<code>store/urls.py</code>中对<code>Product</code>和<code>Review</code>配置路由:</p>\n<pre><code class=\"python\">from django.urls import path, include\nfrom rest_framework_nested import routers\n\nfrom .views import viewset_api\n\nrouter = routers.DefaultRouter()\nrouter.register(&#39;products&#39;, viewset_api.ProductViewSet, basename=&#39;products&#39;)\nrouter.register(&#39;collectons&#39;, viewset_api.CollectionViewSet)\n\n# 参数\n# router - 所属的父路由对象\n# &#39;products&#39; - 对应父路由对象中的哪一个路由, 便是之前通过 router.register()注册的内容\n# lookup - 查询前缀, 会自动生成一个`product-pk`键\nproducts_router = routers.NestedDefaultRouter(router, &#39;products&#39;, lookup=&#39;product&#39;)\nproducts_router.register(\n    &#39;reviews&#39;, viewset_api.ReviewViewSet, basename=&#39;product-reviews&#39;)\n\nurlpatterns = [\n    path(r&#39;&#39;, include(router.urls)),\n    path(r&#39;&#39;, include(products_router.urls))\n]\n</code></pre>\n<blockquote>\n<p>drf的路由嵌套并没有层级限制, 可以在次技术上进行更深层的嵌套.</p>\n<p>比如为<code>review</code>再添加一个<code>reply</code>等等.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h2 id=\"创建-Review-模型\"><a href=\"#创建-Review-模型\" class=\"headerlink\" title=\"创建 Review 模型\"></a>创建 Review 模型</h2><p>一个用于记录<code>Product</code>评论的简单表, 代码如下:</p>\n<pre><code class=\"python\">class Review(models.Model):\n    product = models.ForeignKey(\n        Product, on_delete=models.CASCADE, related_name=&quot;reviews&quot;)\n    name = models.CharField(max_length=255)\n    description = models.TextField()\n    date = models.DateField(auto_now=True)\n</code></pre>\n<p>为了能够配置ViewSet, 还需要为<code>Review</code>创建一个序列化对象:</p>\n<pre><code class=\"python\">class ReviewSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Review\n        fields = [&#39;id&#39;, &#39;name&#39;, &#39;date&#39;, &#39;description&#39;]\n\n    def create(self, validated_data):\n        product_id = self.context[&#39;product_id&#39;]\n        return Review.objects.create(product_id=product_id, **validated_data)\n</code></pre>\n<blockquote>\n<p>关于<code>create</code>方法.</p>\n<p>在创建<code>Review</code>的具体数据时, 我们需要知道该数据时对应的哪一个product.</p>\n<p>虽然可以通过手动输入<code>product_id</code>, 但实际上url之中便已经包含了具体的该值, 只需要从其中获取即可.<br><code>self.context[&#39;product_id&#39;]</code>的作用便是从请求的上下文中获取具体的值.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<h2 id=\"编写对应的Viewset\"><a href=\"#编写对应的Viewset\" class=\"headerlink\" title=\"编写对应的Viewset\"></a>编写对应的Viewset</h2><pre><code class=\"python\">class ReviewViewSet(ModelViewSet):\n\n    serializer_class = ReviewSerializer\n\n    def get_queryset(self):\n        return Review.objects.filter(\n            product_id=self.kwargs[&#39;product_pk&#39;])\n\n    def get_serializer_context(self):\n        context = super().get_serializer_context()\n        context[&#39;product_id&#39;] = self.kwargs[&#39;product_pk&#39;]\n        return context\n</code></pre>\n<blockquote>\n<p>直接获取所有的Review操作没有实际意义, 必须知道产品的id才能获取其相应的review, 也就不能简单的使用<code>objects.all()</code></p>\n<p>由于增加了额外的逻辑, 便需要重写<code>get_queryset</code>方法. 添加对<code>product_id</code>的过滤器<br>而<code>get_serializer_context</code>方法则是将URL中的id储存在上下文中供序列化对象使用.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<blockquote>\n<p>几个ID的对应关系:</p>\n<ul>\n<li><code>product_pk</code>, 由路由配置自动生成, <code>routers.NestedDefaultRouter(router, &#39;products&#39;, lookup=&#39;product&#39;)</code><br>作用是让<code>ViewSet</code>能够获取URL的参数.</li>\n<li><code>product_id</code>, 序列化对象和模型类中外键字段名.</li>\n</ul>\n</blockquote>\n<p>{: .prompt-tip}</p>\n"},{"title":"13. 模型反序列化","date":"2023-12-13T08:41:08.348Z","_content":"\n\n在客户端发送`POST`请求至后台时, 需要将其发送的数据转化为python对象, 此时便需要进行反序列化\n\n## 反序列化的简单实现\n\n基于REST的规范, 获取资源和创建资源应该分别对应同一个URL的`GET`和`POST`方法.\n\n所以我们可以直接修改`products/`路由对应的视图:\n\n```python\n@api_view(['GET', 'POST'])\ndef product_list(request):\n\n    if request.method == 'GET':\n        queryset = Product.objects.all()\n        serializer = ProductSerializer(queryset, many=True,\n                                       context={'request': request})\n        return Response(serializer.data)\n\n    if request.method == 'POST':\n        serializer = ProductSerializer(data=request.data)\n        return Response(\"ok\")\n```\n\n当视图方法设置为`GET`, `POST` 时, Django REST framework会自动在接口页面创建一个表单, 以方便我们直接对接口进行测试.\n![post form](/assets/img/img_202311120215571964.png)\n\n## 数据校验\n\n在视图方法中通过序列化对象进行数据校验, 只需要调用`is_valid()`方法即可. 数据会自动根据数据模型的字段和验证器定义进行校验.\n\n```python\nif request.method == 'POST':\n        serializer = ProductSerializer(data=request.data)\n        if serializer.is_valid():\n            print(serializer.validated_data)\n            return Response(\"ok\")\n\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n```\n\n此时, 如果想接口发送一个空对象, 则会得到如下返回信息:\n\n```python\n# HTTP 400 Bad Request\n# Allow: OPTIONS, POST, GET\n# Content-Type: application/json\n# Vary: Accept\n\n{\n    \"title\": [\n        \"This field is required.\"\n    ],\n    \"price\": [\n        \"This field is required.\"\n    ],\n    \"collection\": [\n        \"This field is required.\"\n    ]\n}\n```\n\n> REST framework提供了一个更为简单的实现方式\n>\n> 通过给`is_valid()`方法添加关键字参数`raise_exception=True`便可以得到完全相同的结果\n>\n> ```python\n> if request.method == 'POST':\n>   serializer = ProductSerializer(data=request.data)\n>   serializer.is_valid(raise_exception=True)\n>   print(serializer.validated_data)\n>   return Response(\"ok\")\n> ```\n>\n{: .prompt-tip}\n\n### 前端数据验证\n\n对于`POST`数据不仅仅要进行数据类型, 非空, 查重等数据库验证, 有些时候也会需要进行一些数据有效性的验证.\n比如创建用户操作时, 密码和确认密码是否相同一类.\n\n此时可以直接在序列化对象中直接进行额外验证的编写, 在调用`is_valid()`方法时便会在一同进行自定义验证.\n\n在`ProductSerializer`中添加如下代码:\n\n```python\ndef validate(self, attrs):\n    if attrs['unit_price'] > 100:\n        raise serializers.ValidationError(\"太贵了没人买\")\n\n    return attrs\n```\n\n> 虽然在序列化对象时定义了字段命为`price`, 但这里的字段名称是`unit_price`.\n>\n> 因为验证是在数据反序列化之后才会进行的, 所以`attrs`对象中的键都是`Product`模型类所定义的字段名.\n>\n{: .prompt-warning}\n","source":"_posts/django/rest-deserializing.md","raw":"---\ntitle: 13. 模型反序列化\ndate: 2023-11-12 01:57:01 +08000\ncategories: [笔记, Django]\ntags: [python, django, backend]\n---\n\n\n在客户端发送`POST`请求至后台时, 需要将其发送的数据转化为python对象, 此时便需要进行反序列化\n\n## 反序列化的简单实现\n\n基于REST的规范, 获取资源和创建资源应该分别对应同一个URL的`GET`和`POST`方法.\n\n所以我们可以直接修改`products/`路由对应的视图:\n\n```python\n@api_view(['GET', 'POST'])\ndef product_list(request):\n\n    if request.method == 'GET':\n        queryset = Product.objects.all()\n        serializer = ProductSerializer(queryset, many=True,\n                                       context={'request': request})\n        return Response(serializer.data)\n\n    if request.method == 'POST':\n        serializer = ProductSerializer(data=request.data)\n        return Response(\"ok\")\n```\n\n当视图方法设置为`GET`, `POST` 时, Django REST framework会自动在接口页面创建一个表单, 以方便我们直接对接口进行测试.\n![post form](/assets/img/img_202311120215571964.png)\n\n## 数据校验\n\n在视图方法中通过序列化对象进行数据校验, 只需要调用`is_valid()`方法即可. 数据会自动根据数据模型的字段和验证器定义进行校验.\n\n```python\nif request.method == 'POST':\n        serializer = ProductSerializer(data=request.data)\n        if serializer.is_valid():\n            print(serializer.validated_data)\n            return Response(\"ok\")\n\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n```\n\n此时, 如果想接口发送一个空对象, 则会得到如下返回信息:\n\n```python\n# HTTP 400 Bad Request\n# Allow: OPTIONS, POST, GET\n# Content-Type: application/json\n# Vary: Accept\n\n{\n    \"title\": [\n        \"This field is required.\"\n    ],\n    \"price\": [\n        \"This field is required.\"\n    ],\n    \"collection\": [\n        \"This field is required.\"\n    ]\n}\n```\n\n> REST framework提供了一个更为简单的实现方式\n>\n> 通过给`is_valid()`方法添加关键字参数`raise_exception=True`便可以得到完全相同的结果\n>\n> ```python\n> if request.method == 'POST':\n>   serializer = ProductSerializer(data=request.data)\n>   serializer.is_valid(raise_exception=True)\n>   print(serializer.validated_data)\n>   return Response(\"ok\")\n> ```\n>\n{: .prompt-tip}\n\n### 前端数据验证\n\n对于`POST`数据不仅仅要进行数据类型, 非空, 查重等数据库验证, 有些时候也会需要进行一些数据有效性的验证.\n比如创建用户操作时, 密码和确认密码是否相同一类.\n\n此时可以直接在序列化对象中直接进行额外验证的编写, 在调用`is_valid()`方法时便会在一同进行自定义验证.\n\n在`ProductSerializer`中添加如下代码:\n\n```python\ndef validate(self, attrs):\n    if attrs['unit_price'] > 100:\n        raise serializers.ValidationError(\"太贵了没人买\")\n\n    return attrs\n```\n\n> 虽然在序列化对象时定义了字段命为`price`, 但这里的字段名称是`unit_price`.\n>\n> 因为验证是在数据反序列化之后才会进行的, 所以`attrs`对象中的键都是`Product`模型类所定义的字段名.\n>\n{: .prompt-warning}\n","slug":"django-rest-deserializing","published":1,"updated":"2023-12-13T08:41:08.348Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v40029i3er986259sd","content":"<p>在客户端发送<code>POST</code>请求至后台时, 需要将其发送的数据转化为python对象, 此时便需要进行反序列化</p>\n<h2 id=\"反序列化的简单实现\"><a href=\"#反序列化的简单实现\" class=\"headerlink\" title=\"反序列化的简单实现\"></a>反序列化的简单实现</h2><p>基于REST的规范, 获取资源和创建资源应该分别对应同一个URL的<code>GET</code>和<code>POST</code>方法.</p>\n<p>所以我们可以直接修改<code>products/</code>路由对应的视图:</p>\n<pre><code class=\"python\">@api_view([&#39;GET&#39;, &#39;POST&#39;])\ndef product_list(request):\n\n    if request.method == &#39;GET&#39;:\n        queryset = Product.objects.all()\n        serializer = ProductSerializer(queryset, many=True,\n                                       context=&#123;&#39;request&#39;: request&#125;)\n        return Response(serializer.data)\n\n    if request.method == &#39;POST&#39;:\n        serializer = ProductSerializer(data=request.data)\n        return Response(&quot;ok&quot;)\n</code></pre>\n<p>当视图方法设置为<code>GET</code>, <code>POST</code> 时, Django REST framework会自动在接口页面创建一个表单, 以方便我们直接对接口进行测试.<br><img src=\"/assets/img/img_202311120215571964.png\" alt=\"post form\"></p>\n<h2 id=\"数据校验\"><a href=\"#数据校验\" class=\"headerlink\" title=\"数据校验\"></a>数据校验</h2><p>在视图方法中通过序列化对象进行数据校验, 只需要调用<code>is_valid()</code>方法即可. 数据会自动根据数据模型的字段和验证器定义进行校验.</p>\n<pre><code class=\"python\">if request.method == &#39;POST&#39;:\n        serializer = ProductSerializer(data=request.data)\n        if serializer.is_valid():\n            print(serializer.validated_data)\n            return Response(&quot;ok&quot;)\n\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n</code></pre>\n<p>此时, 如果想接口发送一个空对象, 则会得到如下返回信息:</p>\n<pre><code class=\"python\"># HTTP 400 Bad Request\n# Allow: OPTIONS, POST, GET\n# Content-Type: application/json\n# Vary: Accept\n\n&#123;\n    &quot;title&quot;: [\n        &quot;This field is required.&quot;\n    ],\n    &quot;price&quot;: [\n        &quot;This field is required.&quot;\n    ],\n    &quot;collection&quot;: [\n        &quot;This field is required.&quot;\n    ]\n&#125;\n</code></pre>\n<blockquote>\n<p>REST framework提供了一个更为简单的实现方式</p>\n<p>通过给<code>is_valid()</code>方法添加关键字参数<code>raise_exception=True</code>便可以得到完全相同的结果</p>\n<pre><code class=\"python\">if request.method == &#39;POST&#39;:\n  serializer = ProductSerializer(data=request.data)\n  serializer.is_valid(raise_exception=True)\n  print(serializer.validated_data)\n  return Response(&quot;ok&quot;)\n</code></pre>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h3 id=\"前端数据验证\"><a href=\"#前端数据验证\" class=\"headerlink\" title=\"前端数据验证\"></a>前端数据验证</h3><p>对于<code>POST</code>数据不仅仅要进行数据类型, 非空, 查重等数据库验证, 有些时候也会需要进行一些数据有效性的验证.<br>比如创建用户操作时, 密码和确认密码是否相同一类.</p>\n<p>此时可以直接在序列化对象中直接进行额外验证的编写, 在调用<code>is_valid()</code>方法时便会在一同进行自定义验证.</p>\n<p>在<code>ProductSerializer</code>中添加如下代码:</p>\n<pre><code class=\"python\">def validate(self, attrs):\n    if attrs[&#39;unit_price&#39;] &gt; 100:\n        raise serializers.ValidationError(&quot;太贵了没人买&quot;)\n\n    return attrs\n</code></pre>\n<blockquote>\n<p>虽然在序列化对象时定义了字段命为<code>price</code>, 但这里的字段名称是<code>unit_price</code>.</p>\n<p>因为验证是在数据反序列化之后才会进行的, 所以<code>attrs</code>对象中的键都是<code>Product</code>模型类所定义的字段名.</p>\n</blockquote>\n<p>{: .prompt-warning}</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>在客户端发送<code>POST</code>请求至后台时, 需要将其发送的数据转化为python对象, 此时便需要进行反序列化</p>\n<h2 id=\"反序列化的简单实现\"><a href=\"#反序列化的简单实现\" class=\"headerlink\" title=\"反序列化的简单实现\"></a>反序列化的简单实现</h2><p>基于REST的规范, 获取资源和创建资源应该分别对应同一个URL的<code>GET</code>和<code>POST</code>方法.</p>\n<p>所以我们可以直接修改<code>products/</code>路由对应的视图:</p>\n<pre><code class=\"python\">@api_view([&#39;GET&#39;, &#39;POST&#39;])\ndef product_list(request):\n\n    if request.method == &#39;GET&#39;:\n        queryset = Product.objects.all()\n        serializer = ProductSerializer(queryset, many=True,\n                                       context=&#123;&#39;request&#39;: request&#125;)\n        return Response(serializer.data)\n\n    if request.method == &#39;POST&#39;:\n        serializer = ProductSerializer(data=request.data)\n        return Response(&quot;ok&quot;)\n</code></pre>\n<p>当视图方法设置为<code>GET</code>, <code>POST</code> 时, Django REST framework会自动在接口页面创建一个表单, 以方便我们直接对接口进行测试.<br><img src=\"/assets/img/img_202311120215571964.png\" alt=\"post form\"></p>\n<h2 id=\"数据校验\"><a href=\"#数据校验\" class=\"headerlink\" title=\"数据校验\"></a>数据校验</h2><p>在视图方法中通过序列化对象进行数据校验, 只需要调用<code>is_valid()</code>方法即可. 数据会自动根据数据模型的字段和验证器定义进行校验.</p>\n<pre><code class=\"python\">if request.method == &#39;POST&#39;:\n        serializer = ProductSerializer(data=request.data)\n        if serializer.is_valid():\n            print(serializer.validated_data)\n            return Response(&quot;ok&quot;)\n\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n</code></pre>\n<p>此时, 如果想接口发送一个空对象, 则会得到如下返回信息:</p>\n<pre><code class=\"python\"># HTTP 400 Bad Request\n# Allow: OPTIONS, POST, GET\n# Content-Type: application/json\n# Vary: Accept\n\n&#123;\n    &quot;title&quot;: [\n        &quot;This field is required.&quot;\n    ],\n    &quot;price&quot;: [\n        &quot;This field is required.&quot;\n    ],\n    &quot;collection&quot;: [\n        &quot;This field is required.&quot;\n    ]\n&#125;\n</code></pre>\n<blockquote>\n<p>REST framework提供了一个更为简单的实现方式</p>\n<p>通过给<code>is_valid()</code>方法添加关键字参数<code>raise_exception=True</code>便可以得到完全相同的结果</p>\n<pre><code class=\"python\">if request.method == &#39;POST&#39;:\n  serializer = ProductSerializer(data=request.data)\n  serializer.is_valid(raise_exception=True)\n  print(serializer.validated_data)\n  return Response(&quot;ok&quot;)\n</code></pre>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h3 id=\"前端数据验证\"><a href=\"#前端数据验证\" class=\"headerlink\" title=\"前端数据验证\"></a>前端数据验证</h3><p>对于<code>POST</code>数据不仅仅要进行数据类型, 非空, 查重等数据库验证, 有些时候也会需要进行一些数据有效性的验证.<br>比如创建用户操作时, 密码和确认密码是否相同一类.</p>\n<p>此时可以直接在序列化对象中直接进行额外验证的编写, 在调用<code>is_valid()</code>方法时便会在一同进行自定义验证.</p>\n<p>在<code>ProductSerializer</code>中添加如下代码:</p>\n<pre><code class=\"python\">def validate(self, attrs):\n    if attrs[&#39;unit_price&#39;] &gt; 100:\n        raise serializers.ValidationError(&quot;太贵了没人买&quot;)\n\n    return attrs\n</code></pre>\n<blockquote>\n<p>虽然在序列化对象时定义了字段命为<code>price</code>, 但这里的字段名称是<code>unit_price</code>.</p>\n<p>因为验证是在数据反序列化之后才会进行的, 所以<code>attrs</code>对象中的键都是<code>Product</code>模型类所定义的字段名.</p>\n</blockquote>\n<p>{: .prompt-warning}</p>\n"},{"title":"7. 自定义模型管理器","date":"2023-12-13T08:41:08.346Z","_content":"\n模型管理器是在调用某个模型的`objects`方法时返回的对象, 如:\n\n```python\nmanager = Product.objects\n```\n\n在 [6. 通用关系查询.md](6. 通用关系查询.md) 中, 封装了通过content-type查询被标记的数据的代码\n\n```python\nfrom django.shortcuts import render\nfrom django.contrib.contenttypes.models import ContentType\nfrom store.models import Product\nfrom tags.models import TaggedItem\n\ndef index(request):\n    content_type = ContentType.objects.get_for_model(Product)\n    query_set = TaggedItem.objects\\\n        .select_related('tag')\\\n        .filter(content_type=content_type, object_id=1)\n\n    return render(request, 'tags.html')\n\n```\n\n但如果每次添加一个查询功能都要封装这些代码显然并不合适, 理想状态下的代码应该是\n\n```python\nTaggedItem.objects.get_tags_from(Product, 1)\n```\n\n此时便需要设置自定义模型管理器\n\n```python\nclass TaggedItemManager(models.Manager):\n    def get_tags_for(self, obj_type, obj_id):\n        content_type = ContentType.objects.get_for_model(obj_type)\n\n        return TaggedItem.objects \\\n            .select_related('tag') \\\n            .filter(\n                content_type=content_type,\n                object_id=obj_id\n            )\n\nclass TaggedItem(models.Model):\n    # 修改模型的管理器对象\n    objects = TaggedItemManager()\n    tag = models.ForeignKey(Tag, on_delete=models.CASCADE)\n    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)\n    object_id = models.PositiveIntegerField()\n    content_object = GenericForeignKey()\n```\n","source":"_posts/django/7-custom-model-manager.md","raw":"---\ntitle: 7. 自定义模型管理器\ndate: 2023-11-7 02:18:11 +08000\ncategories: [笔记, Django]\ntags: [python, django, backend]\n---\n\n模型管理器是在调用某个模型的`objects`方法时返回的对象, 如:\n\n```python\nmanager = Product.objects\n```\n\n在 [6. 通用关系查询.md](6. 通用关系查询.md) 中, 封装了通过content-type查询被标记的数据的代码\n\n```python\nfrom django.shortcuts import render\nfrom django.contrib.contenttypes.models import ContentType\nfrom store.models import Product\nfrom tags.models import TaggedItem\n\ndef index(request):\n    content_type = ContentType.objects.get_for_model(Product)\n    query_set = TaggedItem.objects\\\n        .select_related('tag')\\\n        .filter(content_type=content_type, object_id=1)\n\n    return render(request, 'tags.html')\n\n```\n\n但如果每次添加一个查询功能都要封装这些代码显然并不合适, 理想状态下的代码应该是\n\n```python\nTaggedItem.objects.get_tags_from(Product, 1)\n```\n\n此时便需要设置自定义模型管理器\n\n```python\nclass TaggedItemManager(models.Manager):\n    def get_tags_for(self, obj_type, obj_id):\n        content_type = ContentType.objects.get_for_model(obj_type)\n\n        return TaggedItem.objects \\\n            .select_related('tag') \\\n            .filter(\n                content_type=content_type,\n                object_id=obj_id\n            )\n\nclass TaggedItem(models.Model):\n    # 修改模型的管理器对象\n    objects = TaggedItemManager()\n    tag = models.ForeignKey(Tag, on_delete=models.CASCADE)\n    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)\n    object_id = models.PositiveIntegerField()\n    content_object = GenericForeignKey()\n```\n","slug":"django-7-custom-model-manager","published":1,"updated":"2023-12-13T08:41:08.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v4002di3er3xur5wy0","content":"<p>模型管理器是在调用某个模型的<code>objects</code>方法时返回的对象, 如:</p>\n<pre><code class=\"python\">manager = Product.objects\n</code></pre>\n<p>在 [6. 通用关系查询.md](6. 通用关系查询.md) 中, 封装了通过content-type查询被标记的数据的代码</p>\n<pre><code class=\"python\">from django.shortcuts import render\nfrom django.contrib.contenttypes.models import ContentType\nfrom store.models import Product\nfrom tags.models import TaggedItem\n\ndef index(request):\n    content_type = ContentType.objects.get_for_model(Product)\n    query_set = TaggedItem.objects\\\n        .select_related(&#39;tag&#39;)\\\n        .filter(content_type=content_type, object_id=1)\n\n    return render(request, &#39;tags.html&#39;)\n</code></pre>\n<p>但如果每次添加一个查询功能都要封装这些代码显然并不合适, 理想状态下的代码应该是</p>\n<pre><code class=\"python\">TaggedItem.objects.get_tags_from(Product, 1)\n</code></pre>\n<p>此时便需要设置自定义模型管理器</p>\n<pre><code class=\"python\">class TaggedItemManager(models.Manager):\n    def get_tags_for(self, obj_type, obj_id):\n        content_type = ContentType.objects.get_for_model(obj_type)\n\n        return TaggedItem.objects \\\n            .select_related(&#39;tag&#39;) \\\n            .filter(\n                content_type=content_type,\n                object_id=obj_id\n            )\n\nclass TaggedItem(models.Model):\n    # 修改模型的管理器对象\n    objects = TaggedItemManager()\n    tag = models.ForeignKey(Tag, on_delete=models.CASCADE)\n    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)\n    object_id = models.PositiveIntegerField()\n    content_object = GenericForeignKey()\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>模型管理器是在调用某个模型的<code>objects</code>方法时返回的对象, 如:</p>\n<pre><code class=\"python\">manager = Product.objects\n</code></pre>\n<p>在 [6. 通用关系查询.md](6. 通用关系查询.md) 中, 封装了通过content-type查询被标记的数据的代码</p>\n<pre><code class=\"python\">from django.shortcuts import render\nfrom django.contrib.contenttypes.models import ContentType\nfrom store.models import Product\nfrom tags.models import TaggedItem\n\ndef index(request):\n    content_type = ContentType.objects.get_for_model(Product)\n    query_set = TaggedItem.objects\\\n        .select_related(&#39;tag&#39;)\\\n        .filter(content_type=content_type, object_id=1)\n\n    return render(request, &#39;tags.html&#39;)\n</code></pre>\n<p>但如果每次添加一个查询功能都要封装这些代码显然并不合适, 理想状态下的代码应该是</p>\n<pre><code class=\"python\">TaggedItem.objects.get_tags_from(Product, 1)\n</code></pre>\n<p>此时便需要设置自定义模型管理器</p>\n<pre><code class=\"python\">class TaggedItemManager(models.Manager):\n    def get_tags_for(self, obj_type, obj_id):\n        content_type = ContentType.objects.get_for_model(obj_type)\n\n        return TaggedItem.objects \\\n            .select_related(&#39;tag&#39;) \\\n            .filter(\n                content_type=content_type,\n                object_id=obj_id\n            )\n\nclass TaggedItem(models.Model):\n    # 修改模型的管理器对象\n    objects = TaggedItemManager()\n    tag = models.ForeignKey(Tag, on_delete=models.CASCADE)\n    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)\n    object_id = models.PositiveIntegerField()\n    content_object = GenericForeignKey()\n</code></pre>\n"},{"title":"18. Django rest framework 视图集","date":"2023-11-12T18:52:50.000Z","_content":"\n回顾之前的内容, 通过通用视图对接口进行了简化, 最终得到了代码:\n\n```python\nclass ProductList(generics.ListCreateAPIView):\n\n    serializer_class = ProductSerializer\n    queryset = Product.objects.select_related('collection').all()\n\n\nclass ProductDetail(generics.RetrieveUpdateDestroyAPIView):\n\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    def delete(self, request, *args, **kwargs):\n        product = self.get_object()\n        if product.orderitem_set.count() > 0:\n            return Response({'error': 'Product has been ordered.'},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n\n这两个类相较最初的视图方法和视图类已经进行了极大的简化, 但是任然存在重复的代码或者模式.\n\n事实上, `select_related('collection')`也仅仅只是为了测试字符串关联查询而临时加上去的. 所以两个类真正不同的地方仅有`delete`函数而已.\n\nREST Framework针对这种情况提供了另外一种解决方案, 视图集, 代码如下:\n\n```python\nfrom rest_framework.viewsets import ModelViewSet\n\nclass ProductViewSet(ModelViewSet):\n    serializer_class = ProductSerializer\n    queryset = Product.objects.all()\n\n    def delete(self, request, *args, **kwargs):\n        product = self.get_object()\n        if product.orderitem_set.count() > 0:\n            return Response({'error': 'Product has been ordered.'},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n\n仅需要更改一下父类, 并把代码进行简单和并即可, 而查看`ModelViewSet`的源码可以发现, 其本质也是一个包含多种`Mixin`的通用视图:\n\n```python\nclass ModelViewSet(mixins.CreateModelMixin,\n                   mixins.RetrieveModelMixin,\n                   mixins.UpdateModelMixin,\n                   mixins.DestroyModelMixin,\n                   mixins.ListModelMixin,\n                   GenericViewSet):\n    \"\"\"\n    A viewset that provides default `create()`, `retrieve()`, `update()`,\n    `partial_update()`, `destroy()` and `list()` actions.\n    \"\"\"\n    pass\n```\n\n## 路由设置\n\n当使用了视图集时, 对于接口路由的配置也需要进行对应的改动, 不再需要手动的设置接口对应的具体视图与名称, 而是交由`Router`进行自动设置. 代码如下:\n\n```python\nfrom django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\n\nfrom .views import generic_api\n\n\nrouter = DefaultRouter()\nrouter.register('products', generic_api.ProductViewSet)\nrouter.register('collectons', generic_api.CollectionViewSet)\n\nurlpatterns = [\n    path('', include(router.urls)),\n    # other path you need.\n]\n```\n\n只需简单几个步骤:\n\n1. 导入`DefaultRouter`, 并创建对象\n2. 注册视图名与对应的视图集\n3. 在urlpatterns中包含生成的路由配置\n\n查看`router.urls`可以看到, 我们已经得到了一个完整的路由配置列表, 与之前的配置功能一样, 并自动为每一个路由生成了名称.\n\n```bash\n[\n    <URLPattern '^products/$' [name='product-list']>,\n    <URLPattern '^products/(?P<pk>[^/.]+)/$' [name='product-detail']>,\n    <URLPattern '^collectons/$' [name='collection-list']>,\n    <URLPattern '^collectons/(?P<pk>[^/.]+)/$' [name='collection-detail']>\n]\n```\n\n除了自动完成了具体的路由配置之外, DefaultRouter还会配置一个根目录路由, 并在访问app是提供一个页面:\n\n![preview](/assets/img/img_202311130250548202.png)\n__`store/` API页面__\n\n> 如果不想要这个页面, 也可以使用`SimpleRouter`.\n>\n{: .prompt-tip}\n\n## 关于视图集DELETE方法的一个大坑\n\n在尝试将通用视图改为视图集的实现方式是, 可以正确的执行查询和更新操作, 但是在删除时出现了问题:\n\n![exception](/assets/img/img_202311130227323161.png)\n\n即删除逻辑并没有执行, 而是直接调用了序列化对象的`delete()`方法, 导致直接抛出了依赖保护异常.\n\n在将配置文件切换回通用视图后正常, 转到视图集后便出现问题. 查询源码发现了问题所在.\n\n在通过`APIView`方式处理时, 代码如下:\n\n```python\nclass ProductDetail(generics.RetrieveUpdateDestroyAPIView):\n    # code\n\n    def delete(self, request, *args, **kwargs):\n        # logic\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n\n通过查看 `RetrieveUpdateDestroyAPIView` 类的源码:\n\n```python\n\nclass RetrieveUpdateDestroyAPIView(mixins.RetrieveModelMixin,\n                                   mixins.UpdateModelMixin,\n                                   mixins.DestroyModelMixin,\n                                   GenericAPIView):\n\n    # other method\n\n    def delete(self, request, *args, **kwargs):\n        return self.destroy(request, *args, **kwargs)\n\n```\n\n可以看到, 父类的`delete`方法调用的是`self.destroy()`方法, 而这个`destroy`方法则是`destroyModelMixin`所定义的方法\n\n```python\nclass DestroyModelMixin:\n    \"\"\"\n    Destroy a model instance.\n    \"\"\"\n    def destroy(self, request, *args, **kwargs):\n        instance = self.get_object()\n        self.perform_destroy(instance)\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n    def perform_destroy(self, instance):\n        instance.delete()\n```\n\n再看`ModelViewSet`类的源码:\n\n```python\nclass ModelViewSet(mixins.CreateModelMixin,\n                   mixins.RetrieveModelMixin,\n                   mixins.UpdateModelMixin,\n                   mixins.DestroyModelMixin,\n                   mixins.ListModelMixin,\n                   GenericViewSet):\n    \"\"\"\n    A viewset that provides default `create()`, `retrieve()`, `update()`,\n    `partial_update()`, `destroy()` and `list()` actions.\n    \"\"\"\n    pass\n\n```\n\n这或直接写了个pass, 也就是说自定义的`ViewSet`不会重写父类的`delete`方法, 因为父类就没有`delete`方法.\n\n而`ViewSet`能够执行删除操作, 显然是交由路由配置之后直接调用了`destroy()`方法.\n\n所以之前在`ViewSet`中定义的`delete`方法虽然有判断逻辑, 但是却被直接跳过了.\n\n解决方式也很简单, 将`ViewSet`中的`delete`方法名改为`destroy`即可:\n\n```python\nclass ProductViewSet(ModelViewSet):\n    serializer_class = ProductSerializer\n    queryset = Product.objects.all()\n\n    def destroy(self, request, *args, **kwargs):\n        product = self.get_object()\n        print(product)\n        if product.orderitem_set.count() > 0:\n            return Response({'error': 'Product has been ordered.'},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n","source":"_posts/django/rest-view-set-and-router.md","raw":"---\ntitle: 18. Django rest framework 视图集\ndate: 2023-11-13 02:52:50 +0800\ncategories: [笔记, Django]\ntags: [python, django, backend, REST]\n---\n\n回顾之前的内容, 通过通用视图对接口进行了简化, 最终得到了代码:\n\n```python\nclass ProductList(generics.ListCreateAPIView):\n\n    serializer_class = ProductSerializer\n    queryset = Product.objects.select_related('collection').all()\n\n\nclass ProductDetail(generics.RetrieveUpdateDestroyAPIView):\n\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    def delete(self, request, *args, **kwargs):\n        product = self.get_object()\n        if product.orderitem_set.count() > 0:\n            return Response({'error': 'Product has been ordered.'},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n\n这两个类相较最初的视图方法和视图类已经进行了极大的简化, 但是任然存在重复的代码或者模式.\n\n事实上, `select_related('collection')`也仅仅只是为了测试字符串关联查询而临时加上去的. 所以两个类真正不同的地方仅有`delete`函数而已.\n\nREST Framework针对这种情况提供了另外一种解决方案, 视图集, 代码如下:\n\n```python\nfrom rest_framework.viewsets import ModelViewSet\n\nclass ProductViewSet(ModelViewSet):\n    serializer_class = ProductSerializer\n    queryset = Product.objects.all()\n\n    def delete(self, request, *args, **kwargs):\n        product = self.get_object()\n        if product.orderitem_set.count() > 0:\n            return Response({'error': 'Product has been ordered.'},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n\n仅需要更改一下父类, 并把代码进行简单和并即可, 而查看`ModelViewSet`的源码可以发现, 其本质也是一个包含多种`Mixin`的通用视图:\n\n```python\nclass ModelViewSet(mixins.CreateModelMixin,\n                   mixins.RetrieveModelMixin,\n                   mixins.UpdateModelMixin,\n                   mixins.DestroyModelMixin,\n                   mixins.ListModelMixin,\n                   GenericViewSet):\n    \"\"\"\n    A viewset that provides default `create()`, `retrieve()`, `update()`,\n    `partial_update()`, `destroy()` and `list()` actions.\n    \"\"\"\n    pass\n```\n\n## 路由设置\n\n当使用了视图集时, 对于接口路由的配置也需要进行对应的改动, 不再需要手动的设置接口对应的具体视图与名称, 而是交由`Router`进行自动设置. 代码如下:\n\n```python\nfrom django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\n\nfrom .views import generic_api\n\n\nrouter = DefaultRouter()\nrouter.register('products', generic_api.ProductViewSet)\nrouter.register('collectons', generic_api.CollectionViewSet)\n\nurlpatterns = [\n    path('', include(router.urls)),\n    # other path you need.\n]\n```\n\n只需简单几个步骤:\n\n1. 导入`DefaultRouter`, 并创建对象\n2. 注册视图名与对应的视图集\n3. 在urlpatterns中包含生成的路由配置\n\n查看`router.urls`可以看到, 我们已经得到了一个完整的路由配置列表, 与之前的配置功能一样, 并自动为每一个路由生成了名称.\n\n```bash\n[\n    <URLPattern '^products/$' [name='product-list']>,\n    <URLPattern '^products/(?P<pk>[^/.]+)/$' [name='product-detail']>,\n    <URLPattern '^collectons/$' [name='collection-list']>,\n    <URLPattern '^collectons/(?P<pk>[^/.]+)/$' [name='collection-detail']>\n]\n```\n\n除了自动完成了具体的路由配置之外, DefaultRouter还会配置一个根目录路由, 并在访问app是提供一个页面:\n\n![preview](/assets/img/img_202311130250548202.png)\n__`store/` API页面__\n\n> 如果不想要这个页面, 也可以使用`SimpleRouter`.\n>\n{: .prompt-tip}\n\n## 关于视图集DELETE方法的一个大坑\n\n在尝试将通用视图改为视图集的实现方式是, 可以正确的执行查询和更新操作, 但是在删除时出现了问题:\n\n![exception](/assets/img/img_202311130227323161.png)\n\n即删除逻辑并没有执行, 而是直接调用了序列化对象的`delete()`方法, 导致直接抛出了依赖保护异常.\n\n在将配置文件切换回通用视图后正常, 转到视图集后便出现问题. 查询源码发现了问题所在.\n\n在通过`APIView`方式处理时, 代码如下:\n\n```python\nclass ProductDetail(generics.RetrieveUpdateDestroyAPIView):\n    # code\n\n    def delete(self, request, *args, **kwargs):\n        # logic\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n\n通过查看 `RetrieveUpdateDestroyAPIView` 类的源码:\n\n```python\n\nclass RetrieveUpdateDestroyAPIView(mixins.RetrieveModelMixin,\n                                   mixins.UpdateModelMixin,\n                                   mixins.DestroyModelMixin,\n                                   GenericAPIView):\n\n    # other method\n\n    def delete(self, request, *args, **kwargs):\n        return self.destroy(request, *args, **kwargs)\n\n```\n\n可以看到, 父类的`delete`方法调用的是`self.destroy()`方法, 而这个`destroy`方法则是`destroyModelMixin`所定义的方法\n\n```python\nclass DestroyModelMixin:\n    \"\"\"\n    Destroy a model instance.\n    \"\"\"\n    def destroy(self, request, *args, **kwargs):\n        instance = self.get_object()\n        self.perform_destroy(instance)\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n    def perform_destroy(self, instance):\n        instance.delete()\n```\n\n再看`ModelViewSet`类的源码:\n\n```python\nclass ModelViewSet(mixins.CreateModelMixin,\n                   mixins.RetrieveModelMixin,\n                   mixins.UpdateModelMixin,\n                   mixins.DestroyModelMixin,\n                   mixins.ListModelMixin,\n                   GenericViewSet):\n    \"\"\"\n    A viewset that provides default `create()`, `retrieve()`, `update()`,\n    `partial_update()`, `destroy()` and `list()` actions.\n    \"\"\"\n    pass\n\n```\n\n这或直接写了个pass, 也就是说自定义的`ViewSet`不会重写父类的`delete`方法, 因为父类就没有`delete`方法.\n\n而`ViewSet`能够执行删除操作, 显然是交由路由配置之后直接调用了`destroy()`方法.\n\n所以之前在`ViewSet`中定义的`delete`方法虽然有判断逻辑, 但是却被直接跳过了.\n\n解决方式也很简单, 将`ViewSet`中的`delete`方法名改为`destroy`即可:\n\n```python\nclass ProductViewSet(ModelViewSet):\n    serializer_class = ProductSerializer\n    queryset = Product.objects.all()\n\n    def destroy(self, request, *args, **kwargs):\n        product = self.get_object()\n        print(product)\n        if product.orderitem_set.count() > 0:\n            return Response({'error': 'Product has been ordered.'},\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n","slug":"django-rest-view-set-and-router","published":1,"updated":"2023-12-13T08:41:08.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v4002fi3er6qixg83b","content":"<p>回顾之前的内容, 通过通用视图对接口进行了简化, 最终得到了代码:</p>\n<pre><code class=\"python\">class ProductList(generics.ListCreateAPIView):\n\n    serializer_class = ProductSerializer\n    queryset = Product.objects.select_related(&#39;collection&#39;).all()\n\n\nclass ProductDetail(generics.RetrieveUpdateDestroyAPIView):\n\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    def delete(self, request, *args, **kwargs):\n        product = self.get_object()\n        if product.orderitem_set.count() &gt; 0:\n            return Response(&#123;&#39;error&#39;: &#39;Product has been ordered.&#39;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>这两个类相较最初的视图方法和视图类已经进行了极大的简化, 但是任然存在重复的代码或者模式.</p>\n<p>事实上, <code>select_related(&#39;collection&#39;)</code>也仅仅只是为了测试字符串关联查询而临时加上去的. 所以两个类真正不同的地方仅有<code>delete</code>函数而已.</p>\n<p>REST Framework针对这种情况提供了另外一种解决方案, 视图集, 代码如下:</p>\n<pre><code class=\"python\">from rest_framework.viewsets import ModelViewSet\n\nclass ProductViewSet(ModelViewSet):\n    serializer_class = ProductSerializer\n    queryset = Product.objects.all()\n\n    def delete(self, request, *args, **kwargs):\n        product = self.get_object()\n        if product.orderitem_set.count() &gt; 0:\n            return Response(&#123;&#39;error&#39;: &#39;Product has been ordered.&#39;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>仅需要更改一下父类, 并把代码进行简单和并即可, 而查看<code>ModelViewSet</code>的源码可以发现, 其本质也是一个包含多种<code>Mixin</code>的通用视图:</p>\n<pre><code class=\"python\">class ModelViewSet(mixins.CreateModelMixin,\n                   mixins.RetrieveModelMixin,\n                   mixins.UpdateModelMixin,\n                   mixins.DestroyModelMixin,\n                   mixins.ListModelMixin,\n                   GenericViewSet):\n    &quot;&quot;&quot;\n    A viewset that provides default `create()`, `retrieve()`, `update()`,\n    `partial_update()`, `destroy()` and `list()` actions.\n    &quot;&quot;&quot;\n    pass\n</code></pre>\n<h2 id=\"路由设置\"><a href=\"#路由设置\" class=\"headerlink\" title=\"路由设置\"></a>路由设置</h2><p>当使用了视图集时, 对于接口路由的配置也需要进行对应的改动, 不再需要手动的设置接口对应的具体视图与名称, 而是交由<code>Router</code>进行自动设置. 代码如下:</p>\n<pre><code class=\"python\">from django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\n\nfrom .views import generic_api\n\n\nrouter = DefaultRouter()\nrouter.register(&#39;products&#39;, generic_api.ProductViewSet)\nrouter.register(&#39;collectons&#39;, generic_api.CollectionViewSet)\n\nurlpatterns = [\n    path(&#39;&#39;, include(router.urls)),\n    # other path you need.\n]\n</code></pre>\n<p>只需简单几个步骤:</p>\n<ol>\n<li>导入<code>DefaultRouter</code>, 并创建对象</li>\n<li>注册视图名与对应的视图集</li>\n<li>在urlpatterns中包含生成的路由配置</li>\n</ol>\n<p>查看<code>router.urls</code>可以看到, 我们已经得到了一个完整的路由配置列表, 与之前的配置功能一样, 并自动为每一个路由生成了名称.</p>\n<pre><code class=\"bash\">[\n    &lt;URLPattern &#39;^products/$&#39; [name=&#39;product-list&#39;]&gt;,\n    &lt;URLPattern &#39;^products/(?P&lt;pk&gt;[^/.]+)/$&#39; [name=&#39;product-detail&#39;]&gt;,\n    &lt;URLPattern &#39;^collectons/$&#39; [name=&#39;collection-list&#39;]&gt;,\n    &lt;URLPattern &#39;^collectons/(?P&lt;pk&gt;[^/.]+)/$&#39; [name=&#39;collection-detail&#39;]&gt;\n]\n</code></pre>\n<p>除了自动完成了具体的路由配置之外, DefaultRouter还会配置一个根目录路由, 并在访问app是提供一个页面:</p>\n<p><img src=\"/assets/img/img_202311130250548202.png\" alt=\"preview\"><br><strong><code>store/</code> API页面</strong></p>\n<blockquote>\n<p>如果不想要这个页面, 也可以使用<code>SimpleRouter</code>.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h2 id=\"关于视图集DELETE方法的一个大坑\"><a href=\"#关于视图集DELETE方法的一个大坑\" class=\"headerlink\" title=\"关于视图集DELETE方法的一个大坑\"></a>关于视图集DELETE方法的一个大坑</h2><p>在尝试将通用视图改为视图集的实现方式是, 可以正确的执行查询和更新操作, 但是在删除时出现了问题:</p>\n<p><img src=\"/assets/img/img_202311130227323161.png\" alt=\"exception\"></p>\n<p>即删除逻辑并没有执行, 而是直接调用了序列化对象的<code>delete()</code>方法, 导致直接抛出了依赖保护异常.</p>\n<p>在将配置文件切换回通用视图后正常, 转到视图集后便出现问题. 查询源码发现了问题所在.</p>\n<p>在通过<code>APIView</code>方式处理时, 代码如下:</p>\n<pre><code class=\"python\">class ProductDetail(generics.RetrieveUpdateDestroyAPIView):\n    # code\n\n    def delete(self, request, *args, **kwargs):\n        # logic\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>通过查看 <code>RetrieveUpdateDestroyAPIView</code> 类的源码:</p>\n<pre><code class=\"python\">\nclass RetrieveUpdateDestroyAPIView(mixins.RetrieveModelMixin,\n                                   mixins.UpdateModelMixin,\n                                   mixins.DestroyModelMixin,\n                                   GenericAPIView):\n\n    # other method\n\n    def delete(self, request, *args, **kwargs):\n        return self.destroy(request, *args, **kwargs)\n</code></pre>\n<p>可以看到, 父类的<code>delete</code>方法调用的是<code>self.destroy()</code>方法, 而这个<code>destroy</code>方法则是<code>destroyModelMixin</code>所定义的方法</p>\n<pre><code class=\"python\">class DestroyModelMixin:\n    &quot;&quot;&quot;\n    Destroy a model instance.\n    &quot;&quot;&quot;\n    def destroy(self, request, *args, **kwargs):\n        instance = self.get_object()\n        self.perform_destroy(instance)\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n    def perform_destroy(self, instance):\n        instance.delete()\n</code></pre>\n<p>再看<code>ModelViewSet</code>类的源码:</p>\n<pre><code class=\"python\">class ModelViewSet(mixins.CreateModelMixin,\n                   mixins.RetrieveModelMixin,\n                   mixins.UpdateModelMixin,\n                   mixins.DestroyModelMixin,\n                   mixins.ListModelMixin,\n                   GenericViewSet):\n    &quot;&quot;&quot;\n    A viewset that provides default `create()`, `retrieve()`, `update()`,\n    `partial_update()`, `destroy()` and `list()` actions.\n    &quot;&quot;&quot;\n    pass\n</code></pre>\n<p>这或直接写了个pass, 也就是说自定义的<code>ViewSet</code>不会重写父类的<code>delete</code>方法, 因为父类就没有<code>delete</code>方法.</p>\n<p>而<code>ViewSet</code>能够执行删除操作, 显然是交由路由配置之后直接调用了<code>destroy()</code>方法.</p>\n<p>所以之前在<code>ViewSet</code>中定义的<code>delete</code>方法虽然有判断逻辑, 但是却被直接跳过了.</p>\n<p>解决方式也很简单, 将<code>ViewSet</code>中的<code>delete</code>方法名改为<code>destroy</code>即可:</p>\n<pre><code class=\"python\">class ProductViewSet(ModelViewSet):\n    serializer_class = ProductSerializer\n    queryset = Product.objects.all()\n\n    def destroy(self, request, *args, **kwargs):\n        product = self.get_object()\n        print(product)\n        if product.orderitem_set.count() &gt; 0:\n            return Response(&#123;&#39;error&#39;: &#39;Product has been ordered.&#39;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>回顾之前的内容, 通过通用视图对接口进行了简化, 最终得到了代码:</p>\n<pre><code class=\"python\">class ProductList(generics.ListCreateAPIView):\n\n    serializer_class = ProductSerializer\n    queryset = Product.objects.select_related(&#39;collection&#39;).all()\n\n\nclass ProductDetail(generics.RetrieveUpdateDestroyAPIView):\n\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n\n    def delete(self, request, *args, **kwargs):\n        product = self.get_object()\n        if product.orderitem_set.count() &gt; 0:\n            return Response(&#123;&#39;error&#39;: &#39;Product has been ordered.&#39;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>这两个类相较最初的视图方法和视图类已经进行了极大的简化, 但是任然存在重复的代码或者模式.</p>\n<p>事实上, <code>select_related(&#39;collection&#39;)</code>也仅仅只是为了测试字符串关联查询而临时加上去的. 所以两个类真正不同的地方仅有<code>delete</code>函数而已.</p>\n<p>REST Framework针对这种情况提供了另外一种解决方案, 视图集, 代码如下:</p>\n<pre><code class=\"python\">from rest_framework.viewsets import ModelViewSet\n\nclass ProductViewSet(ModelViewSet):\n    serializer_class = ProductSerializer\n    queryset = Product.objects.all()\n\n    def delete(self, request, *args, **kwargs):\n        product = self.get_object()\n        if product.orderitem_set.count() &gt; 0:\n            return Response(&#123;&#39;error&#39;: &#39;Product has been ordered.&#39;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>仅需要更改一下父类, 并把代码进行简单和并即可, 而查看<code>ModelViewSet</code>的源码可以发现, 其本质也是一个包含多种<code>Mixin</code>的通用视图:</p>\n<pre><code class=\"python\">class ModelViewSet(mixins.CreateModelMixin,\n                   mixins.RetrieveModelMixin,\n                   mixins.UpdateModelMixin,\n                   mixins.DestroyModelMixin,\n                   mixins.ListModelMixin,\n                   GenericViewSet):\n    &quot;&quot;&quot;\n    A viewset that provides default `create()`, `retrieve()`, `update()`,\n    `partial_update()`, `destroy()` and `list()` actions.\n    &quot;&quot;&quot;\n    pass\n</code></pre>\n<h2 id=\"路由设置\"><a href=\"#路由设置\" class=\"headerlink\" title=\"路由设置\"></a>路由设置</h2><p>当使用了视图集时, 对于接口路由的配置也需要进行对应的改动, 不再需要手动的设置接口对应的具体视图与名称, 而是交由<code>Router</code>进行自动设置. 代码如下:</p>\n<pre><code class=\"python\">from django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\n\nfrom .views import generic_api\n\n\nrouter = DefaultRouter()\nrouter.register(&#39;products&#39;, generic_api.ProductViewSet)\nrouter.register(&#39;collectons&#39;, generic_api.CollectionViewSet)\n\nurlpatterns = [\n    path(&#39;&#39;, include(router.urls)),\n    # other path you need.\n]\n</code></pre>\n<p>只需简单几个步骤:</p>\n<ol>\n<li>导入<code>DefaultRouter</code>, 并创建对象</li>\n<li>注册视图名与对应的视图集</li>\n<li>在urlpatterns中包含生成的路由配置</li>\n</ol>\n<p>查看<code>router.urls</code>可以看到, 我们已经得到了一个完整的路由配置列表, 与之前的配置功能一样, 并自动为每一个路由生成了名称.</p>\n<pre><code class=\"bash\">[\n    &lt;URLPattern &#39;^products/$&#39; [name=&#39;product-list&#39;]&gt;,\n    &lt;URLPattern &#39;^products/(?P&lt;pk&gt;[^/.]+)/$&#39; [name=&#39;product-detail&#39;]&gt;,\n    &lt;URLPattern &#39;^collectons/$&#39; [name=&#39;collection-list&#39;]&gt;,\n    &lt;URLPattern &#39;^collectons/(?P&lt;pk&gt;[^/.]+)/$&#39; [name=&#39;collection-detail&#39;]&gt;\n]\n</code></pre>\n<p>除了自动完成了具体的路由配置之外, DefaultRouter还会配置一个根目录路由, 并在访问app是提供一个页面:</p>\n<p><img src=\"/assets/img/img_202311130250548202.png\" alt=\"preview\"><br><strong><code>store/</code> API页面</strong></p>\n<blockquote>\n<p>如果不想要这个页面, 也可以使用<code>SimpleRouter</code>.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h2 id=\"关于视图集DELETE方法的一个大坑\"><a href=\"#关于视图集DELETE方法的一个大坑\" class=\"headerlink\" title=\"关于视图集DELETE方法的一个大坑\"></a>关于视图集DELETE方法的一个大坑</h2><p>在尝试将通用视图改为视图集的实现方式是, 可以正确的执行查询和更新操作, 但是在删除时出现了问题:</p>\n<p><img src=\"/assets/img/img_202311130227323161.png\" alt=\"exception\"></p>\n<p>即删除逻辑并没有执行, 而是直接调用了序列化对象的<code>delete()</code>方法, 导致直接抛出了依赖保护异常.</p>\n<p>在将配置文件切换回通用视图后正常, 转到视图集后便出现问题. 查询源码发现了问题所在.</p>\n<p>在通过<code>APIView</code>方式处理时, 代码如下:</p>\n<pre><code class=\"python\">class ProductDetail(generics.RetrieveUpdateDestroyAPIView):\n    # code\n\n    def delete(self, request, *args, **kwargs):\n        # logic\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n<p>通过查看 <code>RetrieveUpdateDestroyAPIView</code> 类的源码:</p>\n<pre><code class=\"python\">\nclass RetrieveUpdateDestroyAPIView(mixins.RetrieveModelMixin,\n                                   mixins.UpdateModelMixin,\n                                   mixins.DestroyModelMixin,\n                                   GenericAPIView):\n\n    # other method\n\n    def delete(self, request, *args, **kwargs):\n        return self.destroy(request, *args, **kwargs)\n</code></pre>\n<p>可以看到, 父类的<code>delete</code>方法调用的是<code>self.destroy()</code>方法, 而这个<code>destroy</code>方法则是<code>destroyModelMixin</code>所定义的方法</p>\n<pre><code class=\"python\">class DestroyModelMixin:\n    &quot;&quot;&quot;\n    Destroy a model instance.\n    &quot;&quot;&quot;\n    def destroy(self, request, *args, **kwargs):\n        instance = self.get_object()\n        self.perform_destroy(instance)\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\n    def perform_destroy(self, instance):\n        instance.delete()\n</code></pre>\n<p>再看<code>ModelViewSet</code>类的源码:</p>\n<pre><code class=\"python\">class ModelViewSet(mixins.CreateModelMixin,\n                   mixins.RetrieveModelMixin,\n                   mixins.UpdateModelMixin,\n                   mixins.DestroyModelMixin,\n                   mixins.ListModelMixin,\n                   GenericViewSet):\n    &quot;&quot;&quot;\n    A viewset that provides default `create()`, `retrieve()`, `update()`,\n    `partial_update()`, `destroy()` and `list()` actions.\n    &quot;&quot;&quot;\n    pass\n</code></pre>\n<p>这或直接写了个pass, 也就是说自定义的<code>ViewSet</code>不会重写父类的<code>delete</code>方法, 因为父类就没有<code>delete</code>方法.</p>\n<p>而<code>ViewSet</code>能够执行删除操作, 显然是交由路由配置之后直接调用了<code>destroy()</code>方法.</p>\n<p>所以之前在<code>ViewSet</code>中定义的<code>delete</code>方法虽然有判断逻辑, 但是却被直接跳过了.</p>\n<p>解决方式也很简单, 将<code>ViewSet</code>中的<code>delete</code>方法名改为<code>destroy</code>即可:</p>\n<pre><code class=\"python\">class ProductViewSet(ModelViewSet):\n    serializer_class = ProductSerializer\n    queryset = Product.objects.all()\n\n    def destroy(self, request, *args, **kwargs):\n        product = self.get_object()\n        print(product)\n        if product.orderitem_set.count() &gt; 0:\n            return Response(&#123;&#39;error&#39;: &#39;Product has been ordered.&#39;&#125;,\n                            status=status.HTTP_405_METHOD_NOT_ALLOWED)\n\n        product.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>\n"},{"title":"11. Django Rest Framework 序列化","date":"2023-12-13T08:41:08.349Z","_content":"\nREST Framework提供了一个`JSONRenderer`对象, 可以将python的词典对象序列化为json对象.\n\n同时提供了一个`Serializer`对象, 用于将models转化为python词典.\n\n在`store`app中创建一个`serializer.py`文件\n\n```python\nfrom rest_framework import serializers\n\n\nclass ProductSerializer(serializers.Serializer):\n    id = serializers.IntegerField()\n    title = serializers.CharField(max_length=255)\n    unit_price = serializers.DecimalField(max_digits=6,decimal_places=2)\n```\n\n> 使用序列化对象, 而非直接通过模型对象获取数据, 好处在于:\n>\n> * 简化序列化代码, 并使序列化方式统一, 可以在任意位置通过相同的方式一次性完成序列化, 而不是对模型对象进行零散的维护\n> * 隐藏不需要显示的字段\n{: .prompt-tip}\n\n在完成了序列化对象的设置之后, 便可以修改视图函数的代码:\n\n```python\n@api_view()  # 该装饰器替换默认的request对象为djangorestframework的request对象\ndef product_list(request):\n\n    queryset = Product.objects.all()\n    serializer = ProductSerializer(queryset, many=True)\n\n    # 使用djangorestframwork的Response返回数据\n    return Response(serializer.data)\n\n\n@api_view()\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n    serializer = ProductSerializer(product)\n    return Response(serializer.data)\n```\n\n此时通过URL访问视图便可以得到具体的数据了\n\n![result](/assets/img/img_202311111749462365.png)\n\n> django rest framework 会自动把Decimal类型的数据转换为字符串, 如果不希望转换, 可以在`project/settings.py`文件中加入一下设置:\n>\n> ```python\n> REST_FRAMEWORK = {\n>     'COERCE_DECIMAL_TO_STRING': False\n> }\n> ```\n>\n{: .prompt-tip}\n\n## 自定义的序列化字段\n\n序列化对象的目的在于确定接口的呈现形式, 以此来与后台的数据模型解耦.\n从命名规则上来说, 数据库字段的名称与前端需要的字段名称可能不同, 通过序列化对象便可以轻松的解决这一问题.\n同时, 后台的数据模型可能会做各种类型的修改, 但是这些修改只关乎后台, 而无需让用户知道.\n通过自定义序列化字段便可以实现这一目的, 比如:\n\n* 增加模型中不存在的字段\n* 更改字段的名称\n* etc\n\n假设需要再接口中增加一个含税价格字段, 可以使用如下代码:\n\n```python\nfrom decimal import Decimal\nfrom rest_framework import serializers\nfrom store.models import Product\n\n\nclass ProductSerializer(serializers.Serializer):\n    id = serializers.IntegerField()\n    title = serializers.CharField(max_length=255)\n    price = serializers.DecimalField(max_digits=6,\n                                     decimal_places=2,\n                                     source=\"unit_price\")\n\n    price_with_tax = serializers.SerializerMethodField(\n        method_name=\"calc_price_with_tax\")\n\n    def calc_price_with_tax(self, product: Product):\n        return product.unit_price * Decimal(1.17)\n\n```\n\n## 关联查询的序列化\n\nProduct和Collection之间存在多对一的关系, 在Product中通过外键`collection`进行链接.\n那么在序列化Product时便可以将collection的数据同时序列化.\n\n### PrimaryKeyRelatedField\n\n```python\ncollection = serializers.PrimaryKeyRelatedField(\n        queryset=Collection.objects.all()\n    )\n```\n\n> 根据官方文档说明\n>\n> ```text\n> `queryset` - \n> The queryset used for model instance lookups when validating the field input. \n> Relationships must either set a queryset explicitly, or set read_only=True.\n> ```\n>\n> 该参数是用来对于输入数据进行验证的, 应该是说反序列化时进行数据库查重的范围. 所以, 如果该字段不需要修改, 仅仅是读取内容, 也可以用参数`read_only=True`替代.\n> [相关文档](https://www.django-rest-framework.org/api-guide/relations/#primarykeyrelatedfield)\n>\n{: .prompt-tip}\n\n### StringRelatedField\n\n如果希望关联查询出的不仅是id, 比如Collection的`title`, 可以写成\n\n```python\ncollection_title = serializers.StringRelatedField(source='collection')\n```\n\n> 由于`collection`成员已经被定义为了`PrimaryKeyRelatedField`, 所以使用了`collection_title`作为成员名\n> 但是`Collection`对象中并没有与该成员同名的字段, 所以必须显示的声明其`source`为`collection`.\n>\n{: .prompt-info}\n\n但此时运行程序, 会出现一个严重问题, 为了获取每个Product对应的Collection标题, 额外执行了与Product数量相同的SQL查询\n![result](/assets/img/img_202311112225443281.png)\n\n> 原因在于Product在查询时并没有同步查询Collection的其他字段, 所以在序列化的时候才会根据每一个Product重新查询其对应的collection的`title`\n{: .prompt-danger}\n\n为了解决直接以问题, 需要在视图方法中加入对`Collection`的关联查询:\n\n```python\n@api_view()\ndef product_list(request):\n    queryset = Product.objects.select_related('collection').all()\n    serializer = ProductSerializer(queryset, many=True)\n    return Response(serializer.data)\n```\n\n### Nested Serializer\n\nProduct有自己的序列化对象, Collection同样可以有自己的序列化对象.\n\n```python\nclass CollectionSerializer(serializers.Serializer):\n    id = serializers.IntegerField()\n    title = serializers.CharField(max_length=255)\n```\n\n添加一个简单的序列化对象, 同时将ProductSerializer的collection成员修改为:\n\n```python\nclass ProductSerializer(serializers.Serializer):\n    # ... code...\n    collection = CollectionSerializer()\n```\n\n![result](/assets/img/img_202311112240579548.png)\n\n> 需要注意的是, 此种方式同样需要对collection进行关联查询, 否则也会出现额外的SQL查询\n{: .prompt-warning}\n\n### HyperlinkedRelatedField\n\n当不需要直接显示关联表的内容, 而是要给出查询关联表内容的链接地址时, 就需要用到链接序列化.\n\n1. 修改collection成员的类型为:\n\n    ```python\n    collection = serializers.HyperlinkedRelatedField(\n            read_only=True,\n            view_name='collection-detail'\n        )\n    ```\n\n    > 与`PrimaryKeyRelatedField`字段类似, 如果不需要对该字段进行修改, 可以直接使用`read_only=True`, 否则需要提供一个`queryset`.\n    {: .prompt-info}\n\n2. 在`store/views.py`中创建对应的视图方法:\n\n    ```python\n    @api_view()\n    def collection_detail(request, pk):\n        collection = get_object_or_404(Collection, pk=pk)\n        serializer = CollectionSerializer(collection)\n        return Response(serializer.data)\n    ```\n\n3. 在`store/urls.py`中配置对应的路由:\n\n    ```python\n    urlpatterns = [\n        #...\n        path('products/', views.product_list),\n        path('collections/<int:pk>',\n            views.collection_detail,\n            name='collection-detail')\n    ]\n    ```\n\n4. 设置`product_detail`方法的上下文参数:\n\n    ```python\n    @api_view()  # 该装饰器替换默认的request对象为djangorestframework的request对象\n    def product_list(request):\n\n        queryset = Product.objects.select_related('collection').all()\n        serializer = ProductSerializer(\n            queryset, many=True, context={\"request\": request})\n\n        # 使用djangorestframwork的Response返回数据\n        return Response(serializer.data)\n    ```\n\n> ![result](/assets/img/img_202311112310499438.png){: .right}\n> **运行结果:**\n>\n> 可以看到, 在运行结果中列出的是一个完整的url, 而起对应的便是上面配置的视图方法\n>\n> 由于collection作为Product的外联字段, 所以即便没有进行`select_relation()`关联查询, 也不会产生额外的查询SQL.\n>\n{: .prompt-info}\n\n> 需要注意的是, 在进行链接字段序列化时, 视图方法的形参名字只能是`pk`, 在其他代码不做修改, 仅修改形参名便会出现运行异常\n>\n> ```python\n> # Could not resolve URL for hyperlinked relationship using view name \"collection-detail\". \n> # You may have failed to include the related model in your API, \n> # or incorrectly configured the `lookup_field` attribute on this field.\n> ```\n>\n{: .prompt-warning}\n\n> 超链接字段的使用前提是该字段本身必须是模型中的一个关系型字段, 如果只是单纯的序列化对象中定义的字段那么不会有任何结果!\n{: .prompt-danger}\n","source":"_posts/django/rest-serializer-basics.md","raw":"---\ntitle: 11. Django Rest Framework 序列化\ndate: 2023-11-12 00:02:12 +08000\ncategories: [笔记, Django]\ntags: [python, django, backend, REST]\n---\n\nREST Framework提供了一个`JSONRenderer`对象, 可以将python的词典对象序列化为json对象.\n\n同时提供了一个`Serializer`对象, 用于将models转化为python词典.\n\n在`store`app中创建一个`serializer.py`文件\n\n```python\nfrom rest_framework import serializers\n\n\nclass ProductSerializer(serializers.Serializer):\n    id = serializers.IntegerField()\n    title = serializers.CharField(max_length=255)\n    unit_price = serializers.DecimalField(max_digits=6,decimal_places=2)\n```\n\n> 使用序列化对象, 而非直接通过模型对象获取数据, 好处在于:\n>\n> * 简化序列化代码, 并使序列化方式统一, 可以在任意位置通过相同的方式一次性完成序列化, 而不是对模型对象进行零散的维护\n> * 隐藏不需要显示的字段\n{: .prompt-tip}\n\n在完成了序列化对象的设置之后, 便可以修改视图函数的代码:\n\n```python\n@api_view()  # 该装饰器替换默认的request对象为djangorestframework的request对象\ndef product_list(request):\n\n    queryset = Product.objects.all()\n    serializer = ProductSerializer(queryset, many=True)\n\n    # 使用djangorestframwork的Response返回数据\n    return Response(serializer.data)\n\n\n@api_view()\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n    serializer = ProductSerializer(product)\n    return Response(serializer.data)\n```\n\n此时通过URL访问视图便可以得到具体的数据了\n\n![result](/assets/img/img_202311111749462365.png)\n\n> django rest framework 会自动把Decimal类型的数据转换为字符串, 如果不希望转换, 可以在`project/settings.py`文件中加入一下设置:\n>\n> ```python\n> REST_FRAMEWORK = {\n>     'COERCE_DECIMAL_TO_STRING': False\n> }\n> ```\n>\n{: .prompt-tip}\n\n## 自定义的序列化字段\n\n序列化对象的目的在于确定接口的呈现形式, 以此来与后台的数据模型解耦.\n从命名规则上来说, 数据库字段的名称与前端需要的字段名称可能不同, 通过序列化对象便可以轻松的解决这一问题.\n同时, 后台的数据模型可能会做各种类型的修改, 但是这些修改只关乎后台, 而无需让用户知道.\n通过自定义序列化字段便可以实现这一目的, 比如:\n\n* 增加模型中不存在的字段\n* 更改字段的名称\n* etc\n\n假设需要再接口中增加一个含税价格字段, 可以使用如下代码:\n\n```python\nfrom decimal import Decimal\nfrom rest_framework import serializers\nfrom store.models import Product\n\n\nclass ProductSerializer(serializers.Serializer):\n    id = serializers.IntegerField()\n    title = serializers.CharField(max_length=255)\n    price = serializers.DecimalField(max_digits=6,\n                                     decimal_places=2,\n                                     source=\"unit_price\")\n\n    price_with_tax = serializers.SerializerMethodField(\n        method_name=\"calc_price_with_tax\")\n\n    def calc_price_with_tax(self, product: Product):\n        return product.unit_price * Decimal(1.17)\n\n```\n\n## 关联查询的序列化\n\nProduct和Collection之间存在多对一的关系, 在Product中通过外键`collection`进行链接.\n那么在序列化Product时便可以将collection的数据同时序列化.\n\n### PrimaryKeyRelatedField\n\n```python\ncollection = serializers.PrimaryKeyRelatedField(\n        queryset=Collection.objects.all()\n    )\n```\n\n> 根据官方文档说明\n>\n> ```text\n> `queryset` - \n> The queryset used for model instance lookups when validating the field input. \n> Relationships must either set a queryset explicitly, or set read_only=True.\n> ```\n>\n> 该参数是用来对于输入数据进行验证的, 应该是说反序列化时进行数据库查重的范围. 所以, 如果该字段不需要修改, 仅仅是读取内容, 也可以用参数`read_only=True`替代.\n> [相关文档](https://www.django-rest-framework.org/api-guide/relations/#primarykeyrelatedfield)\n>\n{: .prompt-tip}\n\n### StringRelatedField\n\n如果希望关联查询出的不仅是id, 比如Collection的`title`, 可以写成\n\n```python\ncollection_title = serializers.StringRelatedField(source='collection')\n```\n\n> 由于`collection`成员已经被定义为了`PrimaryKeyRelatedField`, 所以使用了`collection_title`作为成员名\n> 但是`Collection`对象中并没有与该成员同名的字段, 所以必须显示的声明其`source`为`collection`.\n>\n{: .prompt-info}\n\n但此时运行程序, 会出现一个严重问题, 为了获取每个Product对应的Collection标题, 额外执行了与Product数量相同的SQL查询\n![result](/assets/img/img_202311112225443281.png)\n\n> 原因在于Product在查询时并没有同步查询Collection的其他字段, 所以在序列化的时候才会根据每一个Product重新查询其对应的collection的`title`\n{: .prompt-danger}\n\n为了解决直接以问题, 需要在视图方法中加入对`Collection`的关联查询:\n\n```python\n@api_view()\ndef product_list(request):\n    queryset = Product.objects.select_related('collection').all()\n    serializer = ProductSerializer(queryset, many=True)\n    return Response(serializer.data)\n```\n\n### Nested Serializer\n\nProduct有自己的序列化对象, Collection同样可以有自己的序列化对象.\n\n```python\nclass CollectionSerializer(serializers.Serializer):\n    id = serializers.IntegerField()\n    title = serializers.CharField(max_length=255)\n```\n\n添加一个简单的序列化对象, 同时将ProductSerializer的collection成员修改为:\n\n```python\nclass ProductSerializer(serializers.Serializer):\n    # ... code...\n    collection = CollectionSerializer()\n```\n\n![result](/assets/img/img_202311112240579548.png)\n\n> 需要注意的是, 此种方式同样需要对collection进行关联查询, 否则也会出现额外的SQL查询\n{: .prompt-warning}\n\n### HyperlinkedRelatedField\n\n当不需要直接显示关联表的内容, 而是要给出查询关联表内容的链接地址时, 就需要用到链接序列化.\n\n1. 修改collection成员的类型为:\n\n    ```python\n    collection = serializers.HyperlinkedRelatedField(\n            read_only=True,\n            view_name='collection-detail'\n        )\n    ```\n\n    > 与`PrimaryKeyRelatedField`字段类似, 如果不需要对该字段进行修改, 可以直接使用`read_only=True`, 否则需要提供一个`queryset`.\n    {: .prompt-info}\n\n2. 在`store/views.py`中创建对应的视图方法:\n\n    ```python\n    @api_view()\n    def collection_detail(request, pk):\n        collection = get_object_or_404(Collection, pk=pk)\n        serializer = CollectionSerializer(collection)\n        return Response(serializer.data)\n    ```\n\n3. 在`store/urls.py`中配置对应的路由:\n\n    ```python\n    urlpatterns = [\n        #...\n        path('products/', views.product_list),\n        path('collections/<int:pk>',\n            views.collection_detail,\n            name='collection-detail')\n    ]\n    ```\n\n4. 设置`product_detail`方法的上下文参数:\n\n    ```python\n    @api_view()  # 该装饰器替换默认的request对象为djangorestframework的request对象\n    def product_list(request):\n\n        queryset = Product.objects.select_related('collection').all()\n        serializer = ProductSerializer(\n            queryset, many=True, context={\"request\": request})\n\n        # 使用djangorestframwork的Response返回数据\n        return Response(serializer.data)\n    ```\n\n> ![result](/assets/img/img_202311112310499438.png){: .right}\n> **运行结果:**\n>\n> 可以看到, 在运行结果中列出的是一个完整的url, 而起对应的便是上面配置的视图方法\n>\n> 由于collection作为Product的外联字段, 所以即便没有进行`select_relation()`关联查询, 也不会产生额外的查询SQL.\n>\n{: .prompt-info}\n\n> 需要注意的是, 在进行链接字段序列化时, 视图方法的形参名字只能是`pk`, 在其他代码不做修改, 仅修改形参名便会出现运行异常\n>\n> ```python\n> # Could not resolve URL for hyperlinked relationship using view name \"collection-detail\". \n> # You may have failed to include the related model in your API, \n> # or incorrectly configured the `lookup_field` attribute on this field.\n> ```\n>\n{: .prompt-warning}\n\n> 超链接字段的使用前提是该字段本身必须是模型中的一个关系型字段, 如果只是单纯的序列化对象中定义的字段那么不会有任何结果!\n{: .prompt-danger}\n","slug":"django-rest-serializer-basics","published":1,"updated":"2023-12-13T08:41:08.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v4002hi3erb8kp4ya7","content":"<p>REST Framework提供了一个<code>JSONRenderer</code>对象, 可以将python的词典对象序列化为json对象.</p>\n<p>同时提供了一个<code>Serializer</code>对象, 用于将models转化为python词典.</p>\n<p>在<code>store</code>app中创建一个<code>serializer.py</code>文件</p>\n<pre><code class=\"python\">from rest_framework import serializers\n\n\nclass ProductSerializer(serializers.Serializer):\n    id = serializers.IntegerField()\n    title = serializers.CharField(max_length=255)\n    unit_price = serializers.DecimalField(max_digits=6,decimal_places=2)\n</code></pre>\n<blockquote>\n<p>使用序列化对象, 而非直接通过模型对象获取数据, 好处在于:</p>\n<ul>\n<li>简化序列化代码, 并使序列化方式统一, 可以在任意位置通过相同的方式一次性完成序列化, 而不是对模型对象进行零散的维护</li>\n<li>隐藏不需要显示的字段<br>{: .prompt-tip}</li>\n</ul>\n</blockquote>\n<p>在完成了序列化对象的设置之后, 便可以修改视图函数的代码:</p>\n<pre><code class=\"python\">@api_view()  # 该装饰器替换默认的request对象为djangorestframework的request对象\ndef product_list(request):\n\n    queryset = Product.objects.all()\n    serializer = ProductSerializer(queryset, many=True)\n\n    # 使用djangorestframwork的Response返回数据\n    return Response(serializer.data)\n\n\n@api_view()\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n    serializer = ProductSerializer(product)\n    return Response(serializer.data)\n</code></pre>\n<p>此时通过URL访问视图便可以得到具体的数据了</p>\n<p><img src=\"/assets/img/img_202311111749462365.png\" alt=\"result\"></p>\n<blockquote>\n<p>django rest framework 会自动把Decimal类型的数据转换为字符串, 如果不希望转换, 可以在<code>project/settings.py</code>文件中加入一下设置:</p>\n<pre><code class=\"python\">REST_FRAMEWORK = &#123;\n    &#39;COERCE_DECIMAL_TO_STRING&#39;: False\n&#125;\n</code></pre>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h2 id=\"自定义的序列化字段\"><a href=\"#自定义的序列化字段\" class=\"headerlink\" title=\"自定义的序列化字段\"></a>自定义的序列化字段</h2><p>序列化对象的目的在于确定接口的呈现形式, 以此来与后台的数据模型解耦.<br>从命名规则上来说, 数据库字段的名称与前端需要的字段名称可能不同, 通过序列化对象便可以轻松的解决这一问题.<br>同时, 后台的数据模型可能会做各种类型的修改, 但是这些修改只关乎后台, 而无需让用户知道.<br>通过自定义序列化字段便可以实现这一目的, 比如:</p>\n<ul>\n<li>增加模型中不存在的字段</li>\n<li>更改字段的名称</li>\n<li>etc</li>\n</ul>\n<p>假设需要再接口中增加一个含税价格字段, 可以使用如下代码:</p>\n<pre><code class=\"python\">from decimal import Decimal\nfrom rest_framework import serializers\nfrom store.models import Product\n\n\nclass ProductSerializer(serializers.Serializer):\n    id = serializers.IntegerField()\n    title = serializers.CharField(max_length=255)\n    price = serializers.DecimalField(max_digits=6,\n                                     decimal_places=2,\n                                     source=&quot;unit_price&quot;)\n\n    price_with_tax = serializers.SerializerMethodField(\n        method_name=&quot;calc_price_with_tax&quot;)\n\n    def calc_price_with_tax(self, product: Product):\n        return product.unit_price * Decimal(1.17)\n</code></pre>\n<h2 id=\"关联查询的序列化\"><a href=\"#关联查询的序列化\" class=\"headerlink\" title=\"关联查询的序列化\"></a>关联查询的序列化</h2><p>Product和Collection之间存在多对一的关系, 在Product中通过外键<code>collection</code>进行链接.<br>那么在序列化Product时便可以将collection的数据同时序列化.</p>\n<h3 id=\"PrimaryKeyRelatedField\"><a href=\"#PrimaryKeyRelatedField\" class=\"headerlink\" title=\"PrimaryKeyRelatedField\"></a>PrimaryKeyRelatedField</h3><pre><code class=\"python\">collection = serializers.PrimaryKeyRelatedField(\n        queryset=Collection.objects.all()\n    )\n</code></pre>\n<blockquote>\n<p>根据官方文档说明</p>\n<pre><code class=\"text\">`queryset` - \nThe queryset used for model instance lookups when validating the field input. \nRelationships must either set a queryset explicitly, or set read_only=True.\n</code></pre>\n<p>该参数是用来对于输入数据进行验证的, 应该是说反序列化时进行数据库查重的范围. 所以, 如果该字段不需要修改, 仅仅是读取内容, 也可以用参数<code>read_only=True</code>替代.<br><a href=\"https://www.django-rest-framework.org/api-guide/relations/#primarykeyrelatedfield\">相关文档</a></p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h3 id=\"StringRelatedField\"><a href=\"#StringRelatedField\" class=\"headerlink\" title=\"StringRelatedField\"></a>StringRelatedField</h3><p>如果希望关联查询出的不仅是id, 比如Collection的<code>title</code>, 可以写成</p>\n<pre><code class=\"python\">collection_title = serializers.StringRelatedField(source=&#39;collection&#39;)\n</code></pre>\n<blockquote>\n<p>由于<code>collection</code>成员已经被定义为了<code>PrimaryKeyRelatedField</code>, 所以使用了<code>collection_title</code>作为成员名<br>但是<code>Collection</code>对象中并没有与该成员同名的字段, 所以必须显示的声明其<code>source</code>为<code>collection</code>.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<p>但此时运行程序, 会出现一个严重问题, 为了获取每个Product对应的Collection标题, 额外执行了与Product数量相同的SQL查询<br><img src=\"/assets/img/img_202311112225443281.png\" alt=\"result\"></p>\n<blockquote>\n<p>原因在于Product在查询时并没有同步查询Collection的其他字段, 所以在序列化的时候才会根据每一个Product重新查询其对应的collection的<code>title</code><br>{: .prompt-danger}</p>\n</blockquote>\n<p>为了解决直接以问题, 需要在视图方法中加入对<code>Collection</code>的关联查询:</p>\n<pre><code class=\"python\">@api_view()\ndef product_list(request):\n    queryset = Product.objects.select_related(&#39;collection&#39;).all()\n    serializer = ProductSerializer(queryset, many=True)\n    return Response(serializer.data)\n</code></pre>\n<h3 id=\"Nested-Serializer\"><a href=\"#Nested-Serializer\" class=\"headerlink\" title=\"Nested Serializer\"></a>Nested Serializer</h3><p>Product有自己的序列化对象, Collection同样可以有自己的序列化对象.</p>\n<pre><code class=\"python\">class CollectionSerializer(serializers.Serializer):\n    id = serializers.IntegerField()\n    title = serializers.CharField(max_length=255)\n</code></pre>\n<p>添加一个简单的序列化对象, 同时将ProductSerializer的collection成员修改为:</p>\n<pre><code class=\"python\">class ProductSerializer(serializers.Serializer):\n    # ... code...\n    collection = CollectionSerializer()\n</code></pre>\n<p><img src=\"/assets/img/img_202311112240579548.png\" alt=\"result\"></p>\n<blockquote>\n<p>需要注意的是, 此种方式同样需要对collection进行关联查询, 否则也会出现额外的SQL查询<br>{: .prompt-warning}</p>\n</blockquote>\n<h3 id=\"HyperlinkedRelatedField\"><a href=\"#HyperlinkedRelatedField\" class=\"headerlink\" title=\"HyperlinkedRelatedField\"></a>HyperlinkedRelatedField</h3><p>当不需要直接显示关联表的内容, 而是要给出查询关联表内容的链接地址时, 就需要用到链接序列化.</p>\n<ol>\n<li><p>修改collection成员的类型为:</p>\n<pre><code class=\"python\">collection = serializers.HyperlinkedRelatedField(\n        read_only=True,\n        view_name=&#39;collection-detail&#39;\n    )\n</code></pre>\n<blockquote>\n<p>与<code>PrimaryKeyRelatedField</code>字段类似, 如果不需要对该字段进行修改, 可以直接使用<code>read_only=True</code>, 否则需要提供一个<code>queryset</code>.<br> {: .prompt-info}</p>\n</blockquote>\n</li>\n<li><p>在<code>store/views.py</code>中创建对应的视图方法:</p>\n<pre><code class=\"python\">@api_view()\ndef collection_detail(request, pk):\n    collection = get_object_or_404(Collection, pk=pk)\n    serializer = CollectionSerializer(collection)\n    return Response(serializer.data)\n</code></pre>\n</li>\n<li><p>在<code>store/urls.py</code>中配置对应的路由:</p>\n<pre><code class=\"python\">urlpatterns = [\n    #...\n    path(&#39;products/&#39;, views.product_list),\n    path(&#39;collections/&lt;int:pk&gt;&#39;,\n        views.collection_detail,\n        name=&#39;collection-detail&#39;)\n]\n</code></pre>\n</li>\n<li><p>设置<code>product_detail</code>方法的上下文参数:</p>\n<pre><code class=\"python\">@api_view()  # 该装饰器替换默认的request对象为djangorestframework的request对象\ndef product_list(request):\n\n    queryset = Product.objects.select_related(&#39;collection&#39;).all()\n    serializer = ProductSerializer(\n        queryset, many=True, context=&#123;&quot;request&quot;: request&#125;)\n\n    # 使用djangorestframwork的Response返回数据\n    return Response(serializer.data)\n</code></pre>\n</li>\n</ol>\n<blockquote>\n<p><img src=\"/assets/img/img_202311112310499438.png\" alt=\"result\">{: .right}<br><strong>运行结果:</strong></p>\n<p>可以看到, 在运行结果中列出的是一个完整的url, 而起对应的便是上面配置的视图方法</p>\n<p>由于collection作为Product的外联字段, 所以即便没有进行<code>select_relation()</code>关联查询, 也不会产生额外的查询SQL.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<blockquote>\n<p>需要注意的是, 在进行链接字段序列化时, 视图方法的形参名字只能是<code>pk</code>, 在其他代码不做修改, 仅修改形参名便会出现运行异常</p>\n<pre><code class=\"python\"># Could not resolve URL for hyperlinked relationship using view name &quot;collection-detail&quot;. \n# You may have failed to include the related model in your API, \n# or incorrectly configured the `lookup_field` attribute on this field.\n</code></pre>\n</blockquote>\n<p>{: .prompt-warning}</p>\n<blockquote>\n<p>超链接字段的使用前提是该字段本身必须是模型中的一个关系型字段, 如果只是单纯的序列化对象中定义的字段那么不会有任何结果!<br>{: .prompt-danger}</p>\n</blockquote>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>REST Framework提供了一个<code>JSONRenderer</code>对象, 可以将python的词典对象序列化为json对象.</p>\n<p>同时提供了一个<code>Serializer</code>对象, 用于将models转化为python词典.</p>\n<p>在<code>store</code>app中创建一个<code>serializer.py</code>文件</p>\n<pre><code class=\"python\">from rest_framework import serializers\n\n\nclass ProductSerializer(serializers.Serializer):\n    id = serializers.IntegerField()\n    title = serializers.CharField(max_length=255)\n    unit_price = serializers.DecimalField(max_digits=6,decimal_places=2)\n</code></pre>\n<blockquote>\n<p>使用序列化对象, 而非直接通过模型对象获取数据, 好处在于:</p>\n<ul>\n<li>简化序列化代码, 并使序列化方式统一, 可以在任意位置通过相同的方式一次性完成序列化, 而不是对模型对象进行零散的维护</li>\n<li>隐藏不需要显示的字段<br>{: .prompt-tip}</li>\n</ul>\n</blockquote>\n<p>在完成了序列化对象的设置之后, 便可以修改视图函数的代码:</p>\n<pre><code class=\"python\">@api_view()  # 该装饰器替换默认的request对象为djangorestframework的request对象\ndef product_list(request):\n\n    queryset = Product.objects.all()\n    serializer = ProductSerializer(queryset, many=True)\n\n    # 使用djangorestframwork的Response返回数据\n    return Response(serializer.data)\n\n\n@api_view()\ndef product_detail(request, product_id):\n    product = get_object_or_404(Product, pk=product_id)\n    serializer = ProductSerializer(product)\n    return Response(serializer.data)\n</code></pre>\n<p>此时通过URL访问视图便可以得到具体的数据了</p>\n<p><img src=\"/assets/img/img_202311111749462365.png\" alt=\"result\"></p>\n<blockquote>\n<p>django rest framework 会自动把Decimal类型的数据转换为字符串, 如果不希望转换, 可以在<code>project/settings.py</code>文件中加入一下设置:</p>\n<pre><code class=\"python\">REST_FRAMEWORK = &#123;\n    &#39;COERCE_DECIMAL_TO_STRING&#39;: False\n&#125;\n</code></pre>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h2 id=\"自定义的序列化字段\"><a href=\"#自定义的序列化字段\" class=\"headerlink\" title=\"自定义的序列化字段\"></a>自定义的序列化字段</h2><p>序列化对象的目的在于确定接口的呈现形式, 以此来与后台的数据模型解耦.<br>从命名规则上来说, 数据库字段的名称与前端需要的字段名称可能不同, 通过序列化对象便可以轻松的解决这一问题.<br>同时, 后台的数据模型可能会做各种类型的修改, 但是这些修改只关乎后台, 而无需让用户知道.<br>通过自定义序列化字段便可以实现这一目的, 比如:</p>\n<ul>\n<li>增加模型中不存在的字段</li>\n<li>更改字段的名称</li>\n<li>etc</li>\n</ul>\n<p>假设需要再接口中增加一个含税价格字段, 可以使用如下代码:</p>\n<pre><code class=\"python\">from decimal import Decimal\nfrom rest_framework import serializers\nfrom store.models import Product\n\n\nclass ProductSerializer(serializers.Serializer):\n    id = serializers.IntegerField()\n    title = serializers.CharField(max_length=255)\n    price = serializers.DecimalField(max_digits=6,\n                                     decimal_places=2,\n                                     source=&quot;unit_price&quot;)\n\n    price_with_tax = serializers.SerializerMethodField(\n        method_name=&quot;calc_price_with_tax&quot;)\n\n    def calc_price_with_tax(self, product: Product):\n        return product.unit_price * Decimal(1.17)\n</code></pre>\n<h2 id=\"关联查询的序列化\"><a href=\"#关联查询的序列化\" class=\"headerlink\" title=\"关联查询的序列化\"></a>关联查询的序列化</h2><p>Product和Collection之间存在多对一的关系, 在Product中通过外键<code>collection</code>进行链接.<br>那么在序列化Product时便可以将collection的数据同时序列化.</p>\n<h3 id=\"PrimaryKeyRelatedField\"><a href=\"#PrimaryKeyRelatedField\" class=\"headerlink\" title=\"PrimaryKeyRelatedField\"></a>PrimaryKeyRelatedField</h3><pre><code class=\"python\">collection = serializers.PrimaryKeyRelatedField(\n        queryset=Collection.objects.all()\n    )\n</code></pre>\n<blockquote>\n<p>根据官方文档说明</p>\n<pre><code class=\"text\">`queryset` - \nThe queryset used for model instance lookups when validating the field input. \nRelationships must either set a queryset explicitly, or set read_only=True.\n</code></pre>\n<p>该参数是用来对于输入数据进行验证的, 应该是说反序列化时进行数据库查重的范围. 所以, 如果该字段不需要修改, 仅仅是读取内容, 也可以用参数<code>read_only=True</code>替代.<br><a href=\"https://www.django-rest-framework.org/api-guide/relations/#primarykeyrelatedfield\">相关文档</a></p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<h3 id=\"StringRelatedField\"><a href=\"#StringRelatedField\" class=\"headerlink\" title=\"StringRelatedField\"></a>StringRelatedField</h3><p>如果希望关联查询出的不仅是id, 比如Collection的<code>title</code>, 可以写成</p>\n<pre><code class=\"python\">collection_title = serializers.StringRelatedField(source=&#39;collection&#39;)\n</code></pre>\n<blockquote>\n<p>由于<code>collection</code>成员已经被定义为了<code>PrimaryKeyRelatedField</code>, 所以使用了<code>collection_title</code>作为成员名<br>但是<code>Collection</code>对象中并没有与该成员同名的字段, 所以必须显示的声明其<code>source</code>为<code>collection</code>.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<p>但此时运行程序, 会出现一个严重问题, 为了获取每个Product对应的Collection标题, 额外执行了与Product数量相同的SQL查询<br><img src=\"/assets/img/img_202311112225443281.png\" alt=\"result\"></p>\n<blockquote>\n<p>原因在于Product在查询时并没有同步查询Collection的其他字段, 所以在序列化的时候才会根据每一个Product重新查询其对应的collection的<code>title</code><br>{: .prompt-danger}</p>\n</blockquote>\n<p>为了解决直接以问题, 需要在视图方法中加入对<code>Collection</code>的关联查询:</p>\n<pre><code class=\"python\">@api_view()\ndef product_list(request):\n    queryset = Product.objects.select_related(&#39;collection&#39;).all()\n    serializer = ProductSerializer(queryset, many=True)\n    return Response(serializer.data)\n</code></pre>\n<h3 id=\"Nested-Serializer\"><a href=\"#Nested-Serializer\" class=\"headerlink\" title=\"Nested Serializer\"></a>Nested Serializer</h3><p>Product有自己的序列化对象, Collection同样可以有自己的序列化对象.</p>\n<pre><code class=\"python\">class CollectionSerializer(serializers.Serializer):\n    id = serializers.IntegerField()\n    title = serializers.CharField(max_length=255)\n</code></pre>\n<p>添加一个简单的序列化对象, 同时将ProductSerializer的collection成员修改为:</p>\n<pre><code class=\"python\">class ProductSerializer(serializers.Serializer):\n    # ... code...\n    collection = CollectionSerializer()\n</code></pre>\n<p><img src=\"/assets/img/img_202311112240579548.png\" alt=\"result\"></p>\n<blockquote>\n<p>需要注意的是, 此种方式同样需要对collection进行关联查询, 否则也会出现额外的SQL查询<br>{: .prompt-warning}</p>\n</blockquote>\n<h3 id=\"HyperlinkedRelatedField\"><a href=\"#HyperlinkedRelatedField\" class=\"headerlink\" title=\"HyperlinkedRelatedField\"></a>HyperlinkedRelatedField</h3><p>当不需要直接显示关联表的内容, 而是要给出查询关联表内容的链接地址时, 就需要用到链接序列化.</p>\n<ol>\n<li><p>修改collection成员的类型为:</p>\n<pre><code class=\"python\">collection = serializers.HyperlinkedRelatedField(\n        read_only=True,\n        view_name=&#39;collection-detail&#39;\n    )\n</code></pre>\n<blockquote>\n<p>与<code>PrimaryKeyRelatedField</code>字段类似, 如果不需要对该字段进行修改, 可以直接使用<code>read_only=True</code>, 否则需要提供一个<code>queryset</code>.<br> {: .prompt-info}</p>\n</blockquote>\n</li>\n<li><p>在<code>store/views.py</code>中创建对应的视图方法:</p>\n<pre><code class=\"python\">@api_view()\ndef collection_detail(request, pk):\n    collection = get_object_or_404(Collection, pk=pk)\n    serializer = CollectionSerializer(collection)\n    return Response(serializer.data)\n</code></pre>\n</li>\n<li><p>在<code>store/urls.py</code>中配置对应的路由:</p>\n<pre><code class=\"python\">urlpatterns = [\n    #...\n    path(&#39;products/&#39;, views.product_list),\n    path(&#39;collections/&lt;int:pk&gt;&#39;,\n        views.collection_detail,\n        name=&#39;collection-detail&#39;)\n]\n</code></pre>\n</li>\n<li><p>设置<code>product_detail</code>方法的上下文参数:</p>\n<pre><code class=\"python\">@api_view()  # 该装饰器替换默认的request对象为djangorestframework的request对象\ndef product_list(request):\n\n    queryset = Product.objects.select_related(&#39;collection&#39;).all()\n    serializer = ProductSerializer(\n        queryset, many=True, context=&#123;&quot;request&quot;: request&#125;)\n\n    # 使用djangorestframwork的Response返回数据\n    return Response(serializer.data)\n</code></pre>\n</li>\n</ol>\n<blockquote>\n<p><img src=\"/assets/img/img_202311112310499438.png\" alt=\"result\">{: .right}<br><strong>运行结果:</strong></p>\n<p>可以看到, 在运行结果中列出的是一个完整的url, 而起对应的便是上面配置的视图方法</p>\n<p>由于collection作为Product的外联字段, 所以即便没有进行<code>select_relation()</code>关联查询, 也不会产生额外的查询SQL.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<blockquote>\n<p>需要注意的是, 在进行链接字段序列化时, 视图方法的形参名字只能是<code>pk</code>, 在其他代码不做修改, 仅修改形参名便会出现运行异常</p>\n<pre><code class=\"python\"># Could not resolve URL for hyperlinked relationship using view name &quot;collection-detail&quot;. \n# You may have failed to include the related model in your API, \n# or incorrectly configured the `lookup_field` attribute on this field.\n</code></pre>\n</blockquote>\n<p>{: .prompt-warning}</p>\n<blockquote>\n<p>超链接字段的使用前提是该字段本身必须是模型中的一个关系型字段, 如果只是单纯的序列化对象中定义的字段那么不会有任何结果!<br>{: .prompt-danger}</p>\n</blockquote>\n"},{"title":"设计模式-桥接模式","date":"2023-11-23T13:21:50.000Z","mermaid":true,"_content":"\n## 问题描述\n\n假设一个智能家居的产品, 要在手机上实现一个遥控器app可以控制所有接入的家电.\n\n大概得结构如下:\n\n```mermaid\nclassDiagram\n    direction LR\n    class RemoteControl{\n        + turnOn()\n        + turnOff()\n    }\n\n    class TVRemoteControl{\n        + setChannel(id)\n    }\n\n    class ACRemoteControl{\n        + setTempreature(value)\n    }\n\n    RemoteControl <|-- TVRemoteControl : 继承\n    RemoteControl <|-- ACRemoteControl : 继承\n```\n\n每一个具体的实现方法都应该包含几个部分:\n\n* App自身的某些逻辑, 比如用户操作日志, 行为分析, 日志处理等等.\n* 创建与设备之间的通讯.\n* 创建指令消息.\n* 向设备发送指令.\n\n可以简单的为一套加点进行完整的操作抽象.\n\n但如果需要增加新的品牌设备增加适配, 通过继承可以解决问题, 比如添加`TCLTVRemoteControl`类等.\n\n但是对于特定品牌的遥控器所需要的仅仅只是对应的通讯方式. 而继承父类则会完整获得所有的变量和方法, 使得子类变得臃肿.\n\n同时抽象部分于实现部分则通过继承关系耦合度太高, 对父类的任何修改都会影响到全部子类.\n\n也可以使用适配器模式来解决, 不过通常来说, 适配器更多的是用于让两个已经存在的东西协同工作.\n\n桥接模式则是用于将抽象层和实现层分离. 在架好桥之后两边则可以进行独立维护, 实现层也可以自由扩展.\n\n```mermaid\nclassDiagram\n    direction TD\n    class RemoteControl{\n          device:Device\n        + turnOn()\n        + turnOff()\n    }\n\n    class TVRemoteControl{\n        + setChannel(id)\n    }\n\n    class ACRemoteControl{\n        + setTempreature(value)\n    }\n\n    class Device{\n        <<interface>>\n        + turnOn()\n        + turnOff()\n    }\n\n    class DeviceTV{\n        <<interface>>\n        + setChannel(id)\n    }\n\n    class DeviceAC{\n        <<interface>>\n        + setTempreature(value)\n    }\n\n    class SonyTV{\n        + setChannel(id)\n    }\n\n    class LGTV{\n        + setChannel(id)\n    }\n\n    class HaierAirControll{\n        + setTempreature(value)\n    }\n\n    class MediaAirControll{\n        + setTempreature(value)\n    }\n\n    RemoteControl *--> Device : 桥接\n    RemoteControl <|-- TVRemoteControl : 继承\n    RemoteControl <|-- ACRemoteControl : 继承\n\n    Device <|-- DeviceTV\n    Device <|-- DeviceAC\n\n    DeviceTV <|-- SonyTV\n    DeviceTV <|-- LGTV\n    DeviceAC <|-- HaierAirControll\n    DeviceAC <|-- MediaAirControll\n```\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass Device(ABC):\n\n    @abstractmethod\n    def turn_on(self):\n        pass\n\n    @abstractmethod\n    def turn_off(self):\n        pass\n\n\nclass Television(Device):\n\n    @abstractmethod\n    def set_channel(self, channel):\n        pass\n\n\nclass AirController(Device):\n\n    @abstractmethod\n    def set_temperature(self, temperature):\n        pass\n\n\nclass SonyTV(Television):\n\n    def turn_on(self):\n        print(\"Turn on Sony TV.\")\n\n    def turn_off(self):\n        print(\"Turn off Sony TV.\")\n\n    def set_channel(self, channel):\n        print(f\"Set Sony TV to channel:{channel}\")\n\n\nclass MediaAirController(AirController):\n\n    def turn_on(self):\n        print(\"Turn on Media Air Controller.\")\n\n    def turn_off(self):\n        print(\"Turn off Media Air Controller.\")\n\n    def set_temperature(self, temperature):\n        print(f\"Set Media Air Controller to: {temperature}°C.\")\n\n\nclass RemoteController:\n\n    def __init__(self, device: Device):\n        self._device = device\n\n    def turn_on(self):\n        print(\"Use Remote Controller to turn on device.\")\n        self._device.turn_on()\n\n    def turn_off(self):\n        print(\"Use Remote Controller to turn off device.\")\n        self._device.turn_off()\n\n\nclass TVRemoteController(RemoteController):\n\n    def __init__(self, device: Television):\n        super().__init__(device)\n\n    def set_channel(self, channel):\n        print(f\"Set TV to channel: {channel}\")\n        if isinstance(self._device, Television):\n            self._device.set_channel(channel)\n\n\nclass ACRemoteController(RemoteController):\n\n    def __init__(self, device: AirController):\n        super().__init__(device)\n\n    def set_temperature(self, temperature):\n        print(f\"set AC to temperature: {temperature}°C\")\n        if isinstance(self._device, AirController):\n            self._device.set_temperature(temperature)\n\n\nif __name__ == \"__main__\":\n\n    ac = ACRemoteController(MediaAirController())\n    tv = TVRemoteController(SonyTV())\n\n    tv.turn_on()\n    tv.set_channel(5)\n    tv.turn_off()\n\n    ac.turn_on()\n    ac.set_temperature(26)\n    ac.turn_off()\n```\n\n最终输出结果:\n\n```bash\nUse Remote Controller to turn on device.\nTurn on Sony TV.\nSet TV to channel: 5\nSet Sony TV to channel:5\nUse Remote Controller to turn off device.\nTurn off Sony TV.\nUse Remote Controller to turn on device.\nTurn on Media Air Controller.\nset AC to temperature: 26°C\nSet Media Air Controller to: 26°C.\nUse Remote Controller to turn off device.\nTurn off Media Air Controller.\n```\n","source":"_posts/design-pattern/bridge-design-pattern-demo.md","raw":"---\ntitle: 设计模式-桥接模式\ndate: 2023-11-23 21:21:50 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n## 问题描述\n\n假设一个智能家居的产品, 要在手机上实现一个遥控器app可以控制所有接入的家电.\n\n大概得结构如下:\n\n```mermaid\nclassDiagram\n    direction LR\n    class RemoteControl{\n        + turnOn()\n        + turnOff()\n    }\n\n    class TVRemoteControl{\n        + setChannel(id)\n    }\n\n    class ACRemoteControl{\n        + setTempreature(value)\n    }\n\n    RemoteControl <|-- TVRemoteControl : 继承\n    RemoteControl <|-- ACRemoteControl : 继承\n```\n\n每一个具体的实现方法都应该包含几个部分:\n\n* App自身的某些逻辑, 比如用户操作日志, 行为分析, 日志处理等等.\n* 创建与设备之间的通讯.\n* 创建指令消息.\n* 向设备发送指令.\n\n可以简单的为一套加点进行完整的操作抽象.\n\n但如果需要增加新的品牌设备增加适配, 通过继承可以解决问题, 比如添加`TCLTVRemoteControl`类等.\n\n但是对于特定品牌的遥控器所需要的仅仅只是对应的通讯方式. 而继承父类则会完整获得所有的变量和方法, 使得子类变得臃肿.\n\n同时抽象部分于实现部分则通过继承关系耦合度太高, 对父类的任何修改都会影响到全部子类.\n\n也可以使用适配器模式来解决, 不过通常来说, 适配器更多的是用于让两个已经存在的东西协同工作.\n\n桥接模式则是用于将抽象层和实现层分离. 在架好桥之后两边则可以进行独立维护, 实现层也可以自由扩展.\n\n```mermaid\nclassDiagram\n    direction TD\n    class RemoteControl{\n          device:Device\n        + turnOn()\n        + turnOff()\n    }\n\n    class TVRemoteControl{\n        + setChannel(id)\n    }\n\n    class ACRemoteControl{\n        + setTempreature(value)\n    }\n\n    class Device{\n        <<interface>>\n        + turnOn()\n        + turnOff()\n    }\n\n    class DeviceTV{\n        <<interface>>\n        + setChannel(id)\n    }\n\n    class DeviceAC{\n        <<interface>>\n        + setTempreature(value)\n    }\n\n    class SonyTV{\n        + setChannel(id)\n    }\n\n    class LGTV{\n        + setChannel(id)\n    }\n\n    class HaierAirControll{\n        + setTempreature(value)\n    }\n\n    class MediaAirControll{\n        + setTempreature(value)\n    }\n\n    RemoteControl *--> Device : 桥接\n    RemoteControl <|-- TVRemoteControl : 继承\n    RemoteControl <|-- ACRemoteControl : 继承\n\n    Device <|-- DeviceTV\n    Device <|-- DeviceAC\n\n    DeviceTV <|-- SonyTV\n    DeviceTV <|-- LGTV\n    DeviceAC <|-- HaierAirControll\n    DeviceAC <|-- MediaAirControll\n```\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass Device(ABC):\n\n    @abstractmethod\n    def turn_on(self):\n        pass\n\n    @abstractmethod\n    def turn_off(self):\n        pass\n\n\nclass Television(Device):\n\n    @abstractmethod\n    def set_channel(self, channel):\n        pass\n\n\nclass AirController(Device):\n\n    @abstractmethod\n    def set_temperature(self, temperature):\n        pass\n\n\nclass SonyTV(Television):\n\n    def turn_on(self):\n        print(\"Turn on Sony TV.\")\n\n    def turn_off(self):\n        print(\"Turn off Sony TV.\")\n\n    def set_channel(self, channel):\n        print(f\"Set Sony TV to channel:{channel}\")\n\n\nclass MediaAirController(AirController):\n\n    def turn_on(self):\n        print(\"Turn on Media Air Controller.\")\n\n    def turn_off(self):\n        print(\"Turn off Media Air Controller.\")\n\n    def set_temperature(self, temperature):\n        print(f\"Set Media Air Controller to: {temperature}°C.\")\n\n\nclass RemoteController:\n\n    def __init__(self, device: Device):\n        self._device = device\n\n    def turn_on(self):\n        print(\"Use Remote Controller to turn on device.\")\n        self._device.turn_on()\n\n    def turn_off(self):\n        print(\"Use Remote Controller to turn off device.\")\n        self._device.turn_off()\n\n\nclass TVRemoteController(RemoteController):\n\n    def __init__(self, device: Television):\n        super().__init__(device)\n\n    def set_channel(self, channel):\n        print(f\"Set TV to channel: {channel}\")\n        if isinstance(self._device, Television):\n            self._device.set_channel(channel)\n\n\nclass ACRemoteController(RemoteController):\n\n    def __init__(self, device: AirController):\n        super().__init__(device)\n\n    def set_temperature(self, temperature):\n        print(f\"set AC to temperature: {temperature}°C\")\n        if isinstance(self._device, AirController):\n            self._device.set_temperature(temperature)\n\n\nif __name__ == \"__main__\":\n\n    ac = ACRemoteController(MediaAirController())\n    tv = TVRemoteController(SonyTV())\n\n    tv.turn_on()\n    tv.set_channel(5)\n    tv.turn_off()\n\n    ac.turn_on()\n    ac.set_temperature(26)\n    ac.turn_off()\n```\n\n最终输出结果:\n\n```bash\nUse Remote Controller to turn on device.\nTurn on Sony TV.\nSet TV to channel: 5\nSet Sony TV to channel:5\nUse Remote Controller to turn off device.\nTurn off Sony TV.\nUse Remote Controller to turn on device.\nTurn on Media Air Controller.\nset AC to temperature: 26°C\nSet Media Air Controller to: 26°C.\nUse Remote Controller to turn off device.\nTurn off Media Air Controller.\n```\n","slug":"design-pattern-bridge-design-pattern-demo","published":1,"updated":"2023-12-13T08:43:58.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v5002ji3erb628hybv","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>假设一个智能家居的产品, 要在手机上实现一个遥控器app可以控制所有接入的家电.</p>\n<p>大概得结构如下:</p>\n<pre><code class=\"mermaid\">classDiagram\n    direction LR\n    class RemoteControl&#123;\n        + turnOn()\n        + turnOff()\n    &#125;\n\n    class TVRemoteControl&#123;\n        + setChannel(id)\n    &#125;\n\n    class ACRemoteControl&#123;\n        + setTempreature(value)\n    &#125;\n\n    RemoteControl &lt;|-- TVRemoteControl : 继承\n    RemoteControl &lt;|-- ACRemoteControl : 继承\n</code></pre>\n<p>每一个具体的实现方法都应该包含几个部分:</p>\n<ul>\n<li>App自身的某些逻辑, 比如用户操作日志, 行为分析, 日志处理等等.</li>\n<li>创建与设备之间的通讯.</li>\n<li>创建指令消息.</li>\n<li>向设备发送指令.</li>\n</ul>\n<p>可以简单的为一套加点进行完整的操作抽象.</p>\n<p>但如果需要增加新的品牌设备增加适配, 通过继承可以解决问题, 比如添加<code>TCLTVRemoteControl</code>类等.</p>\n<p>但是对于特定品牌的遥控器所需要的仅仅只是对应的通讯方式. 而继承父类则会完整获得所有的变量和方法, 使得子类变得臃肿.</p>\n<p>同时抽象部分于实现部分则通过继承关系耦合度太高, 对父类的任何修改都会影响到全部子类.</p>\n<p>也可以使用适配器模式来解决, 不过通常来说, 适配器更多的是用于让两个已经存在的东西协同工作.</p>\n<p>桥接模式则是用于将抽象层和实现层分离. 在架好桥之后两边则可以进行独立维护, 实现层也可以自由扩展.</p>\n<pre><code class=\"mermaid\">classDiagram\n    direction TD\n    class RemoteControl&#123;\n          device:Device\n        + turnOn()\n        + turnOff()\n    &#125;\n\n    class TVRemoteControl&#123;\n        + setChannel(id)\n    &#125;\n\n    class ACRemoteControl&#123;\n        + setTempreature(value)\n    &#125;\n\n    class Device&#123;\n        &lt;&lt;interface&gt;&gt;\n        + turnOn()\n        + turnOff()\n    &#125;\n\n    class DeviceTV&#123;\n        &lt;&lt;interface&gt;&gt;\n        + setChannel(id)\n    &#125;\n\n    class DeviceAC&#123;\n        &lt;&lt;interface&gt;&gt;\n        + setTempreature(value)\n    &#125;\n\n    class SonyTV&#123;\n        + setChannel(id)\n    &#125;\n\n    class LGTV&#123;\n        + setChannel(id)\n    &#125;\n\n    class HaierAirControll&#123;\n        + setTempreature(value)\n    &#125;\n\n    class MediaAirControll&#123;\n        + setTempreature(value)\n    &#125;\n\n    RemoteControl *--&gt; Device : 桥接\n    RemoteControl &lt;|-- TVRemoteControl : 继承\n    RemoteControl &lt;|-- ACRemoteControl : 继承\n\n    Device &lt;|-- DeviceTV\n    Device &lt;|-- DeviceAC\n\n    DeviceTV &lt;|-- SonyTV\n    DeviceTV &lt;|-- LGTV\n    DeviceAC &lt;|-- HaierAirControll\n    DeviceAC &lt;|-- MediaAirControll\n</code></pre>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\n\n\nclass Device(ABC):\n\n    @abstractmethod\n    def turn_on(self):\n        pass\n\n    @abstractmethod\n    def turn_off(self):\n        pass\n\n\nclass Television(Device):\n\n    @abstractmethod\n    def set_channel(self, channel):\n        pass\n\n\nclass AirController(Device):\n\n    @abstractmethod\n    def set_temperature(self, temperature):\n        pass\n\n\nclass SonyTV(Television):\n\n    def turn_on(self):\n        print(&quot;Turn on Sony TV.&quot;)\n\n    def turn_off(self):\n        print(&quot;Turn off Sony TV.&quot;)\n\n    def set_channel(self, channel):\n        print(f&quot;Set Sony TV to channel:&#123;channel&#125;&quot;)\n\n\nclass MediaAirController(AirController):\n\n    def turn_on(self):\n        print(&quot;Turn on Media Air Controller.&quot;)\n\n    def turn_off(self):\n        print(&quot;Turn off Media Air Controller.&quot;)\n\n    def set_temperature(self, temperature):\n        print(f&quot;Set Media Air Controller to: &#123;temperature&#125;°C.&quot;)\n\n\nclass RemoteController:\n\n    def __init__(self, device: Device):\n        self._device = device\n\n    def turn_on(self):\n        print(&quot;Use Remote Controller to turn on device.&quot;)\n        self._device.turn_on()\n\n    def turn_off(self):\n        print(&quot;Use Remote Controller to turn off device.&quot;)\n        self._device.turn_off()\n\n\nclass TVRemoteController(RemoteController):\n\n    def __init__(self, device: Television):\n        super().__init__(device)\n\n    def set_channel(self, channel):\n        print(f&quot;Set TV to channel: &#123;channel&#125;&quot;)\n        if isinstance(self._device, Television):\n            self._device.set_channel(channel)\n\n\nclass ACRemoteController(RemoteController):\n\n    def __init__(self, device: AirController):\n        super().__init__(device)\n\n    def set_temperature(self, temperature):\n        print(f&quot;set AC to temperature: &#123;temperature&#125;°C&quot;)\n        if isinstance(self._device, AirController):\n            self._device.set_temperature(temperature)\n\n\nif __name__ == &quot;__main__&quot;:\n\n    ac = ACRemoteController(MediaAirController())\n    tv = TVRemoteController(SonyTV())\n\n    tv.turn_on()\n    tv.set_channel(5)\n    tv.turn_off()\n\n    ac.turn_on()\n    ac.set_temperature(26)\n    ac.turn_off()\n</code></pre>\n<p>最终输出结果:</p>\n<pre><code class=\"bash\">Use Remote Controller to turn on device.\nTurn on Sony TV.\nSet TV to channel: 5\nSet Sony TV to channel:5\nUse Remote Controller to turn off device.\nTurn off Sony TV.\nUse Remote Controller to turn on device.\nTurn on Media Air Controller.\nset AC to temperature: 26°C\nSet Media Air Controller to: 26°C.\nUse Remote Controller to turn off device.\nTurn off Media Air Controller.\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>假设一个智能家居的产品, 要在手机上实现一个遥控器app可以控制所有接入的家电.</p>\n<p>大概得结构如下:</p>\n<pre><code class=\"mermaid\">classDiagram\n    direction LR\n    class RemoteControl&#123;\n        + turnOn()\n        + turnOff()\n    &#125;\n\n    class TVRemoteControl&#123;\n        + setChannel(id)\n    &#125;\n\n    class ACRemoteControl&#123;\n        + setTempreature(value)\n    &#125;\n\n    RemoteControl &lt;|-- TVRemoteControl : 继承\n    RemoteControl &lt;|-- ACRemoteControl : 继承\n</code></pre>\n<p>每一个具体的实现方法都应该包含几个部分:</p>\n<ul>\n<li>App自身的某些逻辑, 比如用户操作日志, 行为分析, 日志处理等等.</li>\n<li>创建与设备之间的通讯.</li>\n<li>创建指令消息.</li>\n<li>向设备发送指令.</li>\n</ul>\n<p>可以简单的为一套加点进行完整的操作抽象.</p>\n<p>但如果需要增加新的品牌设备增加适配, 通过继承可以解决问题, 比如添加<code>TCLTVRemoteControl</code>类等.</p>\n<p>但是对于特定品牌的遥控器所需要的仅仅只是对应的通讯方式. 而继承父类则会完整获得所有的变量和方法, 使得子类变得臃肿.</p>\n<p>同时抽象部分于实现部分则通过继承关系耦合度太高, 对父类的任何修改都会影响到全部子类.</p>\n<p>也可以使用适配器模式来解决, 不过通常来说, 适配器更多的是用于让两个已经存在的东西协同工作.</p>\n<p>桥接模式则是用于将抽象层和实现层分离. 在架好桥之后两边则可以进行独立维护, 实现层也可以自由扩展.</p>\n<pre><code class=\"mermaid\">classDiagram\n    direction TD\n    class RemoteControl&#123;\n          device:Device\n        + turnOn()\n        + turnOff()\n    &#125;\n\n    class TVRemoteControl&#123;\n        + setChannel(id)\n    &#125;\n\n    class ACRemoteControl&#123;\n        + setTempreature(value)\n    &#125;\n\n    class Device&#123;\n        &lt;&lt;interface&gt;&gt;\n        + turnOn()\n        + turnOff()\n    &#125;\n\n    class DeviceTV&#123;\n        &lt;&lt;interface&gt;&gt;\n        + setChannel(id)\n    &#125;\n\n    class DeviceAC&#123;\n        &lt;&lt;interface&gt;&gt;\n        + setTempreature(value)\n    &#125;\n\n    class SonyTV&#123;\n        + setChannel(id)\n    &#125;\n\n    class LGTV&#123;\n        + setChannel(id)\n    &#125;\n\n    class HaierAirControll&#123;\n        + setTempreature(value)\n    &#125;\n\n    class MediaAirControll&#123;\n        + setTempreature(value)\n    &#125;\n\n    RemoteControl *--&gt; Device : 桥接\n    RemoteControl &lt;|-- TVRemoteControl : 继承\n    RemoteControl &lt;|-- ACRemoteControl : 继承\n\n    Device &lt;|-- DeviceTV\n    Device &lt;|-- DeviceAC\n\n    DeviceTV &lt;|-- SonyTV\n    DeviceTV &lt;|-- LGTV\n    DeviceAC &lt;|-- HaierAirControll\n    DeviceAC &lt;|-- MediaAirControll\n</code></pre>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\n\n\nclass Device(ABC):\n\n    @abstractmethod\n    def turn_on(self):\n        pass\n\n    @abstractmethod\n    def turn_off(self):\n        pass\n\n\nclass Television(Device):\n\n    @abstractmethod\n    def set_channel(self, channel):\n        pass\n\n\nclass AirController(Device):\n\n    @abstractmethod\n    def set_temperature(self, temperature):\n        pass\n\n\nclass SonyTV(Television):\n\n    def turn_on(self):\n        print(&quot;Turn on Sony TV.&quot;)\n\n    def turn_off(self):\n        print(&quot;Turn off Sony TV.&quot;)\n\n    def set_channel(self, channel):\n        print(f&quot;Set Sony TV to channel:&#123;channel&#125;&quot;)\n\n\nclass MediaAirController(AirController):\n\n    def turn_on(self):\n        print(&quot;Turn on Media Air Controller.&quot;)\n\n    def turn_off(self):\n        print(&quot;Turn off Media Air Controller.&quot;)\n\n    def set_temperature(self, temperature):\n        print(f&quot;Set Media Air Controller to: &#123;temperature&#125;°C.&quot;)\n\n\nclass RemoteController:\n\n    def __init__(self, device: Device):\n        self._device = device\n\n    def turn_on(self):\n        print(&quot;Use Remote Controller to turn on device.&quot;)\n        self._device.turn_on()\n\n    def turn_off(self):\n        print(&quot;Use Remote Controller to turn off device.&quot;)\n        self._device.turn_off()\n\n\nclass TVRemoteController(RemoteController):\n\n    def __init__(self, device: Television):\n        super().__init__(device)\n\n    def set_channel(self, channel):\n        print(f&quot;Set TV to channel: &#123;channel&#125;&quot;)\n        if isinstance(self._device, Television):\n            self._device.set_channel(channel)\n\n\nclass ACRemoteController(RemoteController):\n\n    def __init__(self, device: AirController):\n        super().__init__(device)\n\n    def set_temperature(self, temperature):\n        print(f&quot;set AC to temperature: &#123;temperature&#125;°C&quot;)\n        if isinstance(self._device, AirController):\n            self._device.set_temperature(temperature)\n\n\nif __name__ == &quot;__main__&quot;:\n\n    ac = ACRemoteController(MediaAirController())\n    tv = TVRemoteController(SonyTV())\n\n    tv.turn_on()\n    tv.set_channel(5)\n    tv.turn_off()\n\n    ac.turn_on()\n    ac.set_temperature(26)\n    ac.turn_off()\n</code></pre>\n<p>最终输出结果:</p>\n<pre><code class=\"bash\">Use Remote Controller to turn on device.\nTurn on Sony TV.\nSet TV to channel: 5\nSet Sony TV to channel:5\nUse Remote Controller to turn off device.\nTurn off Sony TV.\nUse Remote Controller to turn on device.\nTurn on Media Air Controller.\nset AC to temperature: 26°C\nSet Media Air Controller to: 26°C.\nUse Remote Controller to turn off device.\nTurn off Media Air Controller.\n</code></pre>\n"},{"title":"设计模式-抽象工厂模式","date":"2023-11-25T02:05:52.000Z","mermaid":true,"_content":"\n## 应用场景\n\n> Provide an interface for creating families of related objects.\n>\n{: .prompt-info}\n\n抽象工厂和工厂方法基本没有什么关系.\n\n工厂方法的作用是返回一个接口的实现对象, 子类可以自由决定具体使用什么对象.\n\n而抽象工厂则是一个返回相关对象的接口. 比如一套UI主题系统, 每套主题都包含自己的Button, Listbox, Textbox等UI样式. 不会有人希望在Light皮肤中得到一个Dark按钮.\n\n抽象工厂就是为了解决这一问题.\n\n```mermaid\nclassDiagram\n    class Component{\n        <<interface>>\n        + render(Theme)\n    }\n    class Button{\n        <<interface>>\n        + render(Theme)\n        + click()\n    }\n\n    class Textbox{\n        <<interface>>\n        + render(Theme)\n        + textchange()\n    }\n\n    class Theme{\n        <<interface>>\n        + getButtonStyle()\n        + getTextboxStyle()\n    }\n\n    class DarkTheme{\n        + getButtonStyle()\n        + getTextboxStyle()\n    }\n\n    class LightTheme{\n        + getButtonStyle()\n        + getTextboxStyle()\n    }\n\n    class Page{\n        + button\n        + textbox\n        + theme\n    }\n\n    Component <|-- Button\n    Component <|-- Textbox\n    Component *--> Theme\n\n    Theme <|-- DarkTheme\n    Theme <|-- LightTheme\n\n    Page *--> Component\n    Page *--> Theme\n```\n\n在这个结构中, Page包含的按钮和文本框便是通过Theme的实现类获得统一的样式.\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass Theme(ABC):\n\n    @abstractmethod\n    def button_style(self):\n        pass\n\n    @abstractmethod\n    def textbox_style(self):\n        pass\n\n\nclass Component(ABC):\n\n    @abstractmethod\n    def render(self, theme: Theme = None):\n        pass\n\n\nclass Button(Component):\n\n    def render(self, theme: Theme = None):\n        print(f'Render button use style: {theme.button_style()}')\n\n\nclass Textbox(Component):\n\n    def render(self, theme: Theme = None):\n        print(f'Render textbox use style: {theme.textbox_style()}')\n\n\nclass DarkTheme(Theme):\n\n    def button_style(self):\n        return 'dark button'\n\n    def textbox_style(self):\n        return 'dark textbox'\n\n\nclass LightTheme(Theme):\n\n    def button_style(self):\n        return 'light button'\n\n    def textbox_style(self):\n        return 'light textbox'\n\n\nif __name__ == \"__main__\":\n\n    t = DarkTheme()\n    btn = Button()\n    textbox = Textbox()\n    btn.render(t)\n    textbox.render(t)\n```\n","source":"_posts/design-pattern/abstract-factory-design-pattern.md","raw":"---\ntitle: 设计模式-抽象工厂模式\ndate: 2023-11-25 10:05:52 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n## 应用场景\n\n> Provide an interface for creating families of related objects.\n>\n{: .prompt-info}\n\n抽象工厂和工厂方法基本没有什么关系.\n\n工厂方法的作用是返回一个接口的实现对象, 子类可以自由决定具体使用什么对象.\n\n而抽象工厂则是一个返回相关对象的接口. 比如一套UI主题系统, 每套主题都包含自己的Button, Listbox, Textbox等UI样式. 不会有人希望在Light皮肤中得到一个Dark按钮.\n\n抽象工厂就是为了解决这一问题.\n\n```mermaid\nclassDiagram\n    class Component{\n        <<interface>>\n        + render(Theme)\n    }\n    class Button{\n        <<interface>>\n        + render(Theme)\n        + click()\n    }\n\n    class Textbox{\n        <<interface>>\n        + render(Theme)\n        + textchange()\n    }\n\n    class Theme{\n        <<interface>>\n        + getButtonStyle()\n        + getTextboxStyle()\n    }\n\n    class DarkTheme{\n        + getButtonStyle()\n        + getTextboxStyle()\n    }\n\n    class LightTheme{\n        + getButtonStyle()\n        + getTextboxStyle()\n    }\n\n    class Page{\n        + button\n        + textbox\n        + theme\n    }\n\n    Component <|-- Button\n    Component <|-- Textbox\n    Component *--> Theme\n\n    Theme <|-- DarkTheme\n    Theme <|-- LightTheme\n\n    Page *--> Component\n    Page *--> Theme\n```\n\n在这个结构中, Page包含的按钮和文本框便是通过Theme的实现类获得统一的样式.\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass Theme(ABC):\n\n    @abstractmethod\n    def button_style(self):\n        pass\n\n    @abstractmethod\n    def textbox_style(self):\n        pass\n\n\nclass Component(ABC):\n\n    @abstractmethod\n    def render(self, theme: Theme = None):\n        pass\n\n\nclass Button(Component):\n\n    def render(self, theme: Theme = None):\n        print(f'Render button use style: {theme.button_style()}')\n\n\nclass Textbox(Component):\n\n    def render(self, theme: Theme = None):\n        print(f'Render textbox use style: {theme.textbox_style()}')\n\n\nclass DarkTheme(Theme):\n\n    def button_style(self):\n        return 'dark button'\n\n    def textbox_style(self):\n        return 'dark textbox'\n\n\nclass LightTheme(Theme):\n\n    def button_style(self):\n        return 'light button'\n\n    def textbox_style(self):\n        return 'light textbox'\n\n\nif __name__ == \"__main__\":\n\n    t = DarkTheme()\n    btn = Button()\n    textbox = Textbox()\n    btn.render(t)\n    textbox.render(t)\n```\n","slug":"design-pattern-abstract-factory-design-pattern","published":1,"updated":"2023-12-13T08:43:58.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v5002ni3erb3le22d5","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><blockquote>\n<p>Provide an interface for creating families of related objects.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<p>抽象工厂和工厂方法基本没有什么关系.</p>\n<p>工厂方法的作用是返回一个接口的实现对象, 子类可以自由决定具体使用什么对象.</p>\n<p>而抽象工厂则是一个返回相关对象的接口. 比如一套UI主题系统, 每套主题都包含自己的Button, Listbox, Textbox等UI样式. 不会有人希望在Light皮肤中得到一个Dark按钮.</p>\n<p>抽象工厂就是为了解决这一问题.</p>\n<pre><code class=\"mermaid\">classDiagram\n    class Component&#123;\n        &lt;&lt;interface&gt;&gt;\n        + render(Theme)\n    &#125;\n    class Button&#123;\n        &lt;&lt;interface&gt;&gt;\n        + render(Theme)\n        + click()\n    &#125;\n\n    class Textbox&#123;\n        &lt;&lt;interface&gt;&gt;\n        + render(Theme)\n        + textchange()\n    &#125;\n\n    class Theme&#123;\n        &lt;&lt;interface&gt;&gt;\n        + getButtonStyle()\n        + getTextboxStyle()\n    &#125;\n\n    class DarkTheme&#123;\n        + getButtonStyle()\n        + getTextboxStyle()\n    &#125;\n\n    class LightTheme&#123;\n        + getButtonStyle()\n        + getTextboxStyle()\n    &#125;\n\n    class Page&#123;\n        + button\n        + textbox\n        + theme\n    &#125;\n\n    Component &lt;|-- Button\n    Component &lt;|-- Textbox\n    Component *--&gt; Theme\n\n    Theme &lt;|-- DarkTheme\n    Theme &lt;|-- LightTheme\n\n    Page *--&gt; Component\n    Page *--&gt; Theme\n</code></pre>\n<p>在这个结构中, Page包含的按钮和文本框便是通过Theme的实现类获得统一的样式.</p>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\n\n\nclass Theme(ABC):\n\n    @abstractmethod\n    def button_style(self):\n        pass\n\n    @abstractmethod\n    def textbox_style(self):\n        pass\n\n\nclass Component(ABC):\n\n    @abstractmethod\n    def render(self, theme: Theme = None):\n        pass\n\n\nclass Button(Component):\n\n    def render(self, theme: Theme = None):\n        print(f&#39;Render button use style: &#123;theme.button_style()&#125;&#39;)\n\n\nclass Textbox(Component):\n\n    def render(self, theme: Theme = None):\n        print(f&#39;Render textbox use style: &#123;theme.textbox_style()&#125;&#39;)\n\n\nclass DarkTheme(Theme):\n\n    def button_style(self):\n        return &#39;dark button&#39;\n\n    def textbox_style(self):\n        return &#39;dark textbox&#39;\n\n\nclass LightTheme(Theme):\n\n    def button_style(self):\n        return &#39;light button&#39;\n\n    def textbox_style(self):\n        return &#39;light textbox&#39;\n\n\nif __name__ == &quot;__main__&quot;:\n\n    t = DarkTheme()\n    btn = Button()\n    textbox = Textbox()\n    btn.render(t)\n    textbox.render(t)\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><blockquote>\n<p>Provide an interface for creating families of related objects.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<p>抽象工厂和工厂方法基本没有什么关系.</p>\n<p>工厂方法的作用是返回一个接口的实现对象, 子类可以自由决定具体使用什么对象.</p>\n<p>而抽象工厂则是一个返回相关对象的接口. 比如一套UI主题系统, 每套主题都包含自己的Button, Listbox, Textbox等UI样式. 不会有人希望在Light皮肤中得到一个Dark按钮.</p>\n<p>抽象工厂就是为了解决这一问题.</p>\n<pre><code class=\"mermaid\">classDiagram\n    class Component&#123;\n        &lt;&lt;interface&gt;&gt;\n        + render(Theme)\n    &#125;\n    class Button&#123;\n        &lt;&lt;interface&gt;&gt;\n        + render(Theme)\n        + click()\n    &#125;\n\n    class Textbox&#123;\n        &lt;&lt;interface&gt;&gt;\n        + render(Theme)\n        + textchange()\n    &#125;\n\n    class Theme&#123;\n        &lt;&lt;interface&gt;&gt;\n        + getButtonStyle()\n        + getTextboxStyle()\n    &#125;\n\n    class DarkTheme&#123;\n        + getButtonStyle()\n        + getTextboxStyle()\n    &#125;\n\n    class LightTheme&#123;\n        + getButtonStyle()\n        + getTextboxStyle()\n    &#125;\n\n    class Page&#123;\n        + button\n        + textbox\n        + theme\n    &#125;\n\n    Component &lt;|-- Button\n    Component &lt;|-- Textbox\n    Component *--&gt; Theme\n\n    Theme &lt;|-- DarkTheme\n    Theme &lt;|-- LightTheme\n\n    Page *--&gt; Component\n    Page *--&gt; Theme\n</code></pre>\n<p>在这个结构中, Page包含的按钮和文本框便是通过Theme的实现类获得统一的样式.</p>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\n\n\nclass Theme(ABC):\n\n    @abstractmethod\n    def button_style(self):\n        pass\n\n    @abstractmethod\n    def textbox_style(self):\n        pass\n\n\nclass Component(ABC):\n\n    @abstractmethod\n    def render(self, theme: Theme = None):\n        pass\n\n\nclass Button(Component):\n\n    def render(self, theme: Theme = None):\n        print(f&#39;Render button use style: &#123;theme.button_style()&#125;&#39;)\n\n\nclass Textbox(Component):\n\n    def render(self, theme: Theme = None):\n        print(f&#39;Render textbox use style: &#123;theme.textbox_style()&#125;&#39;)\n\n\nclass DarkTheme(Theme):\n\n    def button_style(self):\n        return &#39;dark button&#39;\n\n    def textbox_style(self):\n        return &#39;dark textbox&#39;\n\n\nclass LightTheme(Theme):\n\n    def button_style(self):\n        return &#39;light button&#39;\n\n    def textbox_style(self):\n        return &#39;light textbox&#39;\n\n\nif __name__ == &quot;__main__&quot;:\n\n    t = DarkTheme()\n    btn = Button()\n    textbox = Textbox()\n    btn.render(t)\n    textbox.render(t)\n</code></pre>\n"},{"title":"设计模式-适配器模式","date":"2023-11-22T01:07:55.000Z","mermaid":true,"_content":"\n## 应用场景\n\n适配器模式属于比较常见且比较容易理解的设计模式.\n\n老话说的好, 0.5的铅芯是不能用在0.7的自动笔里的.\n\n当在项目里为了实现某些功能并应用某种设计模式, 或其他什么原因需要设计一些接口, 而这些接口的实现类要做的具体业务需要依赖于某个外部项目.\n\n比如需要再自己的项目中加入图片处理的一些功能. 需要用到开源的图像处理库.\n再比如在处理数据库ORM的时候针对不同的数据库需要有不同的实现.\n\n这时候就可以应用适配器模式.\n\n```mermaid\nclassDiagram\n    note for ImageHandler \"addFilter(filter)<br/>  filter.apply(this.image)\"\n    class ImageHandler{\n        addFilter(filter)\n    }\n\n    class ImageFilters{\n        <<interface>>\n        apply(Image)\n    }\n\n    note for BlurFilter \"apply(Image)<br/> Pillow.filter(image)\"\n    class BlurFilter{\n        apply(Image)\n    }\n\n    class Pillow{\n        filter()\n    }\n\n    ImageHandler *--> ImageFilters\n    BlurFilter --|> ImageFilters : 实现\n    BlurFilter *--> Pillow : 调用\n\n```\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass ImageFilters(ABC):\n\n    @abstractmethod\n    def apply(self, image):\n        pass\n\n\nclass ImageHandler:\n\n    def __init__(self, image=None):\n        self.image = image or \"Some PNG file\"\n\n    def add_filter(self, *image_filter):\n        for f in image_filter:\n            if isinstance(f, ImageFilters):\n                f.apply(self.image)\n\n\nclass Pillow():\n\n    def blur_filter(self, image):\n        print(f\"fake image filter in Pillow lib is bluring `{image}`.\")\n\n\nclass BlurFilter(ImageFilters):\n\n    def apply(self, image):\n        pillow = Pillow()\n        pillow.blur_filter(image)\n\n\nif __name__ == \"__main__\":\n    handler = ImageHandler(\"SoHot.png\")\n    handler.add_filter(BlurFilter())\n\n```\n","source":"_posts/design-pattern/adapter-design-pattern-demo.md","raw":"---\ntitle: 设计模式-适配器模式\ndate: 2023-11-22 09:07:55 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n## 应用场景\n\n适配器模式属于比较常见且比较容易理解的设计模式.\n\n老话说的好, 0.5的铅芯是不能用在0.7的自动笔里的.\n\n当在项目里为了实现某些功能并应用某种设计模式, 或其他什么原因需要设计一些接口, 而这些接口的实现类要做的具体业务需要依赖于某个外部项目.\n\n比如需要再自己的项目中加入图片处理的一些功能. 需要用到开源的图像处理库.\n再比如在处理数据库ORM的时候针对不同的数据库需要有不同的实现.\n\n这时候就可以应用适配器模式.\n\n```mermaid\nclassDiagram\n    note for ImageHandler \"addFilter(filter)<br/>  filter.apply(this.image)\"\n    class ImageHandler{\n        addFilter(filter)\n    }\n\n    class ImageFilters{\n        <<interface>>\n        apply(Image)\n    }\n\n    note for BlurFilter \"apply(Image)<br/> Pillow.filter(image)\"\n    class BlurFilter{\n        apply(Image)\n    }\n\n    class Pillow{\n        filter()\n    }\n\n    ImageHandler *--> ImageFilters\n    BlurFilter --|> ImageFilters : 实现\n    BlurFilter *--> Pillow : 调用\n\n```\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass ImageFilters(ABC):\n\n    @abstractmethod\n    def apply(self, image):\n        pass\n\n\nclass ImageHandler:\n\n    def __init__(self, image=None):\n        self.image = image or \"Some PNG file\"\n\n    def add_filter(self, *image_filter):\n        for f in image_filter:\n            if isinstance(f, ImageFilters):\n                f.apply(self.image)\n\n\nclass Pillow():\n\n    def blur_filter(self, image):\n        print(f\"fake image filter in Pillow lib is bluring `{image}`.\")\n\n\nclass BlurFilter(ImageFilters):\n\n    def apply(self, image):\n        pillow = Pillow()\n        pillow.blur_filter(image)\n\n\nif __name__ == \"__main__\":\n    handler = ImageHandler(\"SoHot.png\")\n    handler.add_filter(BlurFilter())\n\n```\n","slug":"design-pattern-adapter-design-pattern-demo","published":1,"updated":"2023-12-13T08:43:58.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v5002pi3er38mhdvy8","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>适配器模式属于比较常见且比较容易理解的设计模式.</p>\n<p>老话说的好, 0.5的铅芯是不能用在0.7的自动笔里的.</p>\n<p>当在项目里为了实现某些功能并应用某种设计模式, 或其他什么原因需要设计一些接口, 而这些接口的实现类要做的具体业务需要依赖于某个外部项目.</p>\n<p>比如需要再自己的项目中加入图片处理的一些功能. 需要用到开源的图像处理库.<br>再比如在处理数据库ORM的时候针对不同的数据库需要有不同的实现.</p>\n<p>这时候就可以应用适配器模式.</p>\n<pre><code class=\"mermaid\">classDiagram\n    note for ImageHandler &quot;addFilter(filter)&lt;br/&gt;  filter.apply(this.image)&quot;\n    class ImageHandler&#123;\n        addFilter(filter)\n    &#125;\n\n    class ImageFilters&#123;\n        &lt;&lt;interface&gt;&gt;\n        apply(Image)\n    &#125;\n\n    note for BlurFilter &quot;apply(Image)&lt;br/&gt; Pillow.filter(image)&quot;\n    class BlurFilter&#123;\n        apply(Image)\n    &#125;\n\n    class Pillow&#123;\n        filter()\n    &#125;\n\n    ImageHandler *--&gt; ImageFilters\n    BlurFilter --|&gt; ImageFilters : 实现\n    BlurFilter *--&gt; Pillow : 调用\n</code></pre>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\n\n\nclass ImageFilters(ABC):\n\n    @abstractmethod\n    def apply(self, image):\n        pass\n\n\nclass ImageHandler:\n\n    def __init__(self, image=None):\n        self.image = image or &quot;Some PNG file&quot;\n\n    def add_filter(self, *image_filter):\n        for f in image_filter:\n            if isinstance(f, ImageFilters):\n                f.apply(self.image)\n\n\nclass Pillow():\n\n    def blur_filter(self, image):\n        print(f&quot;fake image filter in Pillow lib is bluring `&#123;image&#125;`.&quot;)\n\n\nclass BlurFilter(ImageFilters):\n\n    def apply(self, image):\n        pillow = Pillow()\n        pillow.blur_filter(image)\n\n\nif __name__ == &quot;__main__&quot;:\n    handler = ImageHandler(&quot;SoHot.png&quot;)\n    handler.add_filter(BlurFilter())\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>适配器模式属于比较常见且比较容易理解的设计模式.</p>\n<p>老话说的好, 0.5的铅芯是不能用在0.7的自动笔里的.</p>\n<p>当在项目里为了实现某些功能并应用某种设计模式, 或其他什么原因需要设计一些接口, 而这些接口的实现类要做的具体业务需要依赖于某个外部项目.</p>\n<p>比如需要再自己的项目中加入图片处理的一些功能. 需要用到开源的图像处理库.<br>再比如在处理数据库ORM的时候针对不同的数据库需要有不同的实现.</p>\n<p>这时候就可以应用适配器模式.</p>\n<pre><code class=\"mermaid\">classDiagram\n    note for ImageHandler &quot;addFilter(filter)&lt;br/&gt;  filter.apply(this.image)&quot;\n    class ImageHandler&#123;\n        addFilter(filter)\n    &#125;\n\n    class ImageFilters&#123;\n        &lt;&lt;interface&gt;&gt;\n        apply(Image)\n    &#125;\n\n    note for BlurFilter &quot;apply(Image)&lt;br/&gt; Pillow.filter(image)&quot;\n    class BlurFilter&#123;\n        apply(Image)\n    &#125;\n\n    class Pillow&#123;\n        filter()\n    &#125;\n\n    ImageHandler *--&gt; ImageFilters\n    BlurFilter --|&gt; ImageFilters : 实现\n    BlurFilter *--&gt; Pillow : 调用\n</code></pre>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\n\n\nclass ImageFilters(ABC):\n\n    @abstractmethod\n    def apply(self, image):\n        pass\n\n\nclass ImageHandler:\n\n    def __init__(self, image=None):\n        self.image = image or &quot;Some PNG file&quot;\n\n    def add_filter(self, *image_filter):\n        for f in image_filter:\n            if isinstance(f, ImageFilters):\n                f.apply(self.image)\n\n\nclass Pillow():\n\n    def blur_filter(self, image):\n        print(f&quot;fake image filter in Pillow lib is bluring `&#123;image&#125;`.&quot;)\n\n\nclass BlurFilter(ImageFilters):\n\n    def apply(self, image):\n        pillow = Pillow()\n        pillow.blur_filter(image)\n\n\nif __name__ == &quot;__main__&quot;:\n    handler = ImageHandler(&quot;SoHot.png&quot;)\n    handler.add_filter(BlurFilter())\n</code></pre>\n"},{"title":"设计模式-生成器模式","date":"2023-11-25T03:20:55.000Z","mermaid":true,"_content":"\n## 应用场景\n\n> To separate the construction of an object from its representation.\n>\n{: .prompt-info}\n\n顾名思义, 将对象的结构与呈现形式进行分离.\n\n经常会有将数据或对象从一种结果导出为其他呈现形式的需求, 比如PPT转PDF, 表格转图表等等.\n\n```mermaid\nclassDiagram\n    direction LR\n    class Presentation{\n        + export()\n    }\n\n    class PresentationBuilder{\n        <<interface>>\n        + addSlide()\n    }\n\n    class PDFDocumentBuilder{\n        + addSlide()\n        + getPDFDocument()\n    }\n\n    class MovieBuilder{\n        + addSlide()\n        + getMovie()\n    }\n\n    Presentation *--> PresentationBuilder\n    PresentationBuilder <|-- PDFDocumentBuilder\n    PresentationBuilder <|-- MovieBuilder\n```\n\n## 简单的python实现\n\n```python\nclass Slide:\n\n    def __init__(self, text):\n        self.text = text\n\n\nclass PresentationBuilder(ABC):\n\n    @abstractmethod\n    def add_slide(self, slide: Slide):\n        pass\n\n    @abstractmethod\n    def get_result(self):\n        pass\n\n\nclass PDFBuilder(PresentationBuilder):\n\n    def __init__(self):\n        self.document = []\n\n    def add_slide(self, slide: Slide):\n        self.document.append(slide)\n\n    def get_result(self):\n        return self.document\n\n\nclass MovieBuilder(PresentationBuilder):\n\n    def __init__(self):\n        self.frames = []\n        self.duration = []\n\n    def add_slide(self, slide: Slide):\n        self.frames.append(slide)\n        self.duration.append(randint(1, 3))\n\n    def get_result(self):\n        return list(zip(self.frames, self.duration))\n\n\nclass Presentation:\n\n    def __init__(self, *slides: Slide):\n        self.slides = slides or []\n\n    def add_slide(self, slide: Slide):\n        self.slides.append(slide)\n\n    def remove_slide(self, index: int):\n        self.slides.remove(index)\n\n    def export(self, builder: PresentationBuilder):\n\n        for slide in self.slides:\n            builder.add_slide(slide)\n\n\nif __name__ == \"__main__\":\n\n    s = [f\"slide {i}\" for i in range(3)]\n    p = Presentation(*s)\n    pdf = PDFBuilder()\n    movie = MovieBuilder()\n    p.export(pdf)\n    p.export(movie)\n    print(pdf.get_result())\n    print(movie.get_result())\n```\n\n输出结果:\n\n```bash\n['slide 0', 'slide 1', 'slide 2']\n[('slide 0', 2), ('slide 1', 1), ('slide 2', 1)]\n```\n","source":"_posts/design-pattern/builder-design-pattern-demo.md","raw":"---\ntitle: 设计模式-生成器模式\ndate: 2023-11-25 11:20:55 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n## 应用场景\n\n> To separate the construction of an object from its representation.\n>\n{: .prompt-info}\n\n顾名思义, 将对象的结构与呈现形式进行分离.\n\n经常会有将数据或对象从一种结果导出为其他呈现形式的需求, 比如PPT转PDF, 表格转图表等等.\n\n```mermaid\nclassDiagram\n    direction LR\n    class Presentation{\n        + export()\n    }\n\n    class PresentationBuilder{\n        <<interface>>\n        + addSlide()\n    }\n\n    class PDFDocumentBuilder{\n        + addSlide()\n        + getPDFDocument()\n    }\n\n    class MovieBuilder{\n        + addSlide()\n        + getMovie()\n    }\n\n    Presentation *--> PresentationBuilder\n    PresentationBuilder <|-- PDFDocumentBuilder\n    PresentationBuilder <|-- MovieBuilder\n```\n\n## 简单的python实现\n\n```python\nclass Slide:\n\n    def __init__(self, text):\n        self.text = text\n\n\nclass PresentationBuilder(ABC):\n\n    @abstractmethod\n    def add_slide(self, slide: Slide):\n        pass\n\n    @abstractmethod\n    def get_result(self):\n        pass\n\n\nclass PDFBuilder(PresentationBuilder):\n\n    def __init__(self):\n        self.document = []\n\n    def add_slide(self, slide: Slide):\n        self.document.append(slide)\n\n    def get_result(self):\n        return self.document\n\n\nclass MovieBuilder(PresentationBuilder):\n\n    def __init__(self):\n        self.frames = []\n        self.duration = []\n\n    def add_slide(self, slide: Slide):\n        self.frames.append(slide)\n        self.duration.append(randint(1, 3))\n\n    def get_result(self):\n        return list(zip(self.frames, self.duration))\n\n\nclass Presentation:\n\n    def __init__(self, *slides: Slide):\n        self.slides = slides or []\n\n    def add_slide(self, slide: Slide):\n        self.slides.append(slide)\n\n    def remove_slide(self, index: int):\n        self.slides.remove(index)\n\n    def export(self, builder: PresentationBuilder):\n\n        for slide in self.slides:\n            builder.add_slide(slide)\n\n\nif __name__ == \"__main__\":\n\n    s = [f\"slide {i}\" for i in range(3)]\n    p = Presentation(*s)\n    pdf = PDFBuilder()\n    movie = MovieBuilder()\n    p.export(pdf)\n    p.export(movie)\n    print(pdf.get_result())\n    print(movie.get_result())\n```\n\n输出结果:\n\n```bash\n['slide 0', 'slide 1', 'slide 2']\n[('slide 0', 2), ('slide 1', 1), ('slide 2', 1)]\n```\n","slug":"design-pattern-builder-design-pattern-demo","published":1,"updated":"2023-12-13T08:43:58.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v5002ti3er80nsepzt","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><blockquote>\n<p>To separate the construction of an object from its representation.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<p>顾名思义, 将对象的结构与呈现形式进行分离.</p>\n<p>经常会有将数据或对象从一种结果导出为其他呈现形式的需求, 比如PPT转PDF, 表格转图表等等.</p>\n<pre><code class=\"mermaid\">classDiagram\n    direction LR\n    class Presentation&#123;\n        + export()\n    &#125;\n\n    class PresentationBuilder&#123;\n        &lt;&lt;interface&gt;&gt;\n        + addSlide()\n    &#125;\n\n    class PDFDocumentBuilder&#123;\n        + addSlide()\n        + getPDFDocument()\n    &#125;\n\n    class MovieBuilder&#123;\n        + addSlide()\n        + getMovie()\n    &#125;\n\n    Presentation *--&gt; PresentationBuilder\n    PresentationBuilder &lt;|-- PDFDocumentBuilder\n    PresentationBuilder &lt;|-- MovieBuilder\n</code></pre>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">class Slide:\n\n    def __init__(self, text):\n        self.text = text\n\n\nclass PresentationBuilder(ABC):\n\n    @abstractmethod\n    def add_slide(self, slide: Slide):\n        pass\n\n    @abstractmethod\n    def get_result(self):\n        pass\n\n\nclass PDFBuilder(PresentationBuilder):\n\n    def __init__(self):\n        self.document = []\n\n    def add_slide(self, slide: Slide):\n        self.document.append(slide)\n\n    def get_result(self):\n        return self.document\n\n\nclass MovieBuilder(PresentationBuilder):\n\n    def __init__(self):\n        self.frames = []\n        self.duration = []\n\n    def add_slide(self, slide: Slide):\n        self.frames.append(slide)\n        self.duration.append(randint(1, 3))\n\n    def get_result(self):\n        return list(zip(self.frames, self.duration))\n\n\nclass Presentation:\n\n    def __init__(self, *slides: Slide):\n        self.slides = slides or []\n\n    def add_slide(self, slide: Slide):\n        self.slides.append(slide)\n\n    def remove_slide(self, index: int):\n        self.slides.remove(index)\n\n    def export(self, builder: PresentationBuilder):\n\n        for slide in self.slides:\n            builder.add_slide(slide)\n\n\nif __name__ == &quot;__main__&quot;:\n\n    s = [f&quot;slide &#123;i&#125;&quot; for i in range(3)]\n    p = Presentation(*s)\n    pdf = PDFBuilder()\n    movie = MovieBuilder()\n    p.export(pdf)\n    p.export(movie)\n    print(pdf.get_result())\n    print(movie.get_result())\n</code></pre>\n<p>输出结果:</p>\n<pre><code class=\"bash\">[&#39;slide 0&#39;, &#39;slide 1&#39;, &#39;slide 2&#39;]\n[(&#39;slide 0&#39;, 2), (&#39;slide 1&#39;, 1), (&#39;slide 2&#39;, 1)]\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><blockquote>\n<p>To separate the construction of an object from its representation.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<p>顾名思义, 将对象的结构与呈现形式进行分离.</p>\n<p>经常会有将数据或对象从一种结果导出为其他呈现形式的需求, 比如PPT转PDF, 表格转图表等等.</p>\n<pre><code class=\"mermaid\">classDiagram\n    direction LR\n    class Presentation&#123;\n        + export()\n    &#125;\n\n    class PresentationBuilder&#123;\n        &lt;&lt;interface&gt;&gt;\n        + addSlide()\n    &#125;\n\n    class PDFDocumentBuilder&#123;\n        + addSlide()\n        + getPDFDocument()\n    &#125;\n\n    class MovieBuilder&#123;\n        + addSlide()\n        + getMovie()\n    &#125;\n\n    Presentation *--&gt; PresentationBuilder\n    PresentationBuilder &lt;|-- PDFDocumentBuilder\n    PresentationBuilder &lt;|-- MovieBuilder\n</code></pre>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">class Slide:\n\n    def __init__(self, text):\n        self.text = text\n\n\nclass PresentationBuilder(ABC):\n\n    @abstractmethod\n    def add_slide(self, slide: Slide):\n        pass\n\n    @abstractmethod\n    def get_result(self):\n        pass\n\n\nclass PDFBuilder(PresentationBuilder):\n\n    def __init__(self):\n        self.document = []\n\n    def add_slide(self, slide: Slide):\n        self.document.append(slide)\n\n    def get_result(self):\n        return self.document\n\n\nclass MovieBuilder(PresentationBuilder):\n\n    def __init__(self):\n        self.frames = []\n        self.duration = []\n\n    def add_slide(self, slide: Slide):\n        self.frames.append(slide)\n        self.duration.append(randint(1, 3))\n\n    def get_result(self):\n        return list(zip(self.frames, self.duration))\n\n\nclass Presentation:\n\n    def __init__(self, *slides: Slide):\n        self.slides = slides or []\n\n    def add_slide(self, slide: Slide):\n        self.slides.append(slide)\n\n    def remove_slide(self, index: int):\n        self.slides.remove(index)\n\n    def export(self, builder: PresentationBuilder):\n\n        for slide in self.slides:\n            builder.add_slide(slide)\n\n\nif __name__ == &quot;__main__&quot;:\n\n    s = [f&quot;slide &#123;i&#125;&quot; for i in range(3)]\n    p = Presentation(*s)\n    pdf = PDFBuilder()\n    movie = MovieBuilder()\n    p.export(pdf)\n    p.export(movie)\n    print(pdf.get_result())\n    print(movie.get_result())\n</code></pre>\n<p>输出结果:</p>\n<pre><code class=\"bash\">[&#39;slide 0&#39;, &#39;slide 1&#39;, &#39;slide 2&#39;]\n[(&#39;slide 0&#39;, 2), (&#39;slide 1&#39;, 1), (&#39;slide 2&#39;, 1)]\n</code></pre>\n"},{"title":"设计模式-命令模式","date":"2023-11-20T06:28:30.000Z","mermaid":true,"_content":"\n## 应用场景\n\n假设在编写一个UI框架, 框架中包含一个按钮对象Button, 当点击按钮时则会执行一些指令.\n\n为了能够实现框架与功能的解耦, 通常便会使用命令模式.\n\n* 按钮点击时会调用命令接口的执行命令\n* 实现接口的对象则依靠多态指派\n* 实现接口的实际指令对象仅负责将指令派发至具体的功能实现类\n* 最终由实现类完成指令\n\n```mermaid\nclassDiagram\n    class Button{\n        click()\n    }\n    class Command{\n        <<interface>>\n        execute()\n    }\n    class AddCommand{\n        execute()\n    }\n    class AddService{\n        addSomething()\n    }\n    Button *--> Command\n    AddCommand --|> Command\n    AddCommand --> AddService\n```\n\n通过这个结构可以看出来, 框架中的`Button`对于具体业务`AddService`是完全隔离的.\n\n业务本身不依赖任何框架, 也就是可以对接任何框架\n\n而`AddCommand`则是用来链接框架和具体业务的派发对象. 当需要更换框架的时候也只需要换个派发对象也就是了.\n\n简单的python实现:\n\n```python\nimport abc\n\n\n# Framework\nclass Command(abc.ABC):\n\n    @abc.abstractmethod\n    def execute(self):\n        pass\n\n\nclass UIControl(abc.ABC):\n\n    @abc.abstractmethod\n    def draw(self):\n        pass\n\n    @abc.abstractmethod\n    def action(self):\n        pass\n\n\nclass Button(UIControl):\n\n    def __init__(self, cmd: Command = None):\n        self.__cmd = cmd\n\n    def draw(self):\n        print(\"draw Button\")\n\n    def click(self):\n        self.action()\n\n    def action(self):\n        if self.command:\n            self.command.execute()\n\n    @property\n    def command(self):\n        return self.__cmd\n\n    @command.setter\n    def command(self, value):\n        if isinstance(value, Command):\n            self.__cmd = value\n\n\n# Project using Framework above.\nclass AddButton(Button):\n\n    def __init__(self):\n        super().__init__(AddCommand())\n\n    def draw(self):\n        print(\"draw add button.\")\n\n\nclass Service(abc.ABC):\n\n    @abc.abstractmethod\n    def perform(self):\n        pass\n\n\nclass AddService(Service):\n\n    def perform(self):\n        self.__add_somethine()\n\n    def __add_somethine(self):\n        print(\"add something to somewhere...\")\n\n\nclass BasicCommand(Command):\n\n    def __init__(self, service: Service):\n        self.__service = service\n\n    def execute(self):\n        self.__service.perform()\n\n\nclass AddCommand(BasicCommand):\n\n    def __init__(self):\n        super().__init__(AddService())\n\n\nif __name__ == \"__main__\":\n    btn = AddButton()\n    btn.draw()\n    btn.click()\n\n```\n","source":"_posts/design-pattern/command-design-pattern-demo.md","raw":"---\ntitle: 设计模式-命令模式\ndate: 2023-11-20 14:28:30 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n## 应用场景\n\n假设在编写一个UI框架, 框架中包含一个按钮对象Button, 当点击按钮时则会执行一些指令.\n\n为了能够实现框架与功能的解耦, 通常便会使用命令模式.\n\n* 按钮点击时会调用命令接口的执行命令\n* 实现接口的对象则依靠多态指派\n* 实现接口的实际指令对象仅负责将指令派发至具体的功能实现类\n* 最终由实现类完成指令\n\n```mermaid\nclassDiagram\n    class Button{\n        click()\n    }\n    class Command{\n        <<interface>>\n        execute()\n    }\n    class AddCommand{\n        execute()\n    }\n    class AddService{\n        addSomething()\n    }\n    Button *--> Command\n    AddCommand --|> Command\n    AddCommand --> AddService\n```\n\n通过这个结构可以看出来, 框架中的`Button`对于具体业务`AddService`是完全隔离的.\n\n业务本身不依赖任何框架, 也就是可以对接任何框架\n\n而`AddCommand`则是用来链接框架和具体业务的派发对象. 当需要更换框架的时候也只需要换个派发对象也就是了.\n\n简单的python实现:\n\n```python\nimport abc\n\n\n# Framework\nclass Command(abc.ABC):\n\n    @abc.abstractmethod\n    def execute(self):\n        pass\n\n\nclass UIControl(abc.ABC):\n\n    @abc.abstractmethod\n    def draw(self):\n        pass\n\n    @abc.abstractmethod\n    def action(self):\n        pass\n\n\nclass Button(UIControl):\n\n    def __init__(self, cmd: Command = None):\n        self.__cmd = cmd\n\n    def draw(self):\n        print(\"draw Button\")\n\n    def click(self):\n        self.action()\n\n    def action(self):\n        if self.command:\n            self.command.execute()\n\n    @property\n    def command(self):\n        return self.__cmd\n\n    @command.setter\n    def command(self, value):\n        if isinstance(value, Command):\n            self.__cmd = value\n\n\n# Project using Framework above.\nclass AddButton(Button):\n\n    def __init__(self):\n        super().__init__(AddCommand())\n\n    def draw(self):\n        print(\"draw add button.\")\n\n\nclass Service(abc.ABC):\n\n    @abc.abstractmethod\n    def perform(self):\n        pass\n\n\nclass AddService(Service):\n\n    def perform(self):\n        self.__add_somethine()\n\n    def __add_somethine(self):\n        print(\"add something to somewhere...\")\n\n\nclass BasicCommand(Command):\n\n    def __init__(self, service: Service):\n        self.__service = service\n\n    def execute(self):\n        self.__service.perform()\n\n\nclass AddCommand(BasicCommand):\n\n    def __init__(self):\n        super().__init__(AddService())\n\n\nif __name__ == \"__main__\":\n    btn = AddButton()\n    btn.draw()\n    btn.click()\n\n```\n","slug":"design-pattern-command-design-pattern-demo","published":1,"updated":"2023-12-13T08:43:58.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v6002vi3er5zek68eq","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>假设在编写一个UI框架, 框架中包含一个按钮对象Button, 当点击按钮时则会执行一些指令.</p>\n<p>为了能够实现框架与功能的解耦, 通常便会使用命令模式.</p>\n<ul>\n<li>按钮点击时会调用命令接口的执行命令</li>\n<li>实现接口的对象则依靠多态指派</li>\n<li>实现接口的实际指令对象仅负责将指令派发至具体的功能实现类</li>\n<li>最终由实现类完成指令</li>\n</ul>\n<pre><code class=\"mermaid\">classDiagram\n    class Button&#123;\n        click()\n    &#125;\n    class Command&#123;\n        &lt;&lt;interface&gt;&gt;\n        execute()\n    &#125;\n    class AddCommand&#123;\n        execute()\n    &#125;\n    class AddService&#123;\n        addSomething()\n    &#125;\n    Button *--&gt; Command\n    AddCommand --|&gt; Command\n    AddCommand --&gt; AddService\n</code></pre>\n<p>通过这个结构可以看出来, 框架中的<code>Button</code>对于具体业务<code>AddService</code>是完全隔离的.</p>\n<p>业务本身不依赖任何框架, 也就是可以对接任何框架</p>\n<p>而<code>AddCommand</code>则是用来链接框架和具体业务的派发对象. 当需要更换框架的时候也只需要换个派发对象也就是了.</p>\n<p>简单的python实现:</p>\n<pre><code class=\"python\">import abc\n\n\n# Framework\nclass Command(abc.ABC):\n\n    @abc.abstractmethod\n    def execute(self):\n        pass\n\n\nclass UIControl(abc.ABC):\n\n    @abc.abstractmethod\n    def draw(self):\n        pass\n\n    @abc.abstractmethod\n    def action(self):\n        pass\n\n\nclass Button(UIControl):\n\n    def __init__(self, cmd: Command = None):\n        self.__cmd = cmd\n\n    def draw(self):\n        print(&quot;draw Button&quot;)\n\n    def click(self):\n        self.action()\n\n    def action(self):\n        if self.command:\n            self.command.execute()\n\n    @property\n    def command(self):\n        return self.__cmd\n\n    @command.setter\n    def command(self, value):\n        if isinstance(value, Command):\n            self.__cmd = value\n\n\n# Project using Framework above.\nclass AddButton(Button):\n\n    def __init__(self):\n        super().__init__(AddCommand())\n\n    def draw(self):\n        print(&quot;draw add button.&quot;)\n\n\nclass Service(abc.ABC):\n\n    @abc.abstractmethod\n    def perform(self):\n        pass\n\n\nclass AddService(Service):\n\n    def perform(self):\n        self.__add_somethine()\n\n    def __add_somethine(self):\n        print(&quot;add something to somewhere...&quot;)\n\n\nclass BasicCommand(Command):\n\n    def __init__(self, service: Service):\n        self.__service = service\n\n    def execute(self):\n        self.__service.perform()\n\n\nclass AddCommand(BasicCommand):\n\n    def __init__(self):\n        super().__init__(AddService())\n\n\nif __name__ == &quot;__main__&quot;:\n    btn = AddButton()\n    btn.draw()\n    btn.click()\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>假设在编写一个UI框架, 框架中包含一个按钮对象Button, 当点击按钮时则会执行一些指令.</p>\n<p>为了能够实现框架与功能的解耦, 通常便会使用命令模式.</p>\n<ul>\n<li>按钮点击时会调用命令接口的执行命令</li>\n<li>实现接口的对象则依靠多态指派</li>\n<li>实现接口的实际指令对象仅负责将指令派发至具体的功能实现类</li>\n<li>最终由实现类完成指令</li>\n</ul>\n<pre><code class=\"mermaid\">classDiagram\n    class Button&#123;\n        click()\n    &#125;\n    class Command&#123;\n        &lt;&lt;interface&gt;&gt;\n        execute()\n    &#125;\n    class AddCommand&#123;\n        execute()\n    &#125;\n    class AddService&#123;\n        addSomething()\n    &#125;\n    Button *--&gt; Command\n    AddCommand --|&gt; Command\n    AddCommand --&gt; AddService\n</code></pre>\n<p>通过这个结构可以看出来, 框架中的<code>Button</code>对于具体业务<code>AddService</code>是完全隔离的.</p>\n<p>业务本身不依赖任何框架, 也就是可以对接任何框架</p>\n<p>而<code>AddCommand</code>则是用来链接框架和具体业务的派发对象. 当需要更换框架的时候也只需要换个派发对象也就是了.</p>\n<p>简单的python实现:</p>\n<pre><code class=\"python\">import abc\n\n\n# Framework\nclass Command(abc.ABC):\n\n    @abc.abstractmethod\n    def execute(self):\n        pass\n\n\nclass UIControl(abc.ABC):\n\n    @abc.abstractmethod\n    def draw(self):\n        pass\n\n    @abc.abstractmethod\n    def action(self):\n        pass\n\n\nclass Button(UIControl):\n\n    def __init__(self, cmd: Command = None):\n        self.__cmd = cmd\n\n    def draw(self):\n        print(&quot;draw Button&quot;)\n\n    def click(self):\n        self.action()\n\n    def action(self):\n        if self.command:\n            self.command.execute()\n\n    @property\n    def command(self):\n        return self.__cmd\n\n    @command.setter\n    def command(self, value):\n        if isinstance(value, Command):\n            self.__cmd = value\n\n\n# Project using Framework above.\nclass AddButton(Button):\n\n    def __init__(self):\n        super().__init__(AddCommand())\n\n    def draw(self):\n        print(&quot;draw add button.&quot;)\n\n\nclass Service(abc.ABC):\n\n    @abc.abstractmethod\n    def perform(self):\n        pass\n\n\nclass AddService(Service):\n\n    def perform(self):\n        self.__add_somethine()\n\n    def __add_somethine(self):\n        print(&quot;add something to somewhere...&quot;)\n\n\nclass BasicCommand(Command):\n\n    def __init__(self, service: Service):\n        self.__service = service\n\n    def execute(self):\n        self.__service.perform()\n\n\nclass AddCommand(BasicCommand):\n\n    def __init__(self):\n        super().__init__(AddService())\n\n\nif __name__ == &quot;__main__&quot;:\n    btn = AddButton()\n    btn.draw()\n    btn.click()\n</code></pre>\n"},{"title":"设计模式-组合模式","date":"2023-11-21T13:45:51.000Z","mermaid":true,"_content":"\n## 应用场景\n\n在使用类似于PowerPoint, Keynot等软件时经常会处理一些简单的图形, 或者具有关联关系的各种元素.通常情况下, 我们会把他们放入一个组中.\n\n之后在对组进行操作的时候, 比如移动, 缩放一类的, 组中的所有元素就会一同执行这些操作.\n\n又或者文件夹和文件的关系, 在复制, 移动, 删除文件夹的时候其中的所有文件都会被一同操作.\n\n当在程序中处理类似问题的时候可以通过一个组对象来保存同组的其他对象, 并在执行某一方法的时候对所有组内的对象一并执行.\n\n```mermaid\nclassDiagram\n    class Component{\n        <<interface>>\n        resize()\n        move()\n        render()\n    }\n\n    class Shape{\n        <<interface>>\n        resize()\n        move()\n        render()\n    }\n\n    class RoundRect{\n        resize()\n        move()\n        render()\n    }\n\n    class Oval{\n        resize()\n        move()\n        render()\n    }\n\n    class Group{\n        cmps:List(Component)\n        resize()\n        move()\n        render()\n        add(Component)\n    }\n\n    Component <|-- Shape\n    Component <|-- Group\n    Shape <|-- RoundRect\n    Shape <|-- Oval\n\n```\n\n这样所有的形状都是Component, 而组也同样是Component, 这也就意味着元素和组有这相同的通讯方式.\n\n对单一元素进行操作,调用自身的接口方法, 而对组进行操作, 组直接调用自身子元素的对应方法即可, 无论子元素是组还是具体元素.\n\n也就实现了无论对于单一元素还是元素组合的相同操作模式.\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\n\n\nclass Excuteable(ABC):\n\n    @abstractmethod\n    def attack(self, target):\n        pass\n\n    @abstractmethod\n    def return_to_base(self):\n        pass\n\n    @abstractmethod\n    def destroy(self):\n        pass\n\n\nclass MarkSeries(Excuteable):\n\n    class Status(Enum):\n        STAND_BY = 1\n        FIGHTING = 2\n        REPAIRING = 3\n        CHARGING = 4\n\n    def __init__(self, name=None):\n        self.name = name or \"Mark Prototype\"\n        self.attack_power = 100\n        self.heath_point = 1000\n        self.status = MarkSeries.Status.STAND_BY\n        self.weapon = \"biu~biu~biu~\"\n\n    def attack(self, target):\n        print(\n            f\"{self.name} {self.weapon} on `{target}` cause `{self.attack_power}` damage.\")\n\n    def return_to_base(self):\n        print(f\"{self.name} is retreat.\")\n\n    def destroy(self):\n        print(f\"{self.name} is exploded. peng~\")\n\n\nclass Mark2(MarkSeries):\n\n    def __init__(self):\n        super().__init__(\"Mark II\")\n        self.attack_power += 20\n        self.heath_point += 200\n        self.weapon = \"kuang~kuang~kuang~\"\n\n\nclass Mark3(MarkSeries):\n\n    def __init__(self):\n        super().__init__(\"Mark III\")\n        self.attack_power += 50\n        self.heath_point += 500\n        self.weapon = \"ka~ka~ka~\"\n\n\nclass Formation(Excuteable):\n\n    def __init__(self, *units):\n        self.units = units or []\n\n    def add_unit(self, unit):\n        self.units.append(unit)\n\n    def remove_unit(self, unit):\n        if unit in self.units:\n            self.units.remove(unit)\n\n    def attack(self, target):\n        for unit in self.units:\n            unit.attack(target)\n\n    def return_to_base(self):\n        for unit in self.units:\n            unit.return_to_base()\n\n    def destroy(self):\n        for unit in self.units:\n            unit.destroy()\n\n\nif __name__ == \"__main__\":\n    boss = \"Thanos\"\n    m2 = Mark2()\n    m3 = Mark3()\n\n    m2.attack(boss)\n    m3.attack(boss)\n\n    form = Formation(m2, m3)\n\n    form.attack(boss)\n    form.return_to_base()\n    form.destroy()\n```\n","source":"_posts/design-pattern/composite-design-pattern.md","raw":"---\ntitle: 设计模式-组合模式\ndate: 2023-11-21 21:45:51 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n## 应用场景\n\n在使用类似于PowerPoint, Keynot等软件时经常会处理一些简单的图形, 或者具有关联关系的各种元素.通常情况下, 我们会把他们放入一个组中.\n\n之后在对组进行操作的时候, 比如移动, 缩放一类的, 组中的所有元素就会一同执行这些操作.\n\n又或者文件夹和文件的关系, 在复制, 移动, 删除文件夹的时候其中的所有文件都会被一同操作.\n\n当在程序中处理类似问题的时候可以通过一个组对象来保存同组的其他对象, 并在执行某一方法的时候对所有组内的对象一并执行.\n\n```mermaid\nclassDiagram\n    class Component{\n        <<interface>>\n        resize()\n        move()\n        render()\n    }\n\n    class Shape{\n        <<interface>>\n        resize()\n        move()\n        render()\n    }\n\n    class RoundRect{\n        resize()\n        move()\n        render()\n    }\n\n    class Oval{\n        resize()\n        move()\n        render()\n    }\n\n    class Group{\n        cmps:List(Component)\n        resize()\n        move()\n        render()\n        add(Component)\n    }\n\n    Component <|-- Shape\n    Component <|-- Group\n    Shape <|-- RoundRect\n    Shape <|-- Oval\n\n```\n\n这样所有的形状都是Component, 而组也同样是Component, 这也就意味着元素和组有这相同的通讯方式.\n\n对单一元素进行操作,调用自身的接口方法, 而对组进行操作, 组直接调用自身子元素的对应方法即可, 无论子元素是组还是具体元素.\n\n也就实现了无论对于单一元素还是元素组合的相同操作模式.\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\n\n\nclass Excuteable(ABC):\n\n    @abstractmethod\n    def attack(self, target):\n        pass\n\n    @abstractmethod\n    def return_to_base(self):\n        pass\n\n    @abstractmethod\n    def destroy(self):\n        pass\n\n\nclass MarkSeries(Excuteable):\n\n    class Status(Enum):\n        STAND_BY = 1\n        FIGHTING = 2\n        REPAIRING = 3\n        CHARGING = 4\n\n    def __init__(self, name=None):\n        self.name = name or \"Mark Prototype\"\n        self.attack_power = 100\n        self.heath_point = 1000\n        self.status = MarkSeries.Status.STAND_BY\n        self.weapon = \"biu~biu~biu~\"\n\n    def attack(self, target):\n        print(\n            f\"{self.name} {self.weapon} on `{target}` cause `{self.attack_power}` damage.\")\n\n    def return_to_base(self):\n        print(f\"{self.name} is retreat.\")\n\n    def destroy(self):\n        print(f\"{self.name} is exploded. peng~\")\n\n\nclass Mark2(MarkSeries):\n\n    def __init__(self):\n        super().__init__(\"Mark II\")\n        self.attack_power += 20\n        self.heath_point += 200\n        self.weapon = \"kuang~kuang~kuang~\"\n\n\nclass Mark3(MarkSeries):\n\n    def __init__(self):\n        super().__init__(\"Mark III\")\n        self.attack_power += 50\n        self.heath_point += 500\n        self.weapon = \"ka~ka~ka~\"\n\n\nclass Formation(Excuteable):\n\n    def __init__(self, *units):\n        self.units = units or []\n\n    def add_unit(self, unit):\n        self.units.append(unit)\n\n    def remove_unit(self, unit):\n        if unit in self.units:\n            self.units.remove(unit)\n\n    def attack(self, target):\n        for unit in self.units:\n            unit.attack(target)\n\n    def return_to_base(self):\n        for unit in self.units:\n            unit.return_to_base()\n\n    def destroy(self):\n        for unit in self.units:\n            unit.destroy()\n\n\nif __name__ == \"__main__\":\n    boss = \"Thanos\"\n    m2 = Mark2()\n    m3 = Mark3()\n\n    m2.attack(boss)\n    m3.attack(boss)\n\n    form = Formation(m2, m3)\n\n    form.attack(boss)\n    form.return_to_base()\n    form.destroy()\n```\n","slug":"design-pattern-composite-design-pattern","published":1,"updated":"2023-12-13T08:43:58.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v6002yi3er8lg37gxl","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>在使用类似于PowerPoint, Keynot等软件时经常会处理一些简单的图形, 或者具有关联关系的各种元素.通常情况下, 我们会把他们放入一个组中.</p>\n<p>之后在对组进行操作的时候, 比如移动, 缩放一类的, 组中的所有元素就会一同执行这些操作.</p>\n<p>又或者文件夹和文件的关系, 在复制, 移动, 删除文件夹的时候其中的所有文件都会被一同操作.</p>\n<p>当在程序中处理类似问题的时候可以通过一个组对象来保存同组的其他对象, 并在执行某一方法的时候对所有组内的对象一并执行.</p>\n<pre><code class=\"mermaid\">classDiagram\n    class Component&#123;\n        &lt;&lt;interface&gt;&gt;\n        resize()\n        move()\n        render()\n    &#125;\n\n    class Shape&#123;\n        &lt;&lt;interface&gt;&gt;\n        resize()\n        move()\n        render()\n    &#125;\n\n    class RoundRect&#123;\n        resize()\n        move()\n        render()\n    &#125;\n\n    class Oval&#123;\n        resize()\n        move()\n        render()\n    &#125;\n\n    class Group&#123;\n        cmps:List(Component)\n        resize()\n        move()\n        render()\n        add(Component)\n    &#125;\n\n    Component &lt;|-- Shape\n    Component &lt;|-- Group\n    Shape &lt;|-- RoundRect\n    Shape &lt;|-- Oval\n</code></pre>\n<p>这样所有的形状都是Component, 而组也同样是Component, 这也就意味着元素和组有这相同的通讯方式.</p>\n<p>对单一元素进行操作,调用自身的接口方法, 而对组进行操作, 组直接调用自身子元素的对应方法即可, 无论子元素是组还是具体元素.</p>\n<p>也就实现了无论对于单一元素还是元素组合的相同操作模式.</p>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\nfrom enum import Enum\n\n\nclass Excuteable(ABC):\n\n    @abstractmethod\n    def attack(self, target):\n        pass\n\n    @abstractmethod\n    def return_to_base(self):\n        pass\n\n    @abstractmethod\n    def destroy(self):\n        pass\n\n\nclass MarkSeries(Excuteable):\n\n    class Status(Enum):\n        STAND_BY = 1\n        FIGHTING = 2\n        REPAIRING = 3\n        CHARGING = 4\n\n    def __init__(self, name=None):\n        self.name = name or &quot;Mark Prototype&quot;\n        self.attack_power = 100\n        self.heath_point = 1000\n        self.status = MarkSeries.Status.STAND_BY\n        self.weapon = &quot;biu~biu~biu~&quot;\n\n    def attack(self, target):\n        print(\n            f&quot;&#123;self.name&#125; &#123;self.weapon&#125; on `&#123;target&#125;` cause `&#123;self.attack_power&#125;` damage.&quot;)\n\n    def return_to_base(self):\n        print(f&quot;&#123;self.name&#125; is retreat.&quot;)\n\n    def destroy(self):\n        print(f&quot;&#123;self.name&#125; is exploded. peng~&quot;)\n\n\nclass Mark2(MarkSeries):\n\n    def __init__(self):\n        super().__init__(&quot;Mark II&quot;)\n        self.attack_power += 20\n        self.heath_point += 200\n        self.weapon = &quot;kuang~kuang~kuang~&quot;\n\n\nclass Mark3(MarkSeries):\n\n    def __init__(self):\n        super().__init__(&quot;Mark III&quot;)\n        self.attack_power += 50\n        self.heath_point += 500\n        self.weapon = &quot;ka~ka~ka~&quot;\n\n\nclass Formation(Excuteable):\n\n    def __init__(self, *units):\n        self.units = units or []\n\n    def add_unit(self, unit):\n        self.units.append(unit)\n\n    def remove_unit(self, unit):\n        if unit in self.units:\n            self.units.remove(unit)\n\n    def attack(self, target):\n        for unit in self.units:\n            unit.attack(target)\n\n    def return_to_base(self):\n        for unit in self.units:\n            unit.return_to_base()\n\n    def destroy(self):\n        for unit in self.units:\n            unit.destroy()\n\n\nif __name__ == &quot;__main__&quot;:\n    boss = &quot;Thanos&quot;\n    m2 = Mark2()\n    m3 = Mark3()\n\n    m2.attack(boss)\n    m3.attack(boss)\n\n    form = Formation(m2, m3)\n\n    form.attack(boss)\n    form.return_to_base()\n    form.destroy()\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>在使用类似于PowerPoint, Keynot等软件时经常会处理一些简单的图形, 或者具有关联关系的各种元素.通常情况下, 我们会把他们放入一个组中.</p>\n<p>之后在对组进行操作的时候, 比如移动, 缩放一类的, 组中的所有元素就会一同执行这些操作.</p>\n<p>又或者文件夹和文件的关系, 在复制, 移动, 删除文件夹的时候其中的所有文件都会被一同操作.</p>\n<p>当在程序中处理类似问题的时候可以通过一个组对象来保存同组的其他对象, 并在执行某一方法的时候对所有组内的对象一并执行.</p>\n<pre><code class=\"mermaid\">classDiagram\n    class Component&#123;\n        &lt;&lt;interface&gt;&gt;\n        resize()\n        move()\n        render()\n    &#125;\n\n    class Shape&#123;\n        &lt;&lt;interface&gt;&gt;\n        resize()\n        move()\n        render()\n    &#125;\n\n    class RoundRect&#123;\n        resize()\n        move()\n        render()\n    &#125;\n\n    class Oval&#123;\n        resize()\n        move()\n        render()\n    &#125;\n\n    class Group&#123;\n        cmps:List(Component)\n        resize()\n        move()\n        render()\n        add(Component)\n    &#125;\n\n    Component &lt;|-- Shape\n    Component &lt;|-- Group\n    Shape &lt;|-- RoundRect\n    Shape &lt;|-- Oval\n</code></pre>\n<p>这样所有的形状都是Component, 而组也同样是Component, 这也就意味着元素和组有这相同的通讯方式.</p>\n<p>对单一元素进行操作,调用自身的接口方法, 而对组进行操作, 组直接调用自身子元素的对应方法即可, 无论子元素是组还是具体元素.</p>\n<p>也就实现了无论对于单一元素还是元素组合的相同操作模式.</p>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\nfrom enum import Enum\n\n\nclass Excuteable(ABC):\n\n    @abstractmethod\n    def attack(self, target):\n        pass\n\n    @abstractmethod\n    def return_to_base(self):\n        pass\n\n    @abstractmethod\n    def destroy(self):\n        pass\n\n\nclass MarkSeries(Excuteable):\n\n    class Status(Enum):\n        STAND_BY = 1\n        FIGHTING = 2\n        REPAIRING = 3\n        CHARGING = 4\n\n    def __init__(self, name=None):\n        self.name = name or &quot;Mark Prototype&quot;\n        self.attack_power = 100\n        self.heath_point = 1000\n        self.status = MarkSeries.Status.STAND_BY\n        self.weapon = &quot;biu~biu~biu~&quot;\n\n    def attack(self, target):\n        print(\n            f&quot;&#123;self.name&#125; &#123;self.weapon&#125; on `&#123;target&#125;` cause `&#123;self.attack_power&#125;` damage.&quot;)\n\n    def return_to_base(self):\n        print(f&quot;&#123;self.name&#125; is retreat.&quot;)\n\n    def destroy(self):\n        print(f&quot;&#123;self.name&#125; is exploded. peng~&quot;)\n\n\nclass Mark2(MarkSeries):\n\n    def __init__(self):\n        super().__init__(&quot;Mark II&quot;)\n        self.attack_power += 20\n        self.heath_point += 200\n        self.weapon = &quot;kuang~kuang~kuang~&quot;\n\n\nclass Mark3(MarkSeries):\n\n    def __init__(self):\n        super().__init__(&quot;Mark III&quot;)\n        self.attack_power += 50\n        self.heath_point += 500\n        self.weapon = &quot;ka~ka~ka~&quot;\n\n\nclass Formation(Excuteable):\n\n    def __init__(self, *units):\n        self.units = units or []\n\n    def add_unit(self, unit):\n        self.units.append(unit)\n\n    def remove_unit(self, unit):\n        if unit in self.units:\n            self.units.remove(unit)\n\n    def attack(self, target):\n        for unit in self.units:\n            unit.attack(target)\n\n    def return_to_base(self):\n        for unit in self.units:\n            unit.return_to_base()\n\n    def destroy(self):\n        for unit in self.units:\n            unit.destroy()\n\n\nif __name__ == &quot;__main__&quot;:\n    boss = &quot;Thanos&quot;\n    m2 = Mark2()\n    m3 = Mark3()\n\n    m2.attack(boss)\n    m3.attack(boss)\n\n    form = Formation(m2, m3)\n\n    form.attack(boss)\n    form.return_to_base()\n    form.destroy()\n</code></pre>\n"},{"title":"设计模式-备忘录模式","date":"2023-11-19T15:24:28.000Z","mermaid":true,"_content":"\n## 应用场景\n\n主要应用在类似于撤销操作的应用场景之中.\n\n假设存在一个文本编辑器, 要对其编辑历史进行记录, 以实现撤销操作\n\n如果使用简单的设计方法, 可以让编辑器包含一个历史记录字段, 用以储存上一次的内容.\n\n```mermaid\nclassDiagram\n    note \"只能保存一次历史\"\n    class Editor{\n        +String content\n        +String content_history\n        +createHistory()\n        +restore()\n    }\n```\n\n但是问题在于仅能保存一次历史记录. 可以修改成\n\n```mermaid\nclassDiagram\n    note \"通过列表保存数据, 可以保存多次\"\n    class Editor{\n        +String content\n        +List content_history\n        +createHistory()\n        +restore()\n    }\n```\n\n虽然可以保存多次了, 但是本质上来说, 历史记录并不是Editor应该要关心的事.\n\n也就是违反了`SRP(Single Responsibility Principle)`原则.\n\n使用备忘录模式(memento pattern)的方案大致如下:\n\n```mermaid\nclassDiagram\n    Editor ..> EditorState\n    History o-- EditorState\n    class Editor{\n        + String content\n        + createState()\n        + restore(state)\n    }\n\n    class History{\n        + List states\n        + push(state)\n        + pop()\n    }\n\n    class EditorState{\n        + content:String\n    }\n```\n\n* Editor 仅负责处理当前编辑的内容;\n* History 只进行历史数据管理;\n* EditorState 仅保存单词的历史信息\n\npython模拟代码:\n\n```python\nfrom collections import namedtuple\n\nEditorState = namedtuple('EditorState', ['title', 'content'])\n\n\nclass History:\n\n    __history = []\n\n    def push(self, record: EditorState):\n        self.__history.append(record)\n\n    def pop(self):\n        return self.__history.pop()\n\n\nclass Editor:\n\n    def __init__(self, title=None, content=None):\n        self.__title = title\n        self.__content = content\n\n    @property\n    def title(self):\n        return self.__title\n\n    @title.setter\n    def title(self, value):\n        self.__title = value\n\n    @property\n    def content(self):\n        return self.__content\n\n    @content.setter\n    def content(self, value):\n        self.__content = value\n\n    def restore(self, state: EditorState):\n        self.title = state.title\n        self.content = state.content\n\n    def create_state(self):\n        return EditorState(self.title, self.content)\n\n    def __str__(self):\n        return f\"{self.title}:{self.content}\"\n\n\nif __name__ == \"__main__\":\n\n    editor = Editor()\n    history = History()\n\n    editor.title = \"title 1\"\n    editor.content = \"content of editor 1\"\n    history.push(editor.create_state())\n    print(editor)   # title 1:content of editor 1\n\n    editor.title = \"title 2\"\n    editor.content = \"content of editor 2\"\n    history.push(editor.create_state())\n    print(editor)   # title 2:content of editor 2\n\n    editor.title = \"title 3\"\n    editor.content = \"content of editor 3\"\n    print(editor)   # title 3:content of editor 3\n\n    editor.restore(history.pop())\n    print(editor)   # title 2:content of editor 2\n```\n","source":"_posts/design-pattern/design-pattern-memento.md","raw":"---\ntitle: 设计模式-备忘录模式\ndate: 2023-11-19 23:24:28 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n## 应用场景\n\n主要应用在类似于撤销操作的应用场景之中.\n\n假设存在一个文本编辑器, 要对其编辑历史进行记录, 以实现撤销操作\n\n如果使用简单的设计方法, 可以让编辑器包含一个历史记录字段, 用以储存上一次的内容.\n\n```mermaid\nclassDiagram\n    note \"只能保存一次历史\"\n    class Editor{\n        +String content\n        +String content_history\n        +createHistory()\n        +restore()\n    }\n```\n\n但是问题在于仅能保存一次历史记录. 可以修改成\n\n```mermaid\nclassDiagram\n    note \"通过列表保存数据, 可以保存多次\"\n    class Editor{\n        +String content\n        +List content_history\n        +createHistory()\n        +restore()\n    }\n```\n\n虽然可以保存多次了, 但是本质上来说, 历史记录并不是Editor应该要关心的事.\n\n也就是违反了`SRP(Single Responsibility Principle)`原则.\n\n使用备忘录模式(memento pattern)的方案大致如下:\n\n```mermaid\nclassDiagram\n    Editor ..> EditorState\n    History o-- EditorState\n    class Editor{\n        + String content\n        + createState()\n        + restore(state)\n    }\n\n    class History{\n        + List states\n        + push(state)\n        + pop()\n    }\n\n    class EditorState{\n        + content:String\n    }\n```\n\n* Editor 仅负责处理当前编辑的内容;\n* History 只进行历史数据管理;\n* EditorState 仅保存单词的历史信息\n\npython模拟代码:\n\n```python\nfrom collections import namedtuple\n\nEditorState = namedtuple('EditorState', ['title', 'content'])\n\n\nclass History:\n\n    __history = []\n\n    def push(self, record: EditorState):\n        self.__history.append(record)\n\n    def pop(self):\n        return self.__history.pop()\n\n\nclass Editor:\n\n    def __init__(self, title=None, content=None):\n        self.__title = title\n        self.__content = content\n\n    @property\n    def title(self):\n        return self.__title\n\n    @title.setter\n    def title(self, value):\n        self.__title = value\n\n    @property\n    def content(self):\n        return self.__content\n\n    @content.setter\n    def content(self, value):\n        self.__content = value\n\n    def restore(self, state: EditorState):\n        self.title = state.title\n        self.content = state.content\n\n    def create_state(self):\n        return EditorState(self.title, self.content)\n\n    def __str__(self):\n        return f\"{self.title}:{self.content}\"\n\n\nif __name__ == \"__main__\":\n\n    editor = Editor()\n    history = History()\n\n    editor.title = \"title 1\"\n    editor.content = \"content of editor 1\"\n    history.push(editor.create_state())\n    print(editor)   # title 1:content of editor 1\n\n    editor.title = \"title 2\"\n    editor.content = \"content of editor 2\"\n    history.push(editor.create_state())\n    print(editor)   # title 2:content of editor 2\n\n    editor.title = \"title 3\"\n    editor.content = \"content of editor 3\"\n    print(editor)   # title 3:content of editor 3\n\n    editor.restore(history.pop())\n    print(editor)   # title 2:content of editor 2\n```\n","slug":"design-pattern-design-pattern-memento","published":1,"updated":"2023-12-13T08:43:58.098Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v60032i3er6pxt8j3h","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>主要应用在类似于撤销操作的应用场景之中.</p>\n<p>假设存在一个文本编辑器, 要对其编辑历史进行记录, 以实现撤销操作</p>\n<p>如果使用简单的设计方法, 可以让编辑器包含一个历史记录字段, 用以储存上一次的内容.</p>\n<pre><code class=\"mermaid\">classDiagram\n    note &quot;只能保存一次历史&quot;\n    class Editor&#123;\n        +String content\n        +String content_history\n        +createHistory()\n        +restore()\n    &#125;\n</code></pre>\n<p>但是问题在于仅能保存一次历史记录. 可以修改成</p>\n<pre><code class=\"mermaid\">classDiagram\n    note &quot;通过列表保存数据, 可以保存多次&quot;\n    class Editor&#123;\n        +String content\n        +List content_history\n        +createHistory()\n        +restore()\n    &#125;\n</code></pre>\n<p>虽然可以保存多次了, 但是本质上来说, 历史记录并不是Editor应该要关心的事.</p>\n<p>也就是违反了<code>SRP(Single Responsibility Principle)</code>原则.</p>\n<p>使用备忘录模式(memento pattern)的方案大致如下:</p>\n<pre><code class=\"mermaid\">classDiagram\n    Editor ..&gt; EditorState\n    History o-- EditorState\n    class Editor&#123;\n        + String content\n        + createState()\n        + restore(state)\n    &#125;\n\n    class History&#123;\n        + List states\n        + push(state)\n        + pop()\n    &#125;\n\n    class EditorState&#123;\n        + content:String\n    &#125;\n</code></pre>\n<ul>\n<li>Editor 仅负责处理当前编辑的内容;</li>\n<li>History 只进行历史数据管理;</li>\n<li>EditorState 仅保存单词的历史信息</li>\n</ul>\n<p>python模拟代码:</p>\n<pre><code class=\"python\">from collections import namedtuple\n\nEditorState = namedtuple(&#39;EditorState&#39;, [&#39;title&#39;, &#39;content&#39;])\n\n\nclass History:\n\n    __history = []\n\n    def push(self, record: EditorState):\n        self.__history.append(record)\n\n    def pop(self):\n        return self.__history.pop()\n\n\nclass Editor:\n\n    def __init__(self, title=None, content=None):\n        self.__title = title\n        self.__content = content\n\n    @property\n    def title(self):\n        return self.__title\n\n    @title.setter\n    def title(self, value):\n        self.__title = value\n\n    @property\n    def content(self):\n        return self.__content\n\n    @content.setter\n    def content(self, value):\n        self.__content = value\n\n    def restore(self, state: EditorState):\n        self.title = state.title\n        self.content = state.content\n\n    def create_state(self):\n        return EditorState(self.title, self.content)\n\n    def __str__(self):\n        return f&quot;&#123;self.title&#125;:&#123;self.content&#125;&quot;\n\n\nif __name__ == &quot;__main__&quot;:\n\n    editor = Editor()\n    history = History()\n\n    editor.title = &quot;title 1&quot;\n    editor.content = &quot;content of editor 1&quot;\n    history.push(editor.create_state())\n    print(editor)   # title 1:content of editor 1\n\n    editor.title = &quot;title 2&quot;\n    editor.content = &quot;content of editor 2&quot;\n    history.push(editor.create_state())\n    print(editor)   # title 2:content of editor 2\n\n    editor.title = &quot;title 3&quot;\n    editor.content = &quot;content of editor 3&quot;\n    print(editor)   # title 3:content of editor 3\n\n    editor.restore(history.pop())\n    print(editor)   # title 2:content of editor 2\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>主要应用在类似于撤销操作的应用场景之中.</p>\n<p>假设存在一个文本编辑器, 要对其编辑历史进行记录, 以实现撤销操作</p>\n<p>如果使用简单的设计方法, 可以让编辑器包含一个历史记录字段, 用以储存上一次的内容.</p>\n<pre><code class=\"mermaid\">classDiagram\n    note &quot;只能保存一次历史&quot;\n    class Editor&#123;\n        +String content\n        +String content_history\n        +createHistory()\n        +restore()\n    &#125;\n</code></pre>\n<p>但是问题在于仅能保存一次历史记录. 可以修改成</p>\n<pre><code class=\"mermaid\">classDiagram\n    note &quot;通过列表保存数据, 可以保存多次&quot;\n    class Editor&#123;\n        +String content\n        +List content_history\n        +createHistory()\n        +restore()\n    &#125;\n</code></pre>\n<p>虽然可以保存多次了, 但是本质上来说, 历史记录并不是Editor应该要关心的事.</p>\n<p>也就是违反了<code>SRP(Single Responsibility Principle)</code>原则.</p>\n<p>使用备忘录模式(memento pattern)的方案大致如下:</p>\n<pre><code class=\"mermaid\">classDiagram\n    Editor ..&gt; EditorState\n    History o-- EditorState\n    class Editor&#123;\n        + String content\n        + createState()\n        + restore(state)\n    &#125;\n\n    class History&#123;\n        + List states\n        + push(state)\n        + pop()\n    &#125;\n\n    class EditorState&#123;\n        + content:String\n    &#125;\n</code></pre>\n<ul>\n<li>Editor 仅负责处理当前编辑的内容;</li>\n<li>History 只进行历史数据管理;</li>\n<li>EditorState 仅保存单词的历史信息</li>\n</ul>\n<p>python模拟代码:</p>\n<pre><code class=\"python\">from collections import namedtuple\n\nEditorState = namedtuple(&#39;EditorState&#39;, [&#39;title&#39;, &#39;content&#39;])\n\n\nclass History:\n\n    __history = []\n\n    def push(self, record: EditorState):\n        self.__history.append(record)\n\n    def pop(self):\n        return self.__history.pop()\n\n\nclass Editor:\n\n    def __init__(self, title=None, content=None):\n        self.__title = title\n        self.__content = content\n\n    @property\n    def title(self):\n        return self.__title\n\n    @title.setter\n    def title(self, value):\n        self.__title = value\n\n    @property\n    def content(self):\n        return self.__content\n\n    @content.setter\n    def content(self, value):\n        self.__content = value\n\n    def restore(self, state: EditorState):\n        self.title = state.title\n        self.content = state.content\n\n    def create_state(self):\n        return EditorState(self.title, self.content)\n\n    def __str__(self):\n        return f&quot;&#123;self.title&#125;:&#123;self.content&#125;&quot;\n\n\nif __name__ == &quot;__main__&quot;:\n\n    editor = Editor()\n    history = History()\n\n    editor.title = &quot;title 1&quot;\n    editor.content = &quot;content of editor 1&quot;\n    history.push(editor.create_state())\n    print(editor)   # title 1:content of editor 1\n\n    editor.title = &quot;title 2&quot;\n    editor.content = &quot;content of editor 2&quot;\n    history.push(editor.create_state())\n    print(editor)   # title 2:content of editor 2\n\n    editor.title = &quot;title 3&quot;\n    editor.content = &quot;content of editor 3&quot;\n    print(editor)   # title 3:content of editor 3\n\n    editor.restore(history.pop())\n    print(editor)   # title 2:content of editor 2\n</code></pre>\n"},{"title":"设计模式-责任链模式","date":"2023-11-21T07:55:54.000Z","mermaid":true,"_content":"\n## 应用场景\n\n相当于为一项任务创建一条流水线, 类似于django的中间件等功能都是采用责任链模式来完成的.\n\n即接到一个任务时, 不同的对象处理完自己的部分任务, 然后将其交给下一个对象一次处理.\n\n类似于HttpRequest请求, 可能包含:\n\n* 登录验证\n* 权限验证\n* IP验证\n* 一系列验证\n* 处理请求\n* 返回结果\n\n责任链模式的好处在于每一个处理任务之间彼此独立, 相互没有依赖, 可以在不修改硬编码的情况下根据需要自行配置处理流程.\n\n假设用责任链模式完成一个小功能, 计算\n\n```text\ny = (|x|+10)^3/2-1\n```\n\n## 简单的python实现\n\n```python\nimport sys\nfrom importlib import import_module\n\n\ndef get_abs(num):\n    return abs(num)\n\n\ndef plus_ten(num):\n    return num + 10\n\n\ndef power_by_three(num):\n    return num ** 3\n\n\ndef divide_by_two(num):\n    return num / 2\n\n\ndef minus_one(num):\n    return num - 1\n\n\ndef operation_name(name):\n    module_name = __file__.rsplit('.', 1)[0].rsplit('/', 1)[-1]+\".\"\n    return module_name + name\n\n\nOPERATIONS = [\n    operation_name(\"get_abs\"),\n    operation_name(\"plus_ten\"),\n    operation_name(\"power_by_three\"),\n    operation_name(\"divide_by_two\"),\n    operation_name('minus_one')\n]\n\n\ndef cached_import(module_path, class_name):\n    # Check whether module is loaded and fully initialized.\n    if not (\n        (module := sys.modules.get(module_path))\n        and (spec := getattr(module, \"__spec__\", None))\n        and getattr(spec, \"_initializing\", False) is False\n    ):\n        module = import_module(module_path)\n    return getattr(module, class_name)\n\n\ndef import_string(full_path):\n    \"\"\"\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n    \"\"\"\n    try:\n        module_path, class_name = full_path.rsplit(\".\", 1)\n    except ValueError as err:\n        raise ImportError(\"%s doesn't look like a module path\" %\n                          full_path) from err\n\n    try:\n        return cached_import(module_path, class_name)\n    except AttributeError as err:\n        raise ImportError(\n            'Module \"%s\" does not define a \"%s\" attribute/class'\n            % (module_path, class_name)\n        ) from err\n\n\nif __name__ == \"__main__\":\n\n    x = -3\n\n    for opreation in OPERATIONS:\n        f = import_string(opreation)\n        x = f(x)\n\n    print(x)\n```\n\n代码本身...啥也不是...\n\n通过几个相互之间没啥关系, 且功能单一的函数构成了一个责任链, 通过`OPERATIONS`数组保存.\n\n按照数组的顺序遍历, 获取每一步操作, 跟着步骤走.\n\n最终得到正确的计算结果. 责任链模式就算是跑通了.\n\n正常来说, 这个`OPERATIONS`对象肯定是放在类似于`settings.py`一类的配置文件中的.\n\n也就可以方便的通过配置文件来修改程序的流程而不需要重新编码了.\n","source":"_posts/design-pattern/chain-of-responsibility-design-pattern.md","raw":"---\ntitle: 设计模式-责任链模式\ndate: 2023-11-21 15:55:54 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n## 应用场景\n\n相当于为一项任务创建一条流水线, 类似于django的中间件等功能都是采用责任链模式来完成的.\n\n即接到一个任务时, 不同的对象处理完自己的部分任务, 然后将其交给下一个对象一次处理.\n\n类似于HttpRequest请求, 可能包含:\n\n* 登录验证\n* 权限验证\n* IP验证\n* 一系列验证\n* 处理请求\n* 返回结果\n\n责任链模式的好处在于每一个处理任务之间彼此独立, 相互没有依赖, 可以在不修改硬编码的情况下根据需要自行配置处理流程.\n\n假设用责任链模式完成一个小功能, 计算\n\n```text\ny = (|x|+10)^3/2-1\n```\n\n## 简单的python实现\n\n```python\nimport sys\nfrom importlib import import_module\n\n\ndef get_abs(num):\n    return abs(num)\n\n\ndef plus_ten(num):\n    return num + 10\n\n\ndef power_by_three(num):\n    return num ** 3\n\n\ndef divide_by_two(num):\n    return num / 2\n\n\ndef minus_one(num):\n    return num - 1\n\n\ndef operation_name(name):\n    module_name = __file__.rsplit('.', 1)[0].rsplit('/', 1)[-1]+\".\"\n    return module_name + name\n\n\nOPERATIONS = [\n    operation_name(\"get_abs\"),\n    operation_name(\"plus_ten\"),\n    operation_name(\"power_by_three\"),\n    operation_name(\"divide_by_two\"),\n    operation_name('minus_one')\n]\n\n\ndef cached_import(module_path, class_name):\n    # Check whether module is loaded and fully initialized.\n    if not (\n        (module := sys.modules.get(module_path))\n        and (spec := getattr(module, \"__spec__\", None))\n        and getattr(spec, \"_initializing\", False) is False\n    ):\n        module = import_module(module_path)\n    return getattr(module, class_name)\n\n\ndef import_string(full_path):\n    \"\"\"\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n    \"\"\"\n    try:\n        module_path, class_name = full_path.rsplit(\".\", 1)\n    except ValueError as err:\n        raise ImportError(\"%s doesn't look like a module path\" %\n                          full_path) from err\n\n    try:\n        return cached_import(module_path, class_name)\n    except AttributeError as err:\n        raise ImportError(\n            'Module \"%s\" does not define a \"%s\" attribute/class'\n            % (module_path, class_name)\n        ) from err\n\n\nif __name__ == \"__main__\":\n\n    x = -3\n\n    for opreation in OPERATIONS:\n        f = import_string(opreation)\n        x = f(x)\n\n    print(x)\n```\n\n代码本身...啥也不是...\n\n通过几个相互之间没啥关系, 且功能单一的函数构成了一个责任链, 通过`OPERATIONS`数组保存.\n\n按照数组的顺序遍历, 获取每一步操作, 跟着步骤走.\n\n最终得到正确的计算结果. 责任链模式就算是跑通了.\n\n正常来说, 这个`OPERATIONS`对象肯定是放在类似于`settings.py`一类的配置文件中的.\n\n也就可以方便的通过配置文件来修改程序的流程而不需要重新编码了.\n","slug":"design-pattern-chain-of-responsibility-design-pattern","published":1,"updated":"2023-12-13T08:43:58.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v70036i3erfb4salgq","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>相当于为一项任务创建一条流水线, 类似于django的中间件等功能都是采用责任链模式来完成的.</p>\n<p>即接到一个任务时, 不同的对象处理完自己的部分任务, 然后将其交给下一个对象一次处理.</p>\n<p>类似于HttpRequest请求, 可能包含:</p>\n<ul>\n<li>登录验证</li>\n<li>权限验证</li>\n<li>IP验证</li>\n<li>一系列验证</li>\n<li>处理请求</li>\n<li>返回结果</li>\n</ul>\n<p>责任链模式的好处在于每一个处理任务之间彼此独立, 相互没有依赖, 可以在不修改硬编码的情况下根据需要自行配置处理流程.</p>\n<p>假设用责任链模式完成一个小功能, 计算</p>\n<pre><code class=\"text\">y = (|x|+10)^3/2-1\n</code></pre>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">import sys\nfrom importlib import import_module\n\n\ndef get_abs(num):\n    return abs(num)\n\n\ndef plus_ten(num):\n    return num + 10\n\n\ndef power_by_three(num):\n    return num ** 3\n\n\ndef divide_by_two(num):\n    return num / 2\n\n\ndef minus_one(num):\n    return num - 1\n\n\ndef operation_name(name):\n    module_name = __file__.rsplit(&#39;.&#39;, 1)[0].rsplit(&#39;/&#39;, 1)[-1]+&quot;.&quot;\n    return module_name + name\n\n\nOPERATIONS = [\n    operation_name(&quot;get_abs&quot;),\n    operation_name(&quot;plus_ten&quot;),\n    operation_name(&quot;power_by_three&quot;),\n    operation_name(&quot;divide_by_two&quot;),\n    operation_name(&#39;minus_one&#39;)\n]\n\n\ndef cached_import(module_path, class_name):\n    # Check whether module is loaded and fully initialized.\n    if not (\n        (module := sys.modules.get(module_path))\n        and (spec := getattr(module, &quot;__spec__&quot;, None))\n        and getattr(spec, &quot;_initializing&quot;, False) is False\n    ):\n        module = import_module(module_path)\n    return getattr(module, class_name)\n\n\ndef import_string(full_path):\n    &quot;&quot;&quot;\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n    &quot;&quot;&quot;\n    try:\n        module_path, class_name = full_path.rsplit(&quot;.&quot;, 1)\n    except ValueError as err:\n        raise ImportError(&quot;%s doesn&#39;t look like a module path&quot; %\n                          full_path) from err\n\n    try:\n        return cached_import(module_path, class_name)\n    except AttributeError as err:\n        raise ImportError(\n            &#39;Module &quot;%s&quot; does not define a &quot;%s&quot; attribute/class&#39;\n            % (module_path, class_name)\n        ) from err\n\n\nif __name__ == &quot;__main__&quot;:\n\n    x = -3\n\n    for opreation in OPERATIONS:\n        f = import_string(opreation)\n        x = f(x)\n\n    print(x)\n</code></pre>\n<p>代码本身…啥也不是…</p>\n<p>通过几个相互之间没啥关系, 且功能单一的函数构成了一个责任链, 通过<code>OPERATIONS</code>数组保存.</p>\n<p>按照数组的顺序遍历, 获取每一步操作, 跟着步骤走.</p>\n<p>最终得到正确的计算结果. 责任链模式就算是跑通了.</p>\n<p>正常来说, 这个<code>OPERATIONS</code>对象肯定是放在类似于<code>settings.py</code>一类的配置文件中的.</p>\n<p>也就可以方便的通过配置文件来修改程序的流程而不需要重新编码了.</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>相当于为一项任务创建一条流水线, 类似于django的中间件等功能都是采用责任链模式来完成的.</p>\n<p>即接到一个任务时, 不同的对象处理完自己的部分任务, 然后将其交给下一个对象一次处理.</p>\n<p>类似于HttpRequest请求, 可能包含:</p>\n<ul>\n<li>登录验证</li>\n<li>权限验证</li>\n<li>IP验证</li>\n<li>一系列验证</li>\n<li>处理请求</li>\n<li>返回结果</li>\n</ul>\n<p>责任链模式的好处在于每一个处理任务之间彼此独立, 相互没有依赖, 可以在不修改硬编码的情况下根据需要自行配置处理流程.</p>\n<p>假设用责任链模式完成一个小功能, 计算</p>\n<pre><code class=\"text\">y = (|x|+10)^3/2-1\n</code></pre>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">import sys\nfrom importlib import import_module\n\n\ndef get_abs(num):\n    return abs(num)\n\n\ndef plus_ten(num):\n    return num + 10\n\n\ndef power_by_three(num):\n    return num ** 3\n\n\ndef divide_by_two(num):\n    return num / 2\n\n\ndef minus_one(num):\n    return num - 1\n\n\ndef operation_name(name):\n    module_name = __file__.rsplit(&#39;.&#39;, 1)[0].rsplit(&#39;/&#39;, 1)[-1]+&quot;.&quot;\n    return module_name + name\n\n\nOPERATIONS = [\n    operation_name(&quot;get_abs&quot;),\n    operation_name(&quot;plus_ten&quot;),\n    operation_name(&quot;power_by_three&quot;),\n    operation_name(&quot;divide_by_two&quot;),\n    operation_name(&#39;minus_one&#39;)\n]\n\n\ndef cached_import(module_path, class_name):\n    # Check whether module is loaded and fully initialized.\n    if not (\n        (module := sys.modules.get(module_path))\n        and (spec := getattr(module, &quot;__spec__&quot;, None))\n        and getattr(spec, &quot;_initializing&quot;, False) is False\n    ):\n        module = import_module(module_path)\n    return getattr(module, class_name)\n\n\ndef import_string(full_path):\n    &quot;&quot;&quot;\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n    &quot;&quot;&quot;\n    try:\n        module_path, class_name = full_path.rsplit(&quot;.&quot;, 1)\n    except ValueError as err:\n        raise ImportError(&quot;%s doesn&#39;t look like a module path&quot; %\n                          full_path) from err\n\n    try:\n        return cached_import(module_path, class_name)\n    except AttributeError as err:\n        raise ImportError(\n            &#39;Module &quot;%s&quot; does not define a &quot;%s&quot; attribute/class&#39;\n            % (module_path, class_name)\n        ) from err\n\n\nif __name__ == &quot;__main__&quot;:\n\n    x = -3\n\n    for opreation in OPERATIONS:\n        f = import_string(opreation)\n        x = f(x)\n\n    print(x)\n</code></pre>\n<p>代码本身…啥也不是…</p>\n<p>通过几个相互之间没啥关系, 且功能单一的函数构成了一个责任链, 通过<code>OPERATIONS</code>数组保存.</p>\n<p>按照数组的顺序遍历, 获取每一步操作, 跟着步骤走.</p>\n<p>最终得到正确的计算结果. 责任链模式就算是跑通了.</p>\n<p>正常来说, 这个<code>OPERATIONS</code>对象肯定是放在类似于<code>settings.py</code>一类的配置文件中的.</p>\n<p>也就可以方便的通过配置文件来修改程序的流程而不需要重新编码了.</p>\n"},{"title":"设计模式-外观模式","date":"2023-11-22T18:44:11.000Z","mermaid":true,"_content":"\n## 问题描述\n\n假设要实现一个推送消息到用户的功能. 大体流程是:\n\n* 首先需要跟服务器建立连接\n* 检查收否有身份验证的Token\n* 如果没有则要通过授权信息向服务器请求Token. \n* 然后将Token,消息和目标用户的id一同发送给服务器\n* 等待服务器返回发送结果\n* 关闭连接\n\n如下图所示:\n![uml](/assets/img/img_202311230930147088.png)\n\n显然这是一个比较复杂的复杂流程, 没有人会在不同的地方去维护这一堆随时有可能发生变化的方法.\n\n## 解决方案\n\n外观模式便是为了把一些列复杂的操作或者子系统封装为一个统一的对外接口, 使得使用者可以通过简单的操作获得所要的结果. 同时将内部的子系统对其屏蔽, 在子系统进行就该的情况下依然不会影响外部使用.\n\n基本上现在的REST API都属于外观模式的体现.\n\n就像车险经纪人, 那么多条款保项的咱也不懂, 他就把你的信息拿去, 依照他们的保险政策算出一套你能接受的他最赚的保险方案, 然后让你交钱. 告诉你办妥了, 放心开吧!\n\n你猜怎么着? 来年还找你要钱! 又亏了一年~~\n\n## 简单的Python实现\n\n```python\nclass Connection:\n\n    def __init__(self, server):\n        self.__server = server\n\n    def send(self, token, message, *clients):\n        print(f\"TOKEN: {token}\")\n        print(f\"CLIENTS: {clients}\")\n        print(f\"send message: `{message}` to server...\")\n        func = getattr(self.__server, \"_NotificationServer__recive\")\n        func(token, message, *clients)\n\n    def disconnect(self):\n        print(\"disconnect notification server.\")\n\n\nclass NotificationServer:\n\n    def connect(self) -> Connection:\n        conn = Connection(self)\n        return conn\n\n    def authenticate(self, appid, apikey):\n        if appid and apikey:\n            print(\"Authenticated\")\n            return \"SECRET-TOKEN\"\n\n    def __recive(self, token, message, *clients):\n        if token:\n            for client in clients:\n                print(\n                    f\"Server is send message: `{message}` to client: `{client}`\")\n\n\nclass NotificationService:\n\n    def __init__(self):\n        self.__server = NotificationServer()\n        self.__conn = None\n        self.__token = None\n\n    def send(self, message, *clients):\n        self.__setup()\n        self.__conn.send(self.__token, message, *clients)\n        self.__disconnect()\n\n    def __setup(self):\n        self.__create_conn()\n        self.__get_autentication()\n\n    def __disconnect(self):\n        self.__conn.disconnect()\n        self.__conn = None\n\n    def __create_conn(self):\n        if self.__conn is None:\n            print(\">> Connecting to server...\")\n            self.__conn = self.__server.connect()\n            print('>> Connection created.')\n\n    def __get_autentication(self):\n        if self.__token is None:\n            self.__token = self.__server.authenticate(\"appid\", \"apikey\")\n            print(f\">> Get token: `{self.__token}` from server.\")\n\n\nif __name__ == \"__main__\":\n    service = NotificationService()\n    service.send(\"天气不错\", 111, 222, 333)\n\n```\n\n> 为了模拟服务器交互所以在本地做了个Connection和NotificationServer之间的引用.\n>\n> 实际应用中Connection必然是直接与API接口进行交互.\n>\n{: .prompt-info}\n\n最终输出结果:\n\n```bash\n>> Connecting to server...\n>> Connection created.\nAuthenticated\n>> Get token: `SECRET-TOKEN` from server.\nTOKEN: SECRET-TOKEN\nCLIENTS: (111, 222, 333)\nsend message: `天气不错` to server...\nServer is send message: `天气不错` to client: `111`\nServer is send message: `天气不错` to client: `222`\nServer is send message: `天气不错` to client: `333`\ndisconnect notification server.\n```","source":"_posts/design-pattern/facade-design-pattern-demo.md","raw":"---\ntitle: 设计模式-外观模式\ndate: 2023-11-23 02:44:11 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n## 问题描述\n\n假设要实现一个推送消息到用户的功能. 大体流程是:\n\n* 首先需要跟服务器建立连接\n* 检查收否有身份验证的Token\n* 如果没有则要通过授权信息向服务器请求Token. \n* 然后将Token,消息和目标用户的id一同发送给服务器\n* 等待服务器返回发送结果\n* 关闭连接\n\n如下图所示:\n![uml](/assets/img/img_202311230930147088.png)\n\n显然这是一个比较复杂的复杂流程, 没有人会在不同的地方去维护这一堆随时有可能发生变化的方法.\n\n## 解决方案\n\n外观模式便是为了把一些列复杂的操作或者子系统封装为一个统一的对外接口, 使得使用者可以通过简单的操作获得所要的结果. 同时将内部的子系统对其屏蔽, 在子系统进行就该的情况下依然不会影响外部使用.\n\n基本上现在的REST API都属于外观模式的体现.\n\n就像车险经纪人, 那么多条款保项的咱也不懂, 他就把你的信息拿去, 依照他们的保险政策算出一套你能接受的他最赚的保险方案, 然后让你交钱. 告诉你办妥了, 放心开吧!\n\n你猜怎么着? 来年还找你要钱! 又亏了一年~~\n\n## 简单的Python实现\n\n```python\nclass Connection:\n\n    def __init__(self, server):\n        self.__server = server\n\n    def send(self, token, message, *clients):\n        print(f\"TOKEN: {token}\")\n        print(f\"CLIENTS: {clients}\")\n        print(f\"send message: `{message}` to server...\")\n        func = getattr(self.__server, \"_NotificationServer__recive\")\n        func(token, message, *clients)\n\n    def disconnect(self):\n        print(\"disconnect notification server.\")\n\n\nclass NotificationServer:\n\n    def connect(self) -> Connection:\n        conn = Connection(self)\n        return conn\n\n    def authenticate(self, appid, apikey):\n        if appid and apikey:\n            print(\"Authenticated\")\n            return \"SECRET-TOKEN\"\n\n    def __recive(self, token, message, *clients):\n        if token:\n            for client in clients:\n                print(\n                    f\"Server is send message: `{message}` to client: `{client}`\")\n\n\nclass NotificationService:\n\n    def __init__(self):\n        self.__server = NotificationServer()\n        self.__conn = None\n        self.__token = None\n\n    def send(self, message, *clients):\n        self.__setup()\n        self.__conn.send(self.__token, message, *clients)\n        self.__disconnect()\n\n    def __setup(self):\n        self.__create_conn()\n        self.__get_autentication()\n\n    def __disconnect(self):\n        self.__conn.disconnect()\n        self.__conn = None\n\n    def __create_conn(self):\n        if self.__conn is None:\n            print(\">> Connecting to server...\")\n            self.__conn = self.__server.connect()\n            print('>> Connection created.')\n\n    def __get_autentication(self):\n        if self.__token is None:\n            self.__token = self.__server.authenticate(\"appid\", \"apikey\")\n            print(f\">> Get token: `{self.__token}` from server.\")\n\n\nif __name__ == \"__main__\":\n    service = NotificationService()\n    service.send(\"天气不错\", 111, 222, 333)\n\n```\n\n> 为了模拟服务器交互所以在本地做了个Connection和NotificationServer之间的引用.\n>\n> 实际应用中Connection必然是直接与API接口进行交互.\n>\n{: .prompt-info}\n\n最终输出结果:\n\n```bash\n>> Connecting to server...\n>> Connection created.\nAuthenticated\n>> Get token: `SECRET-TOKEN` from server.\nTOKEN: SECRET-TOKEN\nCLIENTS: (111, 222, 333)\nsend message: `天气不错` to server...\nServer is send message: `天气不错` to client: `111`\nServer is send message: `天气不错` to client: `222`\nServer is send message: `天气不错` to client: `333`\ndisconnect notification server.\n```","slug":"design-pattern-facade-design-pattern-demo","published":1,"updated":"2023-12-13T08:43:58.098Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v8003ai3er6sn77efv","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>假设要实现一个推送消息到用户的功能. 大体流程是:</p>\n<ul>\n<li>首先需要跟服务器建立连接</li>\n<li>检查收否有身份验证的Token</li>\n<li>如果没有则要通过授权信息向服务器请求Token. </li>\n<li>然后将Token,消息和目标用户的id一同发送给服务器</li>\n<li>等待服务器返回发送结果</li>\n<li>关闭连接</li>\n</ul>\n<p>如下图所示:<br><img src=\"/assets/img/img_202311230930147088.png\" alt=\"uml\"></p>\n<p>显然这是一个比较复杂的复杂流程, 没有人会在不同的地方去维护这一堆随时有可能发生变化的方法.</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>外观模式便是为了把一些列复杂的操作或者子系统封装为一个统一的对外接口, 使得使用者可以通过简单的操作获得所要的结果. 同时将内部的子系统对其屏蔽, 在子系统进行就该的情况下依然不会影响外部使用.</p>\n<p>基本上现在的REST API都属于外观模式的体现.</p>\n<p>就像车险经纪人, 那么多条款保项的咱也不懂, 他就把你的信息拿去, 依照他们的保险政策算出一套你能接受的他最赚的保险方案, 然后让你交钱. 告诉你办妥了, 放心开吧!</p>\n<p>你猜怎么着? 来年还找你要钱! 又亏了一年~~</p>\n<h2 id=\"简单的Python实现\"><a href=\"#简单的Python实现\" class=\"headerlink\" title=\"简单的Python实现\"></a>简单的Python实现</h2><pre><code class=\"python\">class Connection:\n\n    def __init__(self, server):\n        self.__server = server\n\n    def send(self, token, message, *clients):\n        print(f&quot;TOKEN: &#123;token&#125;&quot;)\n        print(f&quot;CLIENTS: &#123;clients&#125;&quot;)\n        print(f&quot;send message: `&#123;message&#125;` to server...&quot;)\n        func = getattr(self.__server, &quot;_NotificationServer__recive&quot;)\n        func(token, message, *clients)\n\n    def disconnect(self):\n        print(&quot;disconnect notification server.&quot;)\n\n\nclass NotificationServer:\n\n    def connect(self) -&gt; Connection:\n        conn = Connection(self)\n        return conn\n\n    def authenticate(self, appid, apikey):\n        if appid and apikey:\n            print(&quot;Authenticated&quot;)\n            return &quot;SECRET-TOKEN&quot;\n\n    def __recive(self, token, message, *clients):\n        if token:\n            for client in clients:\n                print(\n                    f&quot;Server is send message: `&#123;message&#125;` to client: `&#123;client&#125;`&quot;)\n\n\nclass NotificationService:\n\n    def __init__(self):\n        self.__server = NotificationServer()\n        self.__conn = None\n        self.__token = None\n\n    def send(self, message, *clients):\n        self.__setup()\n        self.__conn.send(self.__token, message, *clients)\n        self.__disconnect()\n\n    def __setup(self):\n        self.__create_conn()\n        self.__get_autentication()\n\n    def __disconnect(self):\n        self.__conn.disconnect()\n        self.__conn = None\n\n    def __create_conn(self):\n        if self.__conn is None:\n            print(&quot;&gt;&gt; Connecting to server...&quot;)\n            self.__conn = self.__server.connect()\n            print(&#39;&gt;&gt; Connection created.&#39;)\n\n    def __get_autentication(self):\n        if self.__token is None:\n            self.__token = self.__server.authenticate(&quot;appid&quot;, &quot;apikey&quot;)\n            print(f&quot;&gt;&gt; Get token: `&#123;self.__token&#125;` from server.&quot;)\n\n\nif __name__ == &quot;__main__&quot;:\n    service = NotificationService()\n    service.send(&quot;天气不错&quot;, 111, 222, 333)\n</code></pre>\n<blockquote>\n<p>为了模拟服务器交互所以在本地做了个Connection和NotificationServer之间的引用.</p>\n<p>实际应用中Connection必然是直接与API接口进行交互.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<p>最终输出结果:</p>\n<pre><code class=\"bash\">&gt;&gt; Connecting to server...\n&gt;&gt; Connection created.\nAuthenticated\n&gt;&gt; Get token: `SECRET-TOKEN` from server.\nTOKEN: SECRET-TOKEN\nCLIENTS: (111, 222, 333)\nsend message: `天气不错` to server...\nServer is send message: `天气不错` to client: `111`\nServer is send message: `天气不错` to client: `222`\nServer is send message: `天气不错` to client: `333`\ndisconnect notification server.\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>假设要实现一个推送消息到用户的功能. 大体流程是:</p>\n<ul>\n<li>首先需要跟服务器建立连接</li>\n<li>检查收否有身份验证的Token</li>\n<li>如果没有则要通过授权信息向服务器请求Token. </li>\n<li>然后将Token,消息和目标用户的id一同发送给服务器</li>\n<li>等待服务器返回发送结果</li>\n<li>关闭连接</li>\n</ul>\n<p>如下图所示:<br><img src=\"/assets/img/img_202311230930147088.png\" alt=\"uml\"></p>\n<p>显然这是一个比较复杂的复杂流程, 没有人会在不同的地方去维护这一堆随时有可能发生变化的方法.</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>外观模式便是为了把一些列复杂的操作或者子系统封装为一个统一的对外接口, 使得使用者可以通过简单的操作获得所要的结果. 同时将内部的子系统对其屏蔽, 在子系统进行就该的情况下依然不会影响外部使用.</p>\n<p>基本上现在的REST API都属于外观模式的体现.</p>\n<p>就像车险经纪人, 那么多条款保项的咱也不懂, 他就把你的信息拿去, 依照他们的保险政策算出一套你能接受的他最赚的保险方案, 然后让你交钱. 告诉你办妥了, 放心开吧!</p>\n<p>你猜怎么着? 来年还找你要钱! 又亏了一年~~</p>\n<h2 id=\"简单的Python实现\"><a href=\"#简单的Python实现\" class=\"headerlink\" title=\"简单的Python实现\"></a>简单的Python实现</h2><pre><code class=\"python\">class Connection:\n\n    def __init__(self, server):\n        self.__server = server\n\n    def send(self, token, message, *clients):\n        print(f&quot;TOKEN: &#123;token&#125;&quot;)\n        print(f&quot;CLIENTS: &#123;clients&#125;&quot;)\n        print(f&quot;send message: `&#123;message&#125;` to server...&quot;)\n        func = getattr(self.__server, &quot;_NotificationServer__recive&quot;)\n        func(token, message, *clients)\n\n    def disconnect(self):\n        print(&quot;disconnect notification server.&quot;)\n\n\nclass NotificationServer:\n\n    def connect(self) -&gt; Connection:\n        conn = Connection(self)\n        return conn\n\n    def authenticate(self, appid, apikey):\n        if appid and apikey:\n            print(&quot;Authenticated&quot;)\n            return &quot;SECRET-TOKEN&quot;\n\n    def __recive(self, token, message, *clients):\n        if token:\n            for client in clients:\n                print(\n                    f&quot;Server is send message: `&#123;message&#125;` to client: `&#123;client&#125;`&quot;)\n\n\nclass NotificationService:\n\n    def __init__(self):\n        self.__server = NotificationServer()\n        self.__conn = None\n        self.__token = None\n\n    def send(self, message, *clients):\n        self.__setup()\n        self.__conn.send(self.__token, message, *clients)\n        self.__disconnect()\n\n    def __setup(self):\n        self.__create_conn()\n        self.__get_autentication()\n\n    def __disconnect(self):\n        self.__conn.disconnect()\n        self.__conn = None\n\n    def __create_conn(self):\n        if self.__conn is None:\n            print(&quot;&gt;&gt; Connecting to server...&quot;)\n            self.__conn = self.__server.connect()\n            print(&#39;&gt;&gt; Connection created.&#39;)\n\n    def __get_autentication(self):\n        if self.__token is None:\n            self.__token = self.__server.authenticate(&quot;appid&quot;, &quot;apikey&quot;)\n            print(f&quot;&gt;&gt; Get token: `&#123;self.__token&#125;` from server.&quot;)\n\n\nif __name__ == &quot;__main__&quot;:\n    service = NotificationService()\n    service.send(&quot;天气不错&quot;, 111, 222, 333)\n</code></pre>\n<blockquote>\n<p>为了模拟服务器交互所以在本地做了个Connection和NotificationServer之间的引用.</p>\n<p>实际应用中Connection必然是直接与API接口进行交互.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<p>最终输出结果:</p>\n<pre><code class=\"bash\">&gt;&gt; Connecting to server...\n&gt;&gt; Connection created.\nAuthenticated\n&gt;&gt; Get token: `SECRET-TOKEN` from server.\nTOKEN: SECRET-TOKEN\nCLIENTS: (111, 222, 333)\nsend message: `天气不错` to server...\nServer is send message: `天气不错` to client: `111`\nServer is send message: `天气不错` to client: `222`\nServer is send message: `天气不错` to client: `333`\ndisconnect notification server.\n</code></pre>\n"},{"title":"设计模式-装饰器模式","date":"2023-11-22T15:27:44.000Z","mermaid":true,"_content":"\n## 问题描述\n\n装饰器是python语言中相当重要的一部分. 但装饰器本身并不是python都有的东西. 只是一种设计模式, 本质上可以由任何语言实现.\n\n假设在`HTMLDocument`类中有一个方法, 可以接收一个文本文本文件, 并用`<div>`标签将其包裹并放在html文件中.\n\n```mermaid\nclassDiagram\n    class HTMLDocument{\n        + insertDivWithText(FileReader)\n    }\n\n    class FileReader{\n        + init(fileName)\n        + getFileText()\n    }\n\n    HTMLDocument *--> FileReader\n```\n\n通过文件操作读取文件名, 获取文件内容, 只要保存的是文本格式的内容都可以进行读取.\n\n也就是说`txt`,`md`,`csv`,又或者`html`文件都可以通过`FileReader`读取.\n\n在调用`insertDivWithText`方法时只需要调用参数`FileReader`对象的`getFileText`方法, 将其用`div`标签包裹然后插入到文件中就可以了.\n\n但实际操作中难免会遇到更为复杂的需求. 比如:\n\n* 把Markdown格式的文本转换为html格式的文本.\n* 将csv文件的内容做成html表格然后放到div中.\n\n如果采用策略模式, 在不修改HTMLDocument的情况下, 可以创建MarkdownReader和CSVReader来解决这个问题.\n\n```mermaid\nclassDiagram\n    class HTMLDocument{\n        + insertDivWithText(FileReader)\n    }\n\n    class FileReader{\n        + init(fileName)\n        + getFileText()\n    }\n\n    class MarkdownReader{\n        + getFileText()\n    }\n\n    class CSVReader{\n        + getFileText()\n    }\n\n\n    HTMLDocument *--> FileReader\n    FileReader <|-- MarkdownReader\n    FileReader <|-- CSVReader\n```\n\n用python简单实现以下当前的描述:\n\n```python\nclass FileReader:\n\n    def __init__(self, file_name):\n        self.file_name = file_name\n\n    def get_file_text(self):\n        return f\"content text of file `{self.file_name}`\"\n\n\nclass HTMLDocument:\n\n    def insert_div_with_text(self, reader: FileReader):\n        print(reader.get_file_text())\n\n\nclass MarkdownReader(FileReader):\n\n    def get_file_text(self):\n        text = super().get_file_text()\n        return f\"html text parsed from text: `{text}` in file `{self.file_name}`\"\n\n\nclass CSVReader(FileReader):\n\n    def get_file_text(self):\n        text = super().get_file_text()\n        return f\"html table parsed from text: `{text}` in file `{self.file_name}`\"\n\n\nif __name__ == \"__main__\":\n    doc = HTMLDocument()\n    md_reader = MarkdownReader('demo.md')\n    doc.insert_div_with_text(md_reader)\n```\n\n现在看来, 从结构上来说是没有问题的, 策略模式可以应对这种变动的需求.\n\n通过FileReader基类或者接口, 进行不同类型文件的扩展, 并重写`get_file_text`方法以获得正确的html字符串就可以了.\n\n假设新增了一个需求:\n\n* 将文本文件中通过base64加密的文本文件解密\n\n问题不大, 我们可以直接添加一个`Base64Reader`来解决问题.\n\n跟着新的需求有来了, base64解密之后的文件是一个markdown格式的文本. 除了解密之外还要把markdown文本转换成带格式的html.\n\n安排, 一个新的类又被扩展出来, `Base64MarkdownReader`.\n\n这时候就已经能够初步看到问题了, 因为在之前的代码中, 已经包含了base64解密的策略, 有了mardown解析的策略, 但是当两个需求合并的时候, 便不得不重新为其编写新的策略.\n\n而这每一次为新策略的编码都是毫无疑问的硬编码. 同时已编码的策略是否常用, 是否还会修改也未尝可知. 显然, 在这种情况下应用策略模式并非为一个很好的选择.\n\n装饰器模式便可以更好的解决这一需求.\n\n## 解决方案\n\n装饰器的本质是通过一个包装类或包装方法进行前置或者后置的操作, 然后调用被包装的对象.\n\n而包装类或包装方法在外观上与被包装对象是一致的, 也就可以自然的融入原有的逻辑之中.\n\n```mermaid\nclassDiagram\n    class HTMLDocument{\n        + insertDivWithText(Reader)\n    }\n\n    class Reader{\n        <<interface>>\n        + getFileText()\n    }\n\n    class FileReader{\n        + init(fileName)\n        + getFileText()\n    }\n\n    class MarkdownDecorator{\n        + getFileText()\n    }\n\n    class CSVDecorator{\n        + getFileText()\n    }\n\n    class DecryptBase64Decorator{\n        + getFileText()\n    }\n\n    class Decorator{\n        + init(Reader)\n        + getFileText()\n    }\n\n\n    HTMLDocument *--> Reader\n\n    Reader <|-- FileReader : 实现类\n    Decorator --> Reader : 接口装饰器\n    Decorator *..> FileReader : 依赖\n    MarkdownDecorator --|> Decorator\n    CSVDecorator --|> Decorator\n    DecryptBase64Decorator --|> Decorator\n```\n\n这时就可以通过装饰器来进行额外的处理, 并根据需求进行不同的组合了:\n\n```python\n\ndoc = HTMLDocument()\nreader = MarkdownDecorator(\n    DecryptBase64Decorator(\n        FileReader('demo.txt')))\n\ndoc.insert_div_with_text(reader)\n```\n\n此时, `HTMLDocument`并不知道装饰器的存在, 对于他来说操作的已然是一个reader.\n\n而`FileReader`也并没有向策略模式一样进行各种扩展.\n\n`Decorator`则是接受一个Reader对象作为初始化参数, 而自己本身也是一个Reader对象. 并且可以作为参数传递给其他的`Decorator`对象.\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass Reader(ABC):\n\n    @abstractmethod\n    def get_file_text(self):\n        pass\n\n\nclass FileReader(Reader):\n\n    def __init__(self, file_name):\n        self.file_name = file_name\n\n    def get_file_text(self):\n        return f\"content text of file `{self.file_name}`\"\n\n\nclass HTMLDocument:\n\n    def insert_div_with_text(self, reader: Reader):\n        print(reader.get_file_text())\n\n\nclass BaseDecorator(Reader):\n\n    def __init__(self, reader: Reader):\n        self.reader = reader\n\n\nclass MarkdownDecorator(BaseDecorator):\n\n    def get_file_text(self):\n        text = self.reader.get_file_text()\n        return f\"html text parsed from text: \\n`{text}`\"\n\n\nclass CSVDecorator(BaseDecorator):\n\n    def get_file_text(self):\n        text = self.reader.get_file_text()\n        return f\"html table parsed from text: \\n`{text}`\"\n\n\nclass DecryptBase64Decorator(BaseDecorator):\n\n    def get_file_text(self):\n        text = self.reader.get_file_text()\n        return f\"decrypt base64 string from text: \\n`{text}`\"\n\n\nif __name__ == \"__main__\":\n    doc = HTMLDocument()\n    decorator_reader = CSVDecorator(\n        DecryptBase64Decorator(\n            FileReader('demo.txt')\n        )\n    )\n\n    doc.insert_div_with_text(decorator_reader)\n```\n\n最终输出结果:\n\n```bash\nhtml table parsed from text: \n`decrypt base64 string from text: \n`content text of file `demo.txt```\n```\n","source":"_posts/design-pattern/decorator-design-pattern-demo.md","raw":"---\ntitle: 设计模式-装饰器模式\ndate: 2023-11-22 23:27:44 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern', ⭐️]\nmermaid: true\n---\n\n## 问题描述\n\n装饰器是python语言中相当重要的一部分. 但装饰器本身并不是python都有的东西. 只是一种设计模式, 本质上可以由任何语言实现.\n\n假设在`HTMLDocument`类中有一个方法, 可以接收一个文本文本文件, 并用`<div>`标签将其包裹并放在html文件中.\n\n```mermaid\nclassDiagram\n    class HTMLDocument{\n        + insertDivWithText(FileReader)\n    }\n\n    class FileReader{\n        + init(fileName)\n        + getFileText()\n    }\n\n    HTMLDocument *--> FileReader\n```\n\n通过文件操作读取文件名, 获取文件内容, 只要保存的是文本格式的内容都可以进行读取.\n\n也就是说`txt`,`md`,`csv`,又或者`html`文件都可以通过`FileReader`读取.\n\n在调用`insertDivWithText`方法时只需要调用参数`FileReader`对象的`getFileText`方法, 将其用`div`标签包裹然后插入到文件中就可以了.\n\n但实际操作中难免会遇到更为复杂的需求. 比如:\n\n* 把Markdown格式的文本转换为html格式的文本.\n* 将csv文件的内容做成html表格然后放到div中.\n\n如果采用策略模式, 在不修改HTMLDocument的情况下, 可以创建MarkdownReader和CSVReader来解决这个问题.\n\n```mermaid\nclassDiagram\n    class HTMLDocument{\n        + insertDivWithText(FileReader)\n    }\n\n    class FileReader{\n        + init(fileName)\n        + getFileText()\n    }\n\n    class MarkdownReader{\n        + getFileText()\n    }\n\n    class CSVReader{\n        + getFileText()\n    }\n\n\n    HTMLDocument *--> FileReader\n    FileReader <|-- MarkdownReader\n    FileReader <|-- CSVReader\n```\n\n用python简单实现以下当前的描述:\n\n```python\nclass FileReader:\n\n    def __init__(self, file_name):\n        self.file_name = file_name\n\n    def get_file_text(self):\n        return f\"content text of file `{self.file_name}`\"\n\n\nclass HTMLDocument:\n\n    def insert_div_with_text(self, reader: FileReader):\n        print(reader.get_file_text())\n\n\nclass MarkdownReader(FileReader):\n\n    def get_file_text(self):\n        text = super().get_file_text()\n        return f\"html text parsed from text: `{text}` in file `{self.file_name}`\"\n\n\nclass CSVReader(FileReader):\n\n    def get_file_text(self):\n        text = super().get_file_text()\n        return f\"html table parsed from text: `{text}` in file `{self.file_name}`\"\n\n\nif __name__ == \"__main__\":\n    doc = HTMLDocument()\n    md_reader = MarkdownReader('demo.md')\n    doc.insert_div_with_text(md_reader)\n```\n\n现在看来, 从结构上来说是没有问题的, 策略模式可以应对这种变动的需求.\n\n通过FileReader基类或者接口, 进行不同类型文件的扩展, 并重写`get_file_text`方法以获得正确的html字符串就可以了.\n\n假设新增了一个需求:\n\n* 将文本文件中通过base64加密的文本文件解密\n\n问题不大, 我们可以直接添加一个`Base64Reader`来解决问题.\n\n跟着新的需求有来了, base64解密之后的文件是一个markdown格式的文本. 除了解密之外还要把markdown文本转换成带格式的html.\n\n安排, 一个新的类又被扩展出来, `Base64MarkdownReader`.\n\n这时候就已经能够初步看到问题了, 因为在之前的代码中, 已经包含了base64解密的策略, 有了mardown解析的策略, 但是当两个需求合并的时候, 便不得不重新为其编写新的策略.\n\n而这每一次为新策略的编码都是毫无疑问的硬编码. 同时已编码的策略是否常用, 是否还会修改也未尝可知. 显然, 在这种情况下应用策略模式并非为一个很好的选择.\n\n装饰器模式便可以更好的解决这一需求.\n\n## 解决方案\n\n装饰器的本质是通过一个包装类或包装方法进行前置或者后置的操作, 然后调用被包装的对象.\n\n而包装类或包装方法在外观上与被包装对象是一致的, 也就可以自然的融入原有的逻辑之中.\n\n```mermaid\nclassDiagram\n    class HTMLDocument{\n        + insertDivWithText(Reader)\n    }\n\n    class Reader{\n        <<interface>>\n        + getFileText()\n    }\n\n    class FileReader{\n        + init(fileName)\n        + getFileText()\n    }\n\n    class MarkdownDecorator{\n        + getFileText()\n    }\n\n    class CSVDecorator{\n        + getFileText()\n    }\n\n    class DecryptBase64Decorator{\n        + getFileText()\n    }\n\n    class Decorator{\n        + init(Reader)\n        + getFileText()\n    }\n\n\n    HTMLDocument *--> Reader\n\n    Reader <|-- FileReader : 实现类\n    Decorator --> Reader : 接口装饰器\n    Decorator *..> FileReader : 依赖\n    MarkdownDecorator --|> Decorator\n    CSVDecorator --|> Decorator\n    DecryptBase64Decorator --|> Decorator\n```\n\n这时就可以通过装饰器来进行额外的处理, 并根据需求进行不同的组合了:\n\n```python\n\ndoc = HTMLDocument()\nreader = MarkdownDecorator(\n    DecryptBase64Decorator(\n        FileReader('demo.txt')))\n\ndoc.insert_div_with_text(reader)\n```\n\n此时, `HTMLDocument`并不知道装饰器的存在, 对于他来说操作的已然是一个reader.\n\n而`FileReader`也并没有向策略模式一样进行各种扩展.\n\n`Decorator`则是接受一个Reader对象作为初始化参数, 而自己本身也是一个Reader对象. 并且可以作为参数传递给其他的`Decorator`对象.\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass Reader(ABC):\n\n    @abstractmethod\n    def get_file_text(self):\n        pass\n\n\nclass FileReader(Reader):\n\n    def __init__(self, file_name):\n        self.file_name = file_name\n\n    def get_file_text(self):\n        return f\"content text of file `{self.file_name}`\"\n\n\nclass HTMLDocument:\n\n    def insert_div_with_text(self, reader: Reader):\n        print(reader.get_file_text())\n\n\nclass BaseDecorator(Reader):\n\n    def __init__(self, reader: Reader):\n        self.reader = reader\n\n\nclass MarkdownDecorator(BaseDecorator):\n\n    def get_file_text(self):\n        text = self.reader.get_file_text()\n        return f\"html text parsed from text: \\n`{text}`\"\n\n\nclass CSVDecorator(BaseDecorator):\n\n    def get_file_text(self):\n        text = self.reader.get_file_text()\n        return f\"html table parsed from text: \\n`{text}`\"\n\n\nclass DecryptBase64Decorator(BaseDecorator):\n\n    def get_file_text(self):\n        text = self.reader.get_file_text()\n        return f\"decrypt base64 string from text: \\n`{text}`\"\n\n\nif __name__ == \"__main__\":\n    doc = HTMLDocument()\n    decorator_reader = CSVDecorator(\n        DecryptBase64Decorator(\n            FileReader('demo.txt')\n        )\n    )\n\n    doc.insert_div_with_text(decorator_reader)\n```\n\n最终输出结果:\n\n```bash\nhtml table parsed from text: \n`decrypt base64 string from text: \n`content text of file `demo.txt```\n```\n","slug":"design-pattern-decorator-design-pattern-demo","published":1,"updated":"2023-12-13T08:43:58.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v8003ei3erfam2gek3","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>装饰器是python语言中相当重要的一部分. 但装饰器本身并不是python都有的东西. 只是一种设计模式, 本质上可以由任何语言实现.</p>\n<p>假设在<code>HTMLDocument</code>类中有一个方法, 可以接收一个文本文本文件, 并用<code>&lt;div&gt;</code>标签将其包裹并放在html文件中.</p>\n<pre><code class=\"mermaid\">classDiagram\n    class HTMLDocument&#123;\n        + insertDivWithText(FileReader)\n    &#125;\n\n    class FileReader&#123;\n        + init(fileName)\n        + getFileText()\n    &#125;\n\n    HTMLDocument *--&gt; FileReader\n</code></pre>\n<p>通过文件操作读取文件名, 获取文件内容, 只要保存的是文本格式的内容都可以进行读取.</p>\n<p>也就是说<code>txt</code>,<code>md</code>,<code>csv</code>,又或者<code>html</code>文件都可以通过<code>FileReader</code>读取.</p>\n<p>在调用<code>insertDivWithText</code>方法时只需要调用参数<code>FileReader</code>对象的<code>getFileText</code>方法, 将其用<code>div</code>标签包裹然后插入到文件中就可以了.</p>\n<p>但实际操作中难免会遇到更为复杂的需求. 比如:</p>\n<ul>\n<li>把Markdown格式的文本转换为html格式的文本.</li>\n<li>将csv文件的内容做成html表格然后放到div中.</li>\n</ul>\n<p>如果采用策略模式, 在不修改HTMLDocument的情况下, 可以创建MarkdownReader和CSVReader来解决这个问题.</p>\n<pre><code class=\"mermaid\">classDiagram\n    class HTMLDocument&#123;\n        + insertDivWithText(FileReader)\n    &#125;\n\n    class FileReader&#123;\n        + init(fileName)\n        + getFileText()\n    &#125;\n\n    class MarkdownReader&#123;\n        + getFileText()\n    &#125;\n\n    class CSVReader&#123;\n        + getFileText()\n    &#125;\n\n\n    HTMLDocument *--&gt; FileReader\n    FileReader &lt;|-- MarkdownReader\n    FileReader &lt;|-- CSVReader\n</code></pre>\n<p>用python简单实现以下当前的描述:</p>\n<pre><code class=\"python\">class FileReader:\n\n    def __init__(self, file_name):\n        self.file_name = file_name\n\n    def get_file_text(self):\n        return f&quot;content text of file `&#123;self.file_name&#125;`&quot;\n\n\nclass HTMLDocument:\n\n    def insert_div_with_text(self, reader: FileReader):\n        print(reader.get_file_text())\n\n\nclass MarkdownReader(FileReader):\n\n    def get_file_text(self):\n        text = super().get_file_text()\n        return f&quot;html text parsed from text: `&#123;text&#125;` in file `&#123;self.file_name&#125;`&quot;\n\n\nclass CSVReader(FileReader):\n\n    def get_file_text(self):\n        text = super().get_file_text()\n        return f&quot;html table parsed from text: `&#123;text&#125;` in file `&#123;self.file_name&#125;`&quot;\n\n\nif __name__ == &quot;__main__&quot;:\n    doc = HTMLDocument()\n    md_reader = MarkdownReader(&#39;demo.md&#39;)\n    doc.insert_div_with_text(md_reader)\n</code></pre>\n<p>现在看来, 从结构上来说是没有问题的, 策略模式可以应对这种变动的需求.</p>\n<p>通过FileReader基类或者接口, 进行不同类型文件的扩展, 并重写<code>get_file_text</code>方法以获得正确的html字符串就可以了.</p>\n<p>假设新增了一个需求:</p>\n<ul>\n<li>将文本文件中通过base64加密的文本文件解密</li>\n</ul>\n<p>问题不大, 我们可以直接添加一个<code>Base64Reader</code>来解决问题.</p>\n<p>跟着新的需求有来了, base64解密之后的文件是一个markdown格式的文本. 除了解密之外还要把markdown文本转换成带格式的html.</p>\n<p>安排, 一个新的类又被扩展出来, <code>Base64MarkdownReader</code>.</p>\n<p>这时候就已经能够初步看到问题了, 因为在之前的代码中, 已经包含了base64解密的策略, 有了mardown解析的策略, 但是当两个需求合并的时候, 便不得不重新为其编写新的策略.</p>\n<p>而这每一次为新策略的编码都是毫无疑问的硬编码. 同时已编码的策略是否常用, 是否还会修改也未尝可知. 显然, 在这种情况下应用策略模式并非为一个很好的选择.</p>\n<p>装饰器模式便可以更好的解决这一需求.</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>装饰器的本质是通过一个包装类或包装方法进行前置或者后置的操作, 然后调用被包装的对象.</p>\n<p>而包装类或包装方法在外观上与被包装对象是一致的, 也就可以自然的融入原有的逻辑之中.</p>\n<pre><code class=\"mermaid\">classDiagram\n    class HTMLDocument&#123;\n        + insertDivWithText(Reader)\n    &#125;\n\n    class Reader&#123;\n        &lt;&lt;interface&gt;&gt;\n        + getFileText()\n    &#125;\n\n    class FileReader&#123;\n        + init(fileName)\n        + getFileText()\n    &#125;\n\n    class MarkdownDecorator&#123;\n        + getFileText()\n    &#125;\n\n    class CSVDecorator&#123;\n        + getFileText()\n    &#125;\n\n    class DecryptBase64Decorator&#123;\n        + getFileText()\n    &#125;\n\n    class Decorator&#123;\n        + init(Reader)\n        + getFileText()\n    &#125;\n\n\n    HTMLDocument *--&gt; Reader\n\n    Reader &lt;|-- FileReader : 实现类\n    Decorator --&gt; Reader : 接口装饰器\n    Decorator *..&gt; FileReader : 依赖\n    MarkdownDecorator --|&gt; Decorator\n    CSVDecorator --|&gt; Decorator\n    DecryptBase64Decorator --|&gt; Decorator\n</code></pre>\n<p>这时就可以通过装饰器来进行额外的处理, 并根据需求进行不同的组合了:</p>\n<pre><code class=\"python\">\ndoc = HTMLDocument()\nreader = MarkdownDecorator(\n    DecryptBase64Decorator(\n        FileReader(&#39;demo.txt&#39;)))\n\ndoc.insert_div_with_text(reader)\n</code></pre>\n<p>此时, <code>HTMLDocument</code>并不知道装饰器的存在, 对于他来说操作的已然是一个reader.</p>\n<p>而<code>FileReader</code>也并没有向策略模式一样进行各种扩展.</p>\n<p><code>Decorator</code>则是接受一个Reader对象作为初始化参数, 而自己本身也是一个Reader对象. 并且可以作为参数传递给其他的<code>Decorator</code>对象.</p>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\n\n\nclass Reader(ABC):\n\n    @abstractmethod\n    def get_file_text(self):\n        pass\n\n\nclass FileReader(Reader):\n\n    def __init__(self, file_name):\n        self.file_name = file_name\n\n    def get_file_text(self):\n        return f&quot;content text of file `&#123;self.file_name&#125;`&quot;\n\n\nclass HTMLDocument:\n\n    def insert_div_with_text(self, reader: Reader):\n        print(reader.get_file_text())\n\n\nclass BaseDecorator(Reader):\n\n    def __init__(self, reader: Reader):\n        self.reader = reader\n\n\nclass MarkdownDecorator(BaseDecorator):\n\n    def get_file_text(self):\n        text = self.reader.get_file_text()\n        return f&quot;html text parsed from text: \\n`&#123;text&#125;`&quot;\n\n\nclass CSVDecorator(BaseDecorator):\n\n    def get_file_text(self):\n        text = self.reader.get_file_text()\n        return f&quot;html table parsed from text: \\n`&#123;text&#125;`&quot;\n\n\nclass DecryptBase64Decorator(BaseDecorator):\n\n    def get_file_text(self):\n        text = self.reader.get_file_text()\n        return f&quot;decrypt base64 string from text: \\n`&#123;text&#125;`&quot;\n\n\nif __name__ == &quot;__main__&quot;:\n    doc = HTMLDocument()\n    decorator_reader = CSVDecorator(\n        DecryptBase64Decorator(\n            FileReader(&#39;demo.txt&#39;)\n        )\n    )\n\n    doc.insert_div_with_text(decorator_reader)\n</code></pre>\n<p>最终输出结果:</p>\n<pre><code class=\"bash\">html table parsed from text: \n`decrypt base64 string from text: \n`content text of file `demo.txt```\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>装饰器是python语言中相当重要的一部分. 但装饰器本身并不是python都有的东西. 只是一种设计模式, 本质上可以由任何语言实现.</p>\n<p>假设在<code>HTMLDocument</code>类中有一个方法, 可以接收一个文本文本文件, 并用<code>&lt;div&gt;</code>标签将其包裹并放在html文件中.</p>\n<pre><code class=\"mermaid\">classDiagram\n    class HTMLDocument&#123;\n        + insertDivWithText(FileReader)\n    &#125;\n\n    class FileReader&#123;\n        + init(fileName)\n        + getFileText()\n    &#125;\n\n    HTMLDocument *--&gt; FileReader\n</code></pre>\n<p>通过文件操作读取文件名, 获取文件内容, 只要保存的是文本格式的内容都可以进行读取.</p>\n<p>也就是说<code>txt</code>,<code>md</code>,<code>csv</code>,又或者<code>html</code>文件都可以通过<code>FileReader</code>读取.</p>\n<p>在调用<code>insertDivWithText</code>方法时只需要调用参数<code>FileReader</code>对象的<code>getFileText</code>方法, 将其用<code>div</code>标签包裹然后插入到文件中就可以了.</p>\n<p>但实际操作中难免会遇到更为复杂的需求. 比如:</p>\n<ul>\n<li>把Markdown格式的文本转换为html格式的文本.</li>\n<li>将csv文件的内容做成html表格然后放到div中.</li>\n</ul>\n<p>如果采用策略模式, 在不修改HTMLDocument的情况下, 可以创建MarkdownReader和CSVReader来解决这个问题.</p>\n<pre><code class=\"mermaid\">classDiagram\n    class HTMLDocument&#123;\n        + insertDivWithText(FileReader)\n    &#125;\n\n    class FileReader&#123;\n        + init(fileName)\n        + getFileText()\n    &#125;\n\n    class MarkdownReader&#123;\n        + getFileText()\n    &#125;\n\n    class CSVReader&#123;\n        + getFileText()\n    &#125;\n\n\n    HTMLDocument *--&gt; FileReader\n    FileReader &lt;|-- MarkdownReader\n    FileReader &lt;|-- CSVReader\n</code></pre>\n<p>用python简单实现以下当前的描述:</p>\n<pre><code class=\"python\">class FileReader:\n\n    def __init__(self, file_name):\n        self.file_name = file_name\n\n    def get_file_text(self):\n        return f&quot;content text of file `&#123;self.file_name&#125;`&quot;\n\n\nclass HTMLDocument:\n\n    def insert_div_with_text(self, reader: FileReader):\n        print(reader.get_file_text())\n\n\nclass MarkdownReader(FileReader):\n\n    def get_file_text(self):\n        text = super().get_file_text()\n        return f&quot;html text parsed from text: `&#123;text&#125;` in file `&#123;self.file_name&#125;`&quot;\n\n\nclass CSVReader(FileReader):\n\n    def get_file_text(self):\n        text = super().get_file_text()\n        return f&quot;html table parsed from text: `&#123;text&#125;` in file `&#123;self.file_name&#125;`&quot;\n\n\nif __name__ == &quot;__main__&quot;:\n    doc = HTMLDocument()\n    md_reader = MarkdownReader(&#39;demo.md&#39;)\n    doc.insert_div_with_text(md_reader)\n</code></pre>\n<p>现在看来, 从结构上来说是没有问题的, 策略模式可以应对这种变动的需求.</p>\n<p>通过FileReader基类或者接口, 进行不同类型文件的扩展, 并重写<code>get_file_text</code>方法以获得正确的html字符串就可以了.</p>\n<p>假设新增了一个需求:</p>\n<ul>\n<li>将文本文件中通过base64加密的文本文件解密</li>\n</ul>\n<p>问题不大, 我们可以直接添加一个<code>Base64Reader</code>来解决问题.</p>\n<p>跟着新的需求有来了, base64解密之后的文件是一个markdown格式的文本. 除了解密之外还要把markdown文本转换成带格式的html.</p>\n<p>安排, 一个新的类又被扩展出来, <code>Base64MarkdownReader</code>.</p>\n<p>这时候就已经能够初步看到问题了, 因为在之前的代码中, 已经包含了base64解密的策略, 有了mardown解析的策略, 但是当两个需求合并的时候, 便不得不重新为其编写新的策略.</p>\n<p>而这每一次为新策略的编码都是毫无疑问的硬编码. 同时已编码的策略是否常用, 是否还会修改也未尝可知. 显然, 在这种情况下应用策略模式并非为一个很好的选择.</p>\n<p>装饰器模式便可以更好的解决这一需求.</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>装饰器的本质是通过一个包装类或包装方法进行前置或者后置的操作, 然后调用被包装的对象.</p>\n<p>而包装类或包装方法在外观上与被包装对象是一致的, 也就可以自然的融入原有的逻辑之中.</p>\n<pre><code class=\"mermaid\">classDiagram\n    class HTMLDocument&#123;\n        + insertDivWithText(Reader)\n    &#125;\n\n    class Reader&#123;\n        &lt;&lt;interface&gt;&gt;\n        + getFileText()\n    &#125;\n\n    class FileReader&#123;\n        + init(fileName)\n        + getFileText()\n    &#125;\n\n    class MarkdownDecorator&#123;\n        + getFileText()\n    &#125;\n\n    class CSVDecorator&#123;\n        + getFileText()\n    &#125;\n\n    class DecryptBase64Decorator&#123;\n        + getFileText()\n    &#125;\n\n    class Decorator&#123;\n        + init(Reader)\n        + getFileText()\n    &#125;\n\n\n    HTMLDocument *--&gt; Reader\n\n    Reader &lt;|-- FileReader : 实现类\n    Decorator --&gt; Reader : 接口装饰器\n    Decorator *..&gt; FileReader : 依赖\n    MarkdownDecorator --|&gt; Decorator\n    CSVDecorator --|&gt; Decorator\n    DecryptBase64Decorator --|&gt; Decorator\n</code></pre>\n<p>这时就可以通过装饰器来进行额外的处理, 并根据需求进行不同的组合了:</p>\n<pre><code class=\"python\">\ndoc = HTMLDocument()\nreader = MarkdownDecorator(\n    DecryptBase64Decorator(\n        FileReader(&#39;demo.txt&#39;)))\n\ndoc.insert_div_with_text(reader)\n</code></pre>\n<p>此时, <code>HTMLDocument</code>并不知道装饰器的存在, 对于他来说操作的已然是一个reader.</p>\n<p>而<code>FileReader</code>也并没有向策略模式一样进行各种扩展.</p>\n<p><code>Decorator</code>则是接受一个Reader对象作为初始化参数, 而自己本身也是一个Reader对象. 并且可以作为参数传递给其他的<code>Decorator</code>对象.</p>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\n\n\nclass Reader(ABC):\n\n    @abstractmethod\n    def get_file_text(self):\n        pass\n\n\nclass FileReader(Reader):\n\n    def __init__(self, file_name):\n        self.file_name = file_name\n\n    def get_file_text(self):\n        return f&quot;content text of file `&#123;self.file_name&#125;`&quot;\n\n\nclass HTMLDocument:\n\n    def insert_div_with_text(self, reader: Reader):\n        print(reader.get_file_text())\n\n\nclass BaseDecorator(Reader):\n\n    def __init__(self, reader: Reader):\n        self.reader = reader\n\n\nclass MarkdownDecorator(BaseDecorator):\n\n    def get_file_text(self):\n        text = self.reader.get_file_text()\n        return f&quot;html text parsed from text: \\n`&#123;text&#125;`&quot;\n\n\nclass CSVDecorator(BaseDecorator):\n\n    def get_file_text(self):\n        text = self.reader.get_file_text()\n        return f&quot;html table parsed from text: \\n`&#123;text&#125;`&quot;\n\n\nclass DecryptBase64Decorator(BaseDecorator):\n\n    def get_file_text(self):\n        text = self.reader.get_file_text()\n        return f&quot;decrypt base64 string from text: \\n`&#123;text&#125;`&quot;\n\n\nif __name__ == &quot;__main__&quot;:\n    doc = HTMLDocument()\n    decorator_reader = CSVDecorator(\n        DecryptBase64Decorator(\n            FileReader(&#39;demo.txt&#39;)\n        )\n    )\n\n    doc.insert_div_with_text(decorator_reader)\n</code></pre>\n<p>最终输出结果:</p>\n<pre><code class=\"bash\">html table parsed from text: \n`decrypt base64 string from text: \n`content text of file `demo.txt```\n</code></pre>\n"},{"title":"设计模式-迭代器模式","date":"2023-11-21T04:53:30.000Z","mermaid":true,"_content":"\n## 应用场景\n\n迭代器用于对数据的遍历. 最主要的作用便是对外界隐藏内部的数据结构和遍历方式, 只需要暴露一个统一的遍历方法, 从而解耦外部对于自身数据结构的依赖. 即便在内部修改数据结构或者实现方式也不会对外部代码产生影响.\n\n假设一个需求, 存在一个数据集, 按照表的形式存储数据. 即包含多行数据, 每行包含数个数据列.\n\n在外部需要对表格内的数据进行遍历. 每次仅获取一个单元格的数据, 从首行首列开始直至最后.\n\n虽然没太大实际意义, 但可以用来掩饰迭代器模式.\n\n## 简单的python实现\n\n```python\nimport random\n\n\nclass DataSource:\n\n    def __init__(self):\n        self.__data = [[random.randint(0, 100)\n                        for _ in range(2)] for _ in range(2)]\n        self.__current_index = 0\n        self.__element_count = self.__count_elements()\n        self.__column_count = len(self.__data[0])\n\n    def has_next(self):\n        return self.__current_index < self.__element_count\n\n    def next(self):\n        x = self.__current_index // self.__column_count\n        y = self.__current_index % self.__column_count\n        self.__current_index += 1\n        return self.__data[x][y]\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.has_next():\n            x = self.__current_index // self.__column_count\n            y = self.__current_index % self.__column_count\n            self.__current_index += 1\n            return self.__data[x][y]\n\n        self.__current_index = 0\n        raise StopIteration\n\n    def __count_elements(self):\n        count = 0\n        for lst in self.__data:\n            count += len(lst)\n        return count\n\n\nif __name__ == \"__main__\":\n    ds = DataSource()\n\n    # 基于`__iter__` 和 `__next__` 两个内置魔术方法实现遍历\n    for n in ds:\n        print(n)\n\n    print(\"---\")\n\n    # 基于两个自定义方法实现遍历\n    while ds.has_next():\n        print(ds.next())\n\n```\n","source":"_posts/design-pattern/iterator-design-pattern-demo.md","raw":"---\ntitle: 设计模式-迭代器模式\ndate: 2023-11-21 12:53:30 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n## 应用场景\n\n迭代器用于对数据的遍历. 最主要的作用便是对外界隐藏内部的数据结构和遍历方式, 只需要暴露一个统一的遍历方法, 从而解耦外部对于自身数据结构的依赖. 即便在内部修改数据结构或者实现方式也不会对外部代码产生影响.\n\n假设一个需求, 存在一个数据集, 按照表的形式存储数据. 即包含多行数据, 每行包含数个数据列.\n\n在外部需要对表格内的数据进行遍历. 每次仅获取一个单元格的数据, 从首行首列开始直至最后.\n\n虽然没太大实际意义, 但可以用来掩饰迭代器模式.\n\n## 简单的python实现\n\n```python\nimport random\n\n\nclass DataSource:\n\n    def __init__(self):\n        self.__data = [[random.randint(0, 100)\n                        for _ in range(2)] for _ in range(2)]\n        self.__current_index = 0\n        self.__element_count = self.__count_elements()\n        self.__column_count = len(self.__data[0])\n\n    def has_next(self):\n        return self.__current_index < self.__element_count\n\n    def next(self):\n        x = self.__current_index // self.__column_count\n        y = self.__current_index % self.__column_count\n        self.__current_index += 1\n        return self.__data[x][y]\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.has_next():\n            x = self.__current_index // self.__column_count\n            y = self.__current_index % self.__column_count\n            self.__current_index += 1\n            return self.__data[x][y]\n\n        self.__current_index = 0\n        raise StopIteration\n\n    def __count_elements(self):\n        count = 0\n        for lst in self.__data:\n            count += len(lst)\n        return count\n\n\nif __name__ == \"__main__\":\n    ds = DataSource()\n\n    # 基于`__iter__` 和 `__next__` 两个内置魔术方法实现遍历\n    for n in ds:\n        print(n)\n\n    print(\"---\")\n\n    # 基于两个自定义方法实现遍历\n    while ds.has_next():\n        print(ds.next())\n\n```\n","slug":"design-pattern-iterator-design-pattern-demo","published":1,"updated":"2023-12-13T08:43:58.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v8003hi3er55ha3e5w","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>迭代器用于对数据的遍历. 最主要的作用便是对外界隐藏内部的数据结构和遍历方式, 只需要暴露一个统一的遍历方法, 从而解耦外部对于自身数据结构的依赖. 即便在内部修改数据结构或者实现方式也不会对外部代码产生影响.</p>\n<p>假设一个需求, 存在一个数据集, 按照表的形式存储数据. 即包含多行数据, 每行包含数个数据列.</p>\n<p>在外部需要对表格内的数据进行遍历. 每次仅获取一个单元格的数据, 从首行首列开始直至最后.</p>\n<p>虽然没太大实际意义, 但可以用来掩饰迭代器模式.</p>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">import random\n\n\nclass DataSource:\n\n    def __init__(self):\n        self.__data = [[random.randint(0, 100)\n                        for _ in range(2)] for _ in range(2)]\n        self.__current_index = 0\n        self.__element_count = self.__count_elements()\n        self.__column_count = len(self.__data[0])\n\n    def has_next(self):\n        return self.__current_index &lt; self.__element_count\n\n    def next(self):\n        x = self.__current_index // self.__column_count\n        y = self.__current_index % self.__column_count\n        self.__current_index += 1\n        return self.__data[x][y]\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.has_next():\n            x = self.__current_index // self.__column_count\n            y = self.__current_index % self.__column_count\n            self.__current_index += 1\n            return self.__data[x][y]\n\n        self.__current_index = 0\n        raise StopIteration\n\n    def __count_elements(self):\n        count = 0\n        for lst in self.__data:\n            count += len(lst)\n        return count\n\n\nif __name__ == &quot;__main__&quot;:\n    ds = DataSource()\n\n    # 基于`__iter__` 和 `__next__` 两个内置魔术方法实现遍历\n    for n in ds:\n        print(n)\n\n    print(&quot;---&quot;)\n\n    # 基于两个自定义方法实现遍历\n    while ds.has_next():\n        print(ds.next())\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>迭代器用于对数据的遍历. 最主要的作用便是对外界隐藏内部的数据结构和遍历方式, 只需要暴露一个统一的遍历方法, 从而解耦外部对于自身数据结构的依赖. 即便在内部修改数据结构或者实现方式也不会对外部代码产生影响.</p>\n<p>假设一个需求, 存在一个数据集, 按照表的形式存储数据. 即包含多行数据, 每行包含数个数据列.</p>\n<p>在外部需要对表格内的数据进行遍历. 每次仅获取一个单元格的数据, 从首行首列开始直至最后.</p>\n<p>虽然没太大实际意义, 但可以用来掩饰迭代器模式.</p>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">import random\n\n\nclass DataSource:\n\n    def __init__(self):\n        self.__data = [[random.randint(0, 100)\n                        for _ in range(2)] for _ in range(2)]\n        self.__current_index = 0\n        self.__element_count = self.__count_elements()\n        self.__column_count = len(self.__data[0])\n\n    def has_next(self):\n        return self.__current_index &lt; self.__element_count\n\n    def next(self):\n        x = self.__current_index // self.__column_count\n        y = self.__current_index % self.__column_count\n        self.__current_index += 1\n        return self.__data[x][y]\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.has_next():\n            x = self.__current_index // self.__column_count\n            y = self.__current_index % self.__column_count\n            self.__current_index += 1\n            return self.__data[x][y]\n\n        self.__current_index = 0\n        raise StopIteration\n\n    def __count_elements(self):\n        count = 0\n        for lst in self.__data:\n            count += len(lst)\n        return count\n\n\nif __name__ == &quot;__main__&quot;:\n    ds = DataSource()\n\n    # 基于`__iter__` 和 `__next__` 两个内置魔术方法实现遍历\n    for n in ds:\n        print(n)\n\n    print(&quot;---&quot;)\n\n    # 基于两个自定义方法实现遍历\n    while ds.has_next():\n        print(ds.next())\n</code></pre>\n"},{"title":"设计模式-观察者模式","date":"2023-11-20T09:17:43.000Z","mermaid":true,"_content":"\n## 应用场景\n\n类似于图表的应用场景, 有一个包含原始数据的表格, 以及一张基于表格内的数据绘制的图表.\n\n当表格内的数据发生变动时, 图表就应该给予数据进行重绘.\n\n观察者模式就是设置一个对原始数据的观察者, 当原始数据发生变动时, 由观察者负责通知所有依赖这些数据运行的其他对象发生了变动以及具体的变动内容.\n\n```mermaid\nclassDiagram\n    note for Subject \"定义添加,删除,通知观察者的方法<br/>在通知方法中遍历所有观察者\"\n    class Subject{\n        + addObserver()\n        + removeObserver()\n        + notifyObservers()\n    }\n\n    class Observer{\n        <<interface>>\n        + update()\n    }\n\n    class ConcreateSubject{\n        + data\n        + getData()\n        + setData()\n    }\n\n    class ConcreateObserver1{\n        + update()\n    }\n\n    class ConcreateObserver2{\n        + update()\n    }\n\n    Subject *--> Observer : 依赖\n    ConcreateObserver1 --|> Observer : 实现接口\n    ConcreateObserver2 --|> Observer : 实现接口\n    ConcreateSubject --|> Subject : 继承\n\n\n```\n\n## 简单的python实现\n\n```python\n\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\n\n\nclass ObserverPayloadTypeKey(Enum):\n    OLD = 1\n    NEW = OLD << 1\n\n    def __or__(self, other):\n        return self.value | other.value\n\n    def __and__(self, other):\n        if isinstance(other, int):\n            return self.value & other\n        return self.value & other.value\n\n\nclass Observer(ABC):\n    @abstractmethod\n    def update(self, key: str, payload):\n        \"\"\"\n        观察者回调函数, 在被观察对象的`key`属性发生变化时调用.\n\n        Args:\n            key: 发生变化的属性名\n            payload: 包含属性变化值的词典, \n            通过`ObserverPayloadTypeKey.OLD`和`ObserverPayloadTypeKey.NEW`获取更新前后的数据.\n        \"\"\"\n\n\ndef notify(payload_type=ObserverPayloadTypeKey.OLD | ObserverPayloadTypeKey.NEW):\n    \"\"\"\n    标记属性为通知属性, 被标记的属性在更新时会自动通知观察者对象. 默认会同时向观察者发送更新前和更新后的数据.\n    观察者对象需要实现`Observer`接口中的的`update(self, key, payload)`方法\n\n    通过`payload[ObserverPayloadTypeKey.NEW]`可以获得更新后的值\n\n\n    Example:\n        @title.setter\n        @notify()\n        def title(self, value):\n            self.__title = value\n\n    Note:\n        需要在@property.setter装饰器之前使用.\n\n    Args:\n        payload_type (ObserverPayloadTypeKey, optional): \n            枚举类型的标记, 用以标记通知发送数据的类型. \n            默认为: `ObserverPayloadTypeKey.OLD | ObserverPayloadTypeKey.NEW`\n            即同时包含修改前后的值.\n    \"\"\"\n    def decorator(func):\n        def warpper(*args, **kwargs):\n            key = func.__name__\n            payload = {ObserverPayloadTypeKey.NEW: args[1]}\n            observers = getattr(args[0], \"_Observable__observers\").items()\n            if ObserverPayloadTypeKey.OLD & payload_type:\n                payload[ObserverPayloadTypeKey.OLD] = getattr(\n                    args[0], key)\n            for ob_key, observer in observers:\n                if ob_key.startswith(key):\n\n                    observer.update(key, payload)\n            func(*args, **kwargs)\n        return warpper\n    return decorator\n\n\nclass Observable:\n    \"\"\"\n    可以被监听的对象, 子类需要显示的的调用父类的构造函数\n        \n        def __init__(self, your, args):\n            super().__init__()\n            # ...\n        \n    通过对属性的setter方法添加装饰器`@notify()`可以在属性更新时通知观察者对象.\n    \"\"\"\n\n    def __init__(self):\n        self.__observers = {}\n\n    def __create_observer_key(self, ob, key):\n        return f\"{key}_{ob.__hash__()}\"\n\n    def add_observer(self, observer: Observer, key: str):\n        observer_key = self.__create_observer_key(observer, key)\n        if observer_key not in self.__observers:\n            self.__observers[observer_key] = observer\n\n    def remove_observer(self, observer: Observer, key: str):\n        observer_key = self.__create_observer_key(observer, key)\n        if observer_key in self.__observers:\n            del self.__observers[observer_key]\n\n\nclass Post(Observable):\n\n    def __init__(self, title, body):\n        super().__init__()\n        self.__title = title\n        self.__body = body\n\n    @property\n    def title(self):\n        return self.__title\n\n    @title.setter\n    @notify()\n    def title(self, value):\n        self.__title = value\n\n    @property\n    def body(self):\n        return self.__body\n\n    @body.setter\n    @notify()\n    def body(self, value):\n        self.__body = value\n\n\nclass PostObserver(Observer):\n\n    def update(self, key, payload):\n        print(f\"Observing Post `{key}` has been changed \")\n        print(f\"\\tfrom: `{payload[ObserverPayloadTypeKey.OLD]}`\")\n        print(f\"\\tto: `{payload[ObserverPayloadTypeKey.NEW]}`.\")\n\n\nif __name__ == \"__main__\":\n    post = Post('title', 'some text')\n    observer = PostObserver()\n    post.add_observer(observer, 'title')\n    post.add_observer(observer, 'body')\n\n    post.title = 'new title'\n    post.body = 'new body'\n```\n\n输出结果:\n```bash\nObserving Post `title` has been changed \n    from: `title`\n    to: `new title`.\nObserving Post `body` has been changed \n    from: `some text`\n    to: `new body`.\n```\n\n## 后记\n\n这个demo算是开始学习设计模式以来写的最耗时的一个了.\n\n虽然通过简单的方法来处理观察者的通知要比这么实现简单的多, 但是同样的, 越简单的实现应用起来就越麻烦.\n\n相比于在每一个属性的`setter`里都要显示的调用通知函数, 一个无需额外操作的装饰器他不香么.\n\n也就因为这一个想法, 溜溜耗了一下午才给这东西折腾完.\n\n但就装饰器的问题都可以单独拿出来做一篇笔记了.\n\n虽然功能算是实现了, 但是肯定还有不完善的地方. 比如一次性为多个属性添加观察者什么的.\n\n姑且留个念想, 放在以后得实际项目里再完善吧.\n","source":"_posts/design-pattern/observer-design-pattern-demo.md","raw":"---\ntitle: 设计模式-观察者模式\ndate: 2023-11-20 17:17:43 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern', ⭐️]\nmermaid: true\n---\n\n## 应用场景\n\n类似于图表的应用场景, 有一个包含原始数据的表格, 以及一张基于表格内的数据绘制的图表.\n\n当表格内的数据发生变动时, 图表就应该给予数据进行重绘.\n\n观察者模式就是设置一个对原始数据的观察者, 当原始数据发生变动时, 由观察者负责通知所有依赖这些数据运行的其他对象发生了变动以及具体的变动内容.\n\n```mermaid\nclassDiagram\n    note for Subject \"定义添加,删除,通知观察者的方法<br/>在通知方法中遍历所有观察者\"\n    class Subject{\n        + addObserver()\n        + removeObserver()\n        + notifyObservers()\n    }\n\n    class Observer{\n        <<interface>>\n        + update()\n    }\n\n    class ConcreateSubject{\n        + data\n        + getData()\n        + setData()\n    }\n\n    class ConcreateObserver1{\n        + update()\n    }\n\n    class ConcreateObserver2{\n        + update()\n    }\n\n    Subject *--> Observer : 依赖\n    ConcreateObserver1 --|> Observer : 实现接口\n    ConcreateObserver2 --|> Observer : 实现接口\n    ConcreateSubject --|> Subject : 继承\n\n\n```\n\n## 简单的python实现\n\n```python\n\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\n\n\nclass ObserverPayloadTypeKey(Enum):\n    OLD = 1\n    NEW = OLD << 1\n\n    def __or__(self, other):\n        return self.value | other.value\n\n    def __and__(self, other):\n        if isinstance(other, int):\n            return self.value & other\n        return self.value & other.value\n\n\nclass Observer(ABC):\n    @abstractmethod\n    def update(self, key: str, payload):\n        \"\"\"\n        观察者回调函数, 在被观察对象的`key`属性发生变化时调用.\n\n        Args:\n            key: 发生变化的属性名\n            payload: 包含属性变化值的词典, \n            通过`ObserverPayloadTypeKey.OLD`和`ObserverPayloadTypeKey.NEW`获取更新前后的数据.\n        \"\"\"\n\n\ndef notify(payload_type=ObserverPayloadTypeKey.OLD | ObserverPayloadTypeKey.NEW):\n    \"\"\"\n    标记属性为通知属性, 被标记的属性在更新时会自动通知观察者对象. 默认会同时向观察者发送更新前和更新后的数据.\n    观察者对象需要实现`Observer`接口中的的`update(self, key, payload)`方法\n\n    通过`payload[ObserverPayloadTypeKey.NEW]`可以获得更新后的值\n\n\n    Example:\n        @title.setter\n        @notify()\n        def title(self, value):\n            self.__title = value\n\n    Note:\n        需要在@property.setter装饰器之前使用.\n\n    Args:\n        payload_type (ObserverPayloadTypeKey, optional): \n            枚举类型的标记, 用以标记通知发送数据的类型. \n            默认为: `ObserverPayloadTypeKey.OLD | ObserverPayloadTypeKey.NEW`\n            即同时包含修改前后的值.\n    \"\"\"\n    def decorator(func):\n        def warpper(*args, **kwargs):\n            key = func.__name__\n            payload = {ObserverPayloadTypeKey.NEW: args[1]}\n            observers = getattr(args[0], \"_Observable__observers\").items()\n            if ObserverPayloadTypeKey.OLD & payload_type:\n                payload[ObserverPayloadTypeKey.OLD] = getattr(\n                    args[0], key)\n            for ob_key, observer in observers:\n                if ob_key.startswith(key):\n\n                    observer.update(key, payload)\n            func(*args, **kwargs)\n        return warpper\n    return decorator\n\n\nclass Observable:\n    \"\"\"\n    可以被监听的对象, 子类需要显示的的调用父类的构造函数\n        \n        def __init__(self, your, args):\n            super().__init__()\n            # ...\n        \n    通过对属性的setter方法添加装饰器`@notify()`可以在属性更新时通知观察者对象.\n    \"\"\"\n\n    def __init__(self):\n        self.__observers = {}\n\n    def __create_observer_key(self, ob, key):\n        return f\"{key}_{ob.__hash__()}\"\n\n    def add_observer(self, observer: Observer, key: str):\n        observer_key = self.__create_observer_key(observer, key)\n        if observer_key not in self.__observers:\n            self.__observers[observer_key] = observer\n\n    def remove_observer(self, observer: Observer, key: str):\n        observer_key = self.__create_observer_key(observer, key)\n        if observer_key in self.__observers:\n            del self.__observers[observer_key]\n\n\nclass Post(Observable):\n\n    def __init__(self, title, body):\n        super().__init__()\n        self.__title = title\n        self.__body = body\n\n    @property\n    def title(self):\n        return self.__title\n\n    @title.setter\n    @notify()\n    def title(self, value):\n        self.__title = value\n\n    @property\n    def body(self):\n        return self.__body\n\n    @body.setter\n    @notify()\n    def body(self, value):\n        self.__body = value\n\n\nclass PostObserver(Observer):\n\n    def update(self, key, payload):\n        print(f\"Observing Post `{key}` has been changed \")\n        print(f\"\\tfrom: `{payload[ObserverPayloadTypeKey.OLD]}`\")\n        print(f\"\\tto: `{payload[ObserverPayloadTypeKey.NEW]}`.\")\n\n\nif __name__ == \"__main__\":\n    post = Post('title', 'some text')\n    observer = PostObserver()\n    post.add_observer(observer, 'title')\n    post.add_observer(observer, 'body')\n\n    post.title = 'new title'\n    post.body = 'new body'\n```\n\n输出结果:\n```bash\nObserving Post `title` has been changed \n    from: `title`\n    to: `new title`.\nObserving Post `body` has been changed \n    from: `some text`\n    to: `new body`.\n```\n\n## 后记\n\n这个demo算是开始学习设计模式以来写的最耗时的一个了.\n\n虽然通过简单的方法来处理观察者的通知要比这么实现简单的多, 但是同样的, 越简单的实现应用起来就越麻烦.\n\n相比于在每一个属性的`setter`里都要显示的调用通知函数, 一个无需额外操作的装饰器他不香么.\n\n也就因为这一个想法, 溜溜耗了一下午才给这东西折腾完.\n\n但就装饰器的问题都可以单独拿出来做一篇笔记了.\n\n虽然功能算是实现了, 但是肯定还有不完善的地方. 比如一次性为多个属性添加观察者什么的.\n\n姑且留个念想, 放在以后得实际项目里再完善吧.\n","slug":"design-pattern-observer-design-pattern-demo","published":1,"updated":"2023-12-13T08:43:58.100Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5v8003ki3er9rty9e6h","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>类似于图表的应用场景, 有一个包含原始数据的表格, 以及一张基于表格内的数据绘制的图表.</p>\n<p>当表格内的数据发生变动时, 图表就应该给予数据进行重绘.</p>\n<p>观察者模式就是设置一个对原始数据的观察者, 当原始数据发生变动时, 由观察者负责通知所有依赖这些数据运行的其他对象发生了变动以及具体的变动内容.</p>\n<pre><code class=\"mermaid\">classDiagram\n    note for Subject &quot;定义添加,删除,通知观察者的方法&lt;br/&gt;在通知方法中遍历所有观察者&quot;\n    class Subject&#123;\n        + addObserver()\n        + removeObserver()\n        + notifyObservers()\n    &#125;\n\n    class Observer&#123;\n        &lt;&lt;interface&gt;&gt;\n        + update()\n    &#125;\n\n    class ConcreateSubject&#123;\n        + data\n        + getData()\n        + setData()\n    &#125;\n\n    class ConcreateObserver1&#123;\n        + update()\n    &#125;\n\n    class ConcreateObserver2&#123;\n        + update()\n    &#125;\n\n    Subject *--&gt; Observer : 依赖\n    ConcreateObserver1 --|&gt; Observer : 实现接口\n    ConcreateObserver2 --|&gt; Observer : 实现接口\n    ConcreateSubject --|&gt; Subject : 继承\n\n</code></pre>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\n\n\nclass ObserverPayloadTypeKey(Enum):\n    OLD = 1\n    NEW = OLD &lt;&lt; 1\n\n    def __or__(self, other):\n        return self.value | other.value\n\n    def __and__(self, other):\n        if isinstance(other, int):\n            return self.value &amp; other\n        return self.value &amp; other.value\n\n\nclass Observer(ABC):\n    @abstractmethod\n    def update(self, key: str, payload):\n        &quot;&quot;&quot;\n        观察者回调函数, 在被观察对象的`key`属性发生变化时调用.\n\n        Args:\n            key: 发生变化的属性名\n            payload: 包含属性变化值的词典, \n            通过`ObserverPayloadTypeKey.OLD`和`ObserverPayloadTypeKey.NEW`获取更新前后的数据.\n        &quot;&quot;&quot;\n\n\ndef notify(payload_type=ObserverPayloadTypeKey.OLD | ObserverPayloadTypeKey.NEW):\n    &quot;&quot;&quot;\n    标记属性为通知属性, 被标记的属性在更新时会自动通知观察者对象. 默认会同时向观察者发送更新前和更新后的数据.\n    观察者对象需要实现`Observer`接口中的的`update(self, key, payload)`方法\n\n    通过`payload[ObserverPayloadTypeKey.NEW]`可以获得更新后的值\n\n\n    Example:\n        @title.setter\n        @notify()\n        def title(self, value):\n            self.__title = value\n\n    Note:\n        需要在@property.setter装饰器之前使用.\n\n    Args:\n        payload_type (ObserverPayloadTypeKey, optional): \n            枚举类型的标记, 用以标记通知发送数据的类型. \n            默认为: `ObserverPayloadTypeKey.OLD | ObserverPayloadTypeKey.NEW`\n            即同时包含修改前后的值.\n    &quot;&quot;&quot;\n    def decorator(func):\n        def warpper(*args, **kwargs):\n            key = func.__name__\n            payload = &#123;ObserverPayloadTypeKey.NEW: args[1]&#125;\n            observers = getattr(args[0], &quot;_Observable__observers&quot;).items()\n            if ObserverPayloadTypeKey.OLD &amp; payload_type:\n                payload[ObserverPayloadTypeKey.OLD] = getattr(\n                    args[0], key)\n            for ob_key, observer in observers:\n                if ob_key.startswith(key):\n\n                    observer.update(key, payload)\n            func(*args, **kwargs)\n        return warpper\n    return decorator\n\n\nclass Observable:\n    &quot;&quot;&quot;\n    可以被监听的对象, 子类需要显示的的调用父类的构造函数\n        \n        def __init__(self, your, args):\n            super().__init__()\n            # ...\n        \n    通过对属性的setter方法添加装饰器`@notify()`可以在属性更新时通知观察者对象.\n    &quot;&quot;&quot;\n\n    def __init__(self):\n        self.__observers = &#123;&#125;\n\n    def __create_observer_key(self, ob, key):\n        return f&quot;&#123;key&#125;_&#123;ob.__hash__()&#125;&quot;\n\n    def add_observer(self, observer: Observer, key: str):\n        observer_key = self.__create_observer_key(observer, key)\n        if observer_key not in self.__observers:\n            self.__observers[observer_key] = observer\n\n    def remove_observer(self, observer: Observer, key: str):\n        observer_key = self.__create_observer_key(observer, key)\n        if observer_key in self.__observers:\n            del self.__observers[observer_key]\n\n\nclass Post(Observable):\n\n    def __init__(self, title, body):\n        super().__init__()\n        self.__title = title\n        self.__body = body\n\n    @property\n    def title(self):\n        return self.__title\n\n    @title.setter\n    @notify()\n    def title(self, value):\n        self.__title = value\n\n    @property\n    def body(self):\n        return self.__body\n\n    @body.setter\n    @notify()\n    def body(self, value):\n        self.__body = value\n\n\nclass PostObserver(Observer):\n\n    def update(self, key, payload):\n        print(f&quot;Observing Post `&#123;key&#125;` has been changed &quot;)\n        print(f&quot;\\tfrom: `&#123;payload[ObserverPayloadTypeKey.OLD]&#125;`&quot;)\n        print(f&quot;\\tto: `&#123;payload[ObserverPayloadTypeKey.NEW]&#125;`.&quot;)\n\n\nif __name__ == &quot;__main__&quot;:\n    post = Post(&#39;title&#39;, &#39;some text&#39;)\n    observer = PostObserver()\n    post.add_observer(observer, &#39;title&#39;)\n    post.add_observer(observer, &#39;body&#39;)\n\n    post.title = &#39;new title&#39;\n    post.body = &#39;new body&#39;\n</code></pre>\n<p>输出结果:</p>\n<pre><code class=\"bash\">Observing Post `title` has been changed \n    from: `title`\n    to: `new title`.\nObserving Post `body` has been changed \n    from: `some text`\n    to: `new body`.\n</code></pre>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>这个demo算是开始学习设计模式以来写的最耗时的一个了.</p>\n<p>虽然通过简单的方法来处理观察者的通知要比这么实现简单的多, 但是同样的, 越简单的实现应用起来就越麻烦.</p>\n<p>相比于在每一个属性的<code>setter</code>里都要显示的调用通知函数, 一个无需额外操作的装饰器他不香么.</p>\n<p>也就因为这一个想法, 溜溜耗了一下午才给这东西折腾完.</p>\n<p>但就装饰器的问题都可以单独拿出来做一篇笔记了.</p>\n<p>虽然功能算是实现了, 但是肯定还有不完善的地方. 比如一次性为多个属性添加观察者什么的.</p>\n<p>姑且留个念想, 放在以后得实际项目里再完善吧.</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>类似于图表的应用场景, 有一个包含原始数据的表格, 以及一张基于表格内的数据绘制的图表.</p>\n<p>当表格内的数据发生变动时, 图表就应该给予数据进行重绘.</p>\n<p>观察者模式就是设置一个对原始数据的观察者, 当原始数据发生变动时, 由观察者负责通知所有依赖这些数据运行的其他对象发生了变动以及具体的变动内容.</p>\n<pre><code class=\"mermaid\">classDiagram\n    note for Subject &quot;定义添加,删除,通知观察者的方法&lt;br/&gt;在通知方法中遍历所有观察者&quot;\n    class Subject&#123;\n        + addObserver()\n        + removeObserver()\n        + notifyObservers()\n    &#125;\n\n    class Observer&#123;\n        &lt;&lt;interface&gt;&gt;\n        + update()\n    &#125;\n\n    class ConcreateSubject&#123;\n        + data\n        + getData()\n        + setData()\n    &#125;\n\n    class ConcreateObserver1&#123;\n        + update()\n    &#125;\n\n    class ConcreateObserver2&#123;\n        + update()\n    &#125;\n\n    Subject *--&gt; Observer : 依赖\n    ConcreateObserver1 --|&gt; Observer : 实现接口\n    ConcreateObserver2 --|&gt; Observer : 实现接口\n    ConcreateSubject --|&gt; Subject : 继承\n\n</code></pre>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\n\n\nclass ObserverPayloadTypeKey(Enum):\n    OLD = 1\n    NEW = OLD &lt;&lt; 1\n\n    def __or__(self, other):\n        return self.value | other.value\n\n    def __and__(self, other):\n        if isinstance(other, int):\n            return self.value &amp; other\n        return self.value &amp; other.value\n\n\nclass Observer(ABC):\n    @abstractmethod\n    def update(self, key: str, payload):\n        &quot;&quot;&quot;\n        观察者回调函数, 在被观察对象的`key`属性发生变化时调用.\n\n        Args:\n            key: 发生变化的属性名\n            payload: 包含属性变化值的词典, \n            通过`ObserverPayloadTypeKey.OLD`和`ObserverPayloadTypeKey.NEW`获取更新前后的数据.\n        &quot;&quot;&quot;\n\n\ndef notify(payload_type=ObserverPayloadTypeKey.OLD | ObserverPayloadTypeKey.NEW):\n    &quot;&quot;&quot;\n    标记属性为通知属性, 被标记的属性在更新时会自动通知观察者对象. 默认会同时向观察者发送更新前和更新后的数据.\n    观察者对象需要实现`Observer`接口中的的`update(self, key, payload)`方法\n\n    通过`payload[ObserverPayloadTypeKey.NEW]`可以获得更新后的值\n\n\n    Example:\n        @title.setter\n        @notify()\n        def title(self, value):\n            self.__title = value\n\n    Note:\n        需要在@property.setter装饰器之前使用.\n\n    Args:\n        payload_type (ObserverPayloadTypeKey, optional): \n            枚举类型的标记, 用以标记通知发送数据的类型. \n            默认为: `ObserverPayloadTypeKey.OLD | ObserverPayloadTypeKey.NEW`\n            即同时包含修改前后的值.\n    &quot;&quot;&quot;\n    def decorator(func):\n        def warpper(*args, **kwargs):\n            key = func.__name__\n            payload = &#123;ObserverPayloadTypeKey.NEW: args[1]&#125;\n            observers = getattr(args[0], &quot;_Observable__observers&quot;).items()\n            if ObserverPayloadTypeKey.OLD &amp; payload_type:\n                payload[ObserverPayloadTypeKey.OLD] = getattr(\n                    args[0], key)\n            for ob_key, observer in observers:\n                if ob_key.startswith(key):\n\n                    observer.update(key, payload)\n            func(*args, **kwargs)\n        return warpper\n    return decorator\n\n\nclass Observable:\n    &quot;&quot;&quot;\n    可以被监听的对象, 子类需要显示的的调用父类的构造函数\n        \n        def __init__(self, your, args):\n            super().__init__()\n            # ...\n        \n    通过对属性的setter方法添加装饰器`@notify()`可以在属性更新时通知观察者对象.\n    &quot;&quot;&quot;\n\n    def __init__(self):\n        self.__observers = &#123;&#125;\n\n    def __create_observer_key(self, ob, key):\n        return f&quot;&#123;key&#125;_&#123;ob.__hash__()&#125;&quot;\n\n    def add_observer(self, observer: Observer, key: str):\n        observer_key = self.__create_observer_key(observer, key)\n        if observer_key not in self.__observers:\n            self.__observers[observer_key] = observer\n\n    def remove_observer(self, observer: Observer, key: str):\n        observer_key = self.__create_observer_key(observer, key)\n        if observer_key in self.__observers:\n            del self.__observers[observer_key]\n\n\nclass Post(Observable):\n\n    def __init__(self, title, body):\n        super().__init__()\n        self.__title = title\n        self.__body = body\n\n    @property\n    def title(self):\n        return self.__title\n\n    @title.setter\n    @notify()\n    def title(self, value):\n        self.__title = value\n\n    @property\n    def body(self):\n        return self.__body\n\n    @body.setter\n    @notify()\n    def body(self, value):\n        self.__body = value\n\n\nclass PostObserver(Observer):\n\n    def update(self, key, payload):\n        print(f&quot;Observing Post `&#123;key&#125;` has been changed &quot;)\n        print(f&quot;\\tfrom: `&#123;payload[ObserverPayloadTypeKey.OLD]&#125;`&quot;)\n        print(f&quot;\\tto: `&#123;payload[ObserverPayloadTypeKey.NEW]&#125;`.&quot;)\n\n\nif __name__ == &quot;__main__&quot;:\n    post = Post(&#39;title&#39;, &#39;some text&#39;)\n    observer = PostObserver()\n    post.add_observer(observer, &#39;title&#39;)\n    post.add_observer(observer, &#39;body&#39;)\n\n    post.title = &#39;new title&#39;\n    post.body = &#39;new body&#39;\n</code></pre>\n<p>输出结果:</p>\n<pre><code class=\"bash\">Observing Post `title` has been changed \n    from: `title`\n    to: `new title`.\nObserving Post `body` has been changed \n    from: `some text`\n    to: `new body`.\n</code></pre>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>这个demo算是开始学习设计模式以来写的最耗时的一个了.</p>\n<p>虽然通过简单的方法来处理观察者的通知要比这么实现简单的多, 但是同样的, 越简单的实现应用起来就越麻烦.</p>\n<p>相比于在每一个属性的<code>setter</code>里都要显示的调用通知函数, 一个无需额外操作的装饰器他不香么.</p>\n<p>也就因为这一个想法, 溜溜耗了一下午才给这东西折腾完.</p>\n<p>但就装饰器的问题都可以单独拿出来做一篇笔记了.</p>\n<p>虽然功能算是实现了, 但是肯定还有不完善的地方. 比如一次性为多个属性添加观察者什么的.</p>\n<p>姑且留个念想, 放在以后得实际项目里再完善吧.</p>\n"},{"title":"设计模式-原型(模板)模式","date":"2023-11-23T23:33:43.000Z","mermaid":true,"_content":"\n## 应用场景\n\n解决对象的复制问题. 比如在Keynote中有一个图形, 通过右键点击菜单选择副本. 就可以直接得到一个一模一样的图形.\n\n直观的来看, 图形应该有很多种, 可以有一个共同的基类. 而副本命令应该根据不同的图形执行不同的操作.\n\n```mermaid\nclassDiagram\n    class Shape{\n        origin\n        border\n        bgcolor\n    }\n\n    class Rectangle{\n        width\n        height\n    }\n\n    class Circle{\n        radius\n    }\n\n    class ContextMenu{\n        + duplicate(Shape)\n    }\n\n    Shape <|-- Rectangle\n    Shape <|-- Circle\n\n    ContextMenu *--> Circle\n    ContextMenu *--> Rectangle\n```\n\n虽然可以通过这个结构实现功能, 但是问题在于, duplicate方法既要判断究竟是什么类型的形状, 还要针对不同的形状实现复制方法.\n\n这就似的维护成本增高了, 新创建一个形状, 就得同步维护duiplicate方法.\n\n而在原型模式中, 则是直接将duplicate方法定义在shape接口中.\n\n```mermaid\nclassDiagram\n    direction LR\n    class Shape{\n        <<interface>>\n        + duplicate()->Shape\n    }\n\n    class BasicShape{\n        origin\n        border\n        bgcolor\n        + duplicate()->Shape\n    }\n\n    class Rectangle{\n        width\n        height\n        + duplicate()->Shape\n    }\n\n    class Circle{\n        radius\n        + duplicate()->Shape\n    }\n\n    class ContextMenu{\n        + duplicate()\n    }\n\n    Shape <|-- BasicShape\n    BasicShape <|-- Circle\n    BasicShape <|-- Rectangle\n\n    ContextMenu *--> Shape\n```\n\n这样一来每个形状各自维护自己的副本方法, 而外部指令不需要关心其内部实现, 只负责与接口交互即可.\n\n本质上来说, 相当于对可能得外部操作通过接口进行了强制要求. 想要成为一个形状, 得先能生成副本.\n\n想当个后端工程师, 得先会几个后台框架, 明白数据库怎么回事, 来了项目才能做出来.\n\n没两句黑话打底那天王山是能随便上的么? 天王盖地虎你要都对不出来, 那就赶紧风紧扯呼吧~\n\n## 简单的python实现\n\n```python\nclass Component(ABC):\n\n    @abstractmethod\n    def duplicate(self):\n        pass\n\n\nclass Shape(Component):\n\n    def __init__(self, origin=Point(0, 0)):\n        self.origin = origin\n\n\nclass Rectangle(Shape):\n\n    def __init__(self, origin=Point(0, 0), width=0, height=0):\n        super().__init__(origin)\n        self.width = width\n        self.height = height\n\n    def duplicate(self):\n        return Rectangle(self.origin, self.width, self.height)\n\n    def __eq__(self, other):\n        if isinstance(other, Rectangle):\n            return (self.origin == other.origin\n                    and self.width == other.width\n                    and self.height == other.height)\n\n\nclass Circle(Shape):\n\n    def __init__(self, origin=Point(0, 0), radius=0):\n        super().__init__(origin)\n        self.radius = radius\n\n    def duplicate(self):\n        return Circle(self.origin, self.radius)\n\n\nclass ContextMenu:\n\n    def __init__(self, context: Component):\n        self.__context = context\n\n    def duplicate(self):\n        return self.__context.duplicate()\n\n\nif __name__ == \"__main__\":\n    rect = Rectangle()\n    menu = ContextMenu(rect)\n    dup_rect = menu.duplicate()\n\n    print(rect)\n    print(dup_rect)\n    print(rect == dup_rect)\n```\n\n输出结果:\n\n```bash\n<__main__.Rectangle object at 0x1005cfb90>\n<__main__.Rectangle object at 0x1005cfbd0>\nTrue\n```\n","source":"_posts/design-pattern/prototype-design-pattern-demo.md","raw":"---\ntitle: 设计模式-原型(模板)模式\ndate: 2023-11-24 07:33:43 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n## 应用场景\n\n解决对象的复制问题. 比如在Keynote中有一个图形, 通过右键点击菜单选择副本. 就可以直接得到一个一模一样的图形.\n\n直观的来看, 图形应该有很多种, 可以有一个共同的基类. 而副本命令应该根据不同的图形执行不同的操作.\n\n```mermaid\nclassDiagram\n    class Shape{\n        origin\n        border\n        bgcolor\n    }\n\n    class Rectangle{\n        width\n        height\n    }\n\n    class Circle{\n        radius\n    }\n\n    class ContextMenu{\n        + duplicate(Shape)\n    }\n\n    Shape <|-- Rectangle\n    Shape <|-- Circle\n\n    ContextMenu *--> Circle\n    ContextMenu *--> Rectangle\n```\n\n虽然可以通过这个结构实现功能, 但是问题在于, duplicate方法既要判断究竟是什么类型的形状, 还要针对不同的形状实现复制方法.\n\n这就似的维护成本增高了, 新创建一个形状, 就得同步维护duiplicate方法.\n\n而在原型模式中, 则是直接将duplicate方法定义在shape接口中.\n\n```mermaid\nclassDiagram\n    direction LR\n    class Shape{\n        <<interface>>\n        + duplicate()->Shape\n    }\n\n    class BasicShape{\n        origin\n        border\n        bgcolor\n        + duplicate()->Shape\n    }\n\n    class Rectangle{\n        width\n        height\n        + duplicate()->Shape\n    }\n\n    class Circle{\n        radius\n        + duplicate()->Shape\n    }\n\n    class ContextMenu{\n        + duplicate()\n    }\n\n    Shape <|-- BasicShape\n    BasicShape <|-- Circle\n    BasicShape <|-- Rectangle\n\n    ContextMenu *--> Shape\n```\n\n这样一来每个形状各自维护自己的副本方法, 而外部指令不需要关心其内部实现, 只负责与接口交互即可.\n\n本质上来说, 相当于对可能得外部操作通过接口进行了强制要求. 想要成为一个形状, 得先能生成副本.\n\n想当个后端工程师, 得先会几个后台框架, 明白数据库怎么回事, 来了项目才能做出来.\n\n没两句黑话打底那天王山是能随便上的么? 天王盖地虎你要都对不出来, 那就赶紧风紧扯呼吧~\n\n## 简单的python实现\n\n```python\nclass Component(ABC):\n\n    @abstractmethod\n    def duplicate(self):\n        pass\n\n\nclass Shape(Component):\n\n    def __init__(self, origin=Point(0, 0)):\n        self.origin = origin\n\n\nclass Rectangle(Shape):\n\n    def __init__(self, origin=Point(0, 0), width=0, height=0):\n        super().__init__(origin)\n        self.width = width\n        self.height = height\n\n    def duplicate(self):\n        return Rectangle(self.origin, self.width, self.height)\n\n    def __eq__(self, other):\n        if isinstance(other, Rectangle):\n            return (self.origin == other.origin\n                    and self.width == other.width\n                    and self.height == other.height)\n\n\nclass Circle(Shape):\n\n    def __init__(self, origin=Point(0, 0), radius=0):\n        super().__init__(origin)\n        self.radius = radius\n\n    def duplicate(self):\n        return Circle(self.origin, self.radius)\n\n\nclass ContextMenu:\n\n    def __init__(self, context: Component):\n        self.__context = context\n\n    def duplicate(self):\n        return self.__context.duplicate()\n\n\nif __name__ == \"__main__\":\n    rect = Rectangle()\n    menu = ContextMenu(rect)\n    dup_rect = menu.duplicate()\n\n    print(rect)\n    print(dup_rect)\n    print(rect == dup_rect)\n```\n\n输出结果:\n\n```bash\n<__main__.Rectangle object at 0x1005cfb90>\n<__main__.Rectangle object at 0x1005cfbd0>\nTrue\n```\n","slug":"design-pattern-prototype-design-pattern-demo","published":1,"updated":"2023-12-13T08:43:58.100Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5vj00bei3er773p8b6s","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>解决对象的复制问题. 比如在Keynote中有一个图形, 通过右键点击菜单选择副本. 就可以直接得到一个一模一样的图形.</p>\n<p>直观的来看, 图形应该有很多种, 可以有一个共同的基类. 而副本命令应该根据不同的图形执行不同的操作.</p>\n<pre><code class=\"mermaid\">classDiagram\n    class Shape&#123;\n        origin\n        border\n        bgcolor\n    &#125;\n\n    class Rectangle&#123;\n        width\n        height\n    &#125;\n\n    class Circle&#123;\n        radius\n    &#125;\n\n    class ContextMenu&#123;\n        + duplicate(Shape)\n    &#125;\n\n    Shape &lt;|-- Rectangle\n    Shape &lt;|-- Circle\n\n    ContextMenu *--&gt; Circle\n    ContextMenu *--&gt; Rectangle\n</code></pre>\n<p>虽然可以通过这个结构实现功能, 但是问题在于, duplicate方法既要判断究竟是什么类型的形状, 还要针对不同的形状实现复制方法.</p>\n<p>这就似的维护成本增高了, 新创建一个形状, 就得同步维护duiplicate方法.</p>\n<p>而在原型模式中, 则是直接将duplicate方法定义在shape接口中.</p>\n<pre><code class=\"mermaid\">classDiagram\n    direction LR\n    class Shape&#123;\n        &lt;&lt;interface&gt;&gt;\n        + duplicate()-&gt;Shape\n    &#125;\n\n    class BasicShape&#123;\n        origin\n        border\n        bgcolor\n        + duplicate()-&gt;Shape\n    &#125;\n\n    class Rectangle&#123;\n        width\n        height\n        + duplicate()-&gt;Shape\n    &#125;\n\n    class Circle&#123;\n        radius\n        + duplicate()-&gt;Shape\n    &#125;\n\n    class ContextMenu&#123;\n        + duplicate()\n    &#125;\n\n    Shape &lt;|-- BasicShape\n    BasicShape &lt;|-- Circle\n    BasicShape &lt;|-- Rectangle\n\n    ContextMenu *--&gt; Shape\n</code></pre>\n<p>这样一来每个形状各自维护自己的副本方法, 而外部指令不需要关心其内部实现, 只负责与接口交互即可.</p>\n<p>本质上来说, 相当于对可能得外部操作通过接口进行了强制要求. 想要成为一个形状, 得先能生成副本.</p>\n<p>想当个后端工程师, 得先会几个后台框架, 明白数据库怎么回事, 来了项目才能做出来.</p>\n<p>没两句黑话打底那天王山是能随便上的么? 天王盖地虎你要都对不出来, 那就赶紧风紧扯呼吧~</p>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">class Component(ABC):\n\n    @abstractmethod\n    def duplicate(self):\n        pass\n\n\nclass Shape(Component):\n\n    def __init__(self, origin=Point(0, 0)):\n        self.origin = origin\n\n\nclass Rectangle(Shape):\n\n    def __init__(self, origin=Point(0, 0), width=0, height=0):\n        super().__init__(origin)\n        self.width = width\n        self.height = height\n\n    def duplicate(self):\n        return Rectangle(self.origin, self.width, self.height)\n\n    def __eq__(self, other):\n        if isinstance(other, Rectangle):\n            return (self.origin == other.origin\n                    and self.width == other.width\n                    and self.height == other.height)\n\n\nclass Circle(Shape):\n\n    def __init__(self, origin=Point(0, 0), radius=0):\n        super().__init__(origin)\n        self.radius = radius\n\n    def duplicate(self):\n        return Circle(self.origin, self.radius)\n\n\nclass ContextMenu:\n\n    def __init__(self, context: Component):\n        self.__context = context\n\n    def duplicate(self):\n        return self.__context.duplicate()\n\n\nif __name__ == &quot;__main__&quot;:\n    rect = Rectangle()\n    menu = ContextMenu(rect)\n    dup_rect = menu.duplicate()\n\n    print(rect)\n    print(dup_rect)\n    print(rect == dup_rect)\n</code></pre>\n<p>输出结果:</p>\n<pre><code class=\"bash\">&lt;__main__.Rectangle object at 0x1005cfb90&gt;\n&lt;__main__.Rectangle object at 0x1005cfbd0&gt;\nTrue\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>解决对象的复制问题. 比如在Keynote中有一个图形, 通过右键点击菜单选择副本. 就可以直接得到一个一模一样的图形.</p>\n<p>直观的来看, 图形应该有很多种, 可以有一个共同的基类. 而副本命令应该根据不同的图形执行不同的操作.</p>\n<pre><code class=\"mermaid\">classDiagram\n    class Shape&#123;\n        origin\n        border\n        bgcolor\n    &#125;\n\n    class Rectangle&#123;\n        width\n        height\n    &#125;\n\n    class Circle&#123;\n        radius\n    &#125;\n\n    class ContextMenu&#123;\n        + duplicate(Shape)\n    &#125;\n\n    Shape &lt;|-- Rectangle\n    Shape &lt;|-- Circle\n\n    ContextMenu *--&gt; Circle\n    ContextMenu *--&gt; Rectangle\n</code></pre>\n<p>虽然可以通过这个结构实现功能, 但是问题在于, duplicate方法既要判断究竟是什么类型的形状, 还要针对不同的形状实现复制方法.</p>\n<p>这就似的维护成本增高了, 新创建一个形状, 就得同步维护duiplicate方法.</p>\n<p>而在原型模式中, 则是直接将duplicate方法定义在shape接口中.</p>\n<pre><code class=\"mermaid\">classDiagram\n    direction LR\n    class Shape&#123;\n        &lt;&lt;interface&gt;&gt;\n        + duplicate()-&gt;Shape\n    &#125;\n\n    class BasicShape&#123;\n        origin\n        border\n        bgcolor\n        + duplicate()-&gt;Shape\n    &#125;\n\n    class Rectangle&#123;\n        width\n        height\n        + duplicate()-&gt;Shape\n    &#125;\n\n    class Circle&#123;\n        radius\n        + duplicate()-&gt;Shape\n    &#125;\n\n    class ContextMenu&#123;\n        + duplicate()\n    &#125;\n\n    Shape &lt;|-- BasicShape\n    BasicShape &lt;|-- Circle\n    BasicShape &lt;|-- Rectangle\n\n    ContextMenu *--&gt; Shape\n</code></pre>\n<p>这样一来每个形状各自维护自己的副本方法, 而外部指令不需要关心其内部实现, 只负责与接口交互即可.</p>\n<p>本质上来说, 相当于对可能得外部操作通过接口进行了强制要求. 想要成为一个形状, 得先能生成副本.</p>\n<p>想当个后端工程师, 得先会几个后台框架, 明白数据库怎么回事, 来了项目才能做出来.</p>\n<p>没两句黑话打底那天王山是能随便上的么? 天王盖地虎你要都对不出来, 那就赶紧风紧扯呼吧~</p>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">class Component(ABC):\n\n    @abstractmethod\n    def duplicate(self):\n        pass\n\n\nclass Shape(Component):\n\n    def __init__(self, origin=Point(0, 0)):\n        self.origin = origin\n\n\nclass Rectangle(Shape):\n\n    def __init__(self, origin=Point(0, 0), width=0, height=0):\n        super().__init__(origin)\n        self.width = width\n        self.height = height\n\n    def duplicate(self):\n        return Rectangle(self.origin, self.width, self.height)\n\n    def __eq__(self, other):\n        if isinstance(other, Rectangle):\n            return (self.origin == other.origin\n                    and self.width == other.width\n                    and self.height == other.height)\n\n\nclass Circle(Shape):\n\n    def __init__(self, origin=Point(0, 0), radius=0):\n        super().__init__(origin)\n        self.radius = radius\n\n    def duplicate(self):\n        return Circle(self.origin, self.radius)\n\n\nclass ContextMenu:\n\n    def __init__(self, context: Component):\n        self.__context = context\n\n    def duplicate(self):\n        return self.__context.duplicate()\n\n\nif __name__ == &quot;__main__&quot;:\n    rect = Rectangle()\n    menu = ContextMenu(rect)\n    dup_rect = menu.duplicate()\n\n    print(rect)\n    print(dup_rect)\n    print(rect == dup_rect)\n</code></pre>\n<p>输出结果:</p>\n<pre><code class=\"bash\">&lt;__main__.Rectangle object at 0x1005cfb90&gt;\n&lt;__main__.Rectangle object at 0x1005cfbd0&gt;\nTrue\n</code></pre>\n"},{"title":"设计模式-享元模式","date":"2023-11-23T11:24:38.000Z","mermaid":true,"_content":"\n也叫轻量级模式, 轻量模式.\n\n## 问题描述\n\n属于概念比较好理解的模式. 核心思想就是把高内存占用的只读资源共享, 使其能够在多个位置进行重用.\n\n在不重用的情况下, 每个元素独占一个图片资源, 当重复元素变多就会由于系统资源不足而崩溃.\n\n最常见的属于各类App中的图片素材, 比如按钮底图, 占位符图片. 比较形象的就是扫雷游戏里那一屏幕密密麻麻的方块图片.\n\n## 简单的python实现\n\n```python\nfrom pathlib import Path\nfrom enum import Enum\nimport tracemalloc\n\n\nclass Point:\n\n    def __init__(self, x, y, icon):\n        self.x = x\n        self.y = y\n        self.icon = icon\n\n    def draw(self):\n        print(f\">> draw point at: ({self.x},{self.y}) with image:{self.icon}\")\n\n\nclass IconType(Enum):\n    RED = 1\n    GREEN = 2\n    BLUE = 3\n\n\nclass PointIcon:\n\n    def __init__(self, icon_type, path):\n        self.icon_type = icon_type\n        if path:\n            self.icon = Path(path).read_bytes()\n\n\nclass IconFactory:\n\n    __singleton = None\n\n    def __init__(self):\n        self.__icons = {}\n        IconFactory.__singleton = self\n\n    @staticmethod\n    def instance():\n        if IconFactory.__singleton is None:\n            IconFactory.__singleton = IconFactory()\n\n        return IconFactory.__singleton\n\n    def get_icon(self, icon_type, path):\n        # key = f\"icon-type-{icon_type.name}-{icon_type.__hash__()}\"\n        if icon_type in self.__icons:\n            return self.__icons[icon_type]\n\n        self.__icons[icon_type] = Path(path).read_bytes()\n\n\nif __name__ == \"__main__\":\n\n    def test_for_100_points():\n        # pathlib.py:1051: size=8941 KiB, count=100, average=89.4 KiB\n        # flyweight_pattern.py:44: size=24.8 KiB, count=401, average=63 B\n        # pathlib.py:508: size=48 B, count=1, average=48 B\n        tracemalloc.start()\n\n        points = [Point(i, i, PointIcon(IconType.RED, \"temp.jpg\"))\n                  for i in range(0, 100)]\n\n        snapshot = tracemalloc.take_snapshot()\n        stats = snapshot.statistics('lineno')\n\n        for stat in stats:\n            result = str(stat).rsplit('/', 1)[-1]\n            print(result)\n\n        tracemalloc.stop()\n\n    def test_for_100_points_with_flyweight():\n        tracemalloc.start()\n\n        icon = IconFactory.instance().get_icon(IconType.RED, \"temp.jpg\")\n        points = [Point(i, i, icon) for i in range(0, 100)]\n\n        snapshot = tracemalloc.take_snapshot()\n        stats = snapshot.statistics('lineno')\n\n        for stat in stats:\n            result = str(stat).rsplit('/', 1)[-1]\n            print(result)\n\n        tracemalloc.stop()\n\ntest_for_100_points()\nprint('---')\ntest_for_100_points_with_flyweight()\n```\n\n最终输出结果:\n\n```bash\npathlib.py:1051: size=8941 KiB, count=100, average=89.4 KiB\nflyweight_pattern.py:71: size=24.8 KiB, count=401, average=63 B\nflyweight_pattern.py:37: size=48 B, count=1, average=48 B\npathlib.py:508: size=48 B, count=1, average=48 B\n---\npathlib.py:1051: size=89.4 KiB, count=1, average=89.4 KiB\nflyweight_pattern.py:87: size=10.2 KiB, count=201, average=52 B\nflyweight_pattern.py:51: size=320 B, count=2, average=160 B\nflyweight_pattern.py:60: size=160 B, count=1, average=160 B\n```\n","source":"_posts/design-pattern/flyweight-design-pattern-demo.md","raw":"---\ntitle: 设计模式-享元模式\ndate: 2023-11-23 19:24:38 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n也叫轻量级模式, 轻量模式.\n\n## 问题描述\n\n属于概念比较好理解的模式. 核心思想就是把高内存占用的只读资源共享, 使其能够在多个位置进行重用.\n\n在不重用的情况下, 每个元素独占一个图片资源, 当重复元素变多就会由于系统资源不足而崩溃.\n\n最常见的属于各类App中的图片素材, 比如按钮底图, 占位符图片. 比较形象的就是扫雷游戏里那一屏幕密密麻麻的方块图片.\n\n## 简单的python实现\n\n```python\nfrom pathlib import Path\nfrom enum import Enum\nimport tracemalloc\n\n\nclass Point:\n\n    def __init__(self, x, y, icon):\n        self.x = x\n        self.y = y\n        self.icon = icon\n\n    def draw(self):\n        print(f\">> draw point at: ({self.x},{self.y}) with image:{self.icon}\")\n\n\nclass IconType(Enum):\n    RED = 1\n    GREEN = 2\n    BLUE = 3\n\n\nclass PointIcon:\n\n    def __init__(self, icon_type, path):\n        self.icon_type = icon_type\n        if path:\n            self.icon = Path(path).read_bytes()\n\n\nclass IconFactory:\n\n    __singleton = None\n\n    def __init__(self):\n        self.__icons = {}\n        IconFactory.__singleton = self\n\n    @staticmethod\n    def instance():\n        if IconFactory.__singleton is None:\n            IconFactory.__singleton = IconFactory()\n\n        return IconFactory.__singleton\n\n    def get_icon(self, icon_type, path):\n        # key = f\"icon-type-{icon_type.name}-{icon_type.__hash__()}\"\n        if icon_type in self.__icons:\n            return self.__icons[icon_type]\n\n        self.__icons[icon_type] = Path(path).read_bytes()\n\n\nif __name__ == \"__main__\":\n\n    def test_for_100_points():\n        # pathlib.py:1051: size=8941 KiB, count=100, average=89.4 KiB\n        # flyweight_pattern.py:44: size=24.8 KiB, count=401, average=63 B\n        # pathlib.py:508: size=48 B, count=1, average=48 B\n        tracemalloc.start()\n\n        points = [Point(i, i, PointIcon(IconType.RED, \"temp.jpg\"))\n                  for i in range(0, 100)]\n\n        snapshot = tracemalloc.take_snapshot()\n        stats = snapshot.statistics('lineno')\n\n        for stat in stats:\n            result = str(stat).rsplit('/', 1)[-1]\n            print(result)\n\n        tracemalloc.stop()\n\n    def test_for_100_points_with_flyweight():\n        tracemalloc.start()\n\n        icon = IconFactory.instance().get_icon(IconType.RED, \"temp.jpg\")\n        points = [Point(i, i, icon) for i in range(0, 100)]\n\n        snapshot = tracemalloc.take_snapshot()\n        stats = snapshot.statistics('lineno')\n\n        for stat in stats:\n            result = str(stat).rsplit('/', 1)[-1]\n            print(result)\n\n        tracemalloc.stop()\n\ntest_for_100_points()\nprint('---')\ntest_for_100_points_with_flyweight()\n```\n\n最终输出结果:\n\n```bash\npathlib.py:1051: size=8941 KiB, count=100, average=89.4 KiB\nflyweight_pattern.py:71: size=24.8 KiB, count=401, average=63 B\nflyweight_pattern.py:37: size=48 B, count=1, average=48 B\npathlib.py:508: size=48 B, count=1, average=48 B\n---\npathlib.py:1051: size=89.4 KiB, count=1, average=89.4 KiB\nflyweight_pattern.py:87: size=10.2 KiB, count=201, average=52 B\nflyweight_pattern.py:51: size=320 B, count=2, average=160 B\nflyweight_pattern.py:60: size=160 B, count=1, average=160 B\n```\n","slug":"design-pattern-flyweight-design-pattern-demo","published":1,"updated":"2023-12-13T08:43:58.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5vj00bfi3er5gc6bdja","content":"<p>也叫轻量级模式, 轻量模式.</p>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>属于概念比较好理解的模式. 核心思想就是把高内存占用的只读资源共享, 使其能够在多个位置进行重用.</p>\n<p>在不重用的情况下, 每个元素独占一个图片资源, 当重复元素变多就会由于系统资源不足而崩溃.</p>\n<p>最常见的属于各类App中的图片素材, 比如按钮底图, 占位符图片. 比较形象的就是扫雷游戏里那一屏幕密密麻麻的方块图片.</p>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from pathlib import Path\nfrom enum import Enum\nimport tracemalloc\n\n\nclass Point:\n\n    def __init__(self, x, y, icon):\n        self.x = x\n        self.y = y\n        self.icon = icon\n\n    def draw(self):\n        print(f&quot;&gt;&gt; draw point at: (&#123;self.x&#125;,&#123;self.y&#125;) with image:&#123;self.icon&#125;&quot;)\n\n\nclass IconType(Enum):\n    RED = 1\n    GREEN = 2\n    BLUE = 3\n\n\nclass PointIcon:\n\n    def __init__(self, icon_type, path):\n        self.icon_type = icon_type\n        if path:\n            self.icon = Path(path).read_bytes()\n\n\nclass IconFactory:\n\n    __singleton = None\n\n    def __init__(self):\n        self.__icons = &#123;&#125;\n        IconFactory.__singleton = self\n\n    @staticmethod\n    def instance():\n        if IconFactory.__singleton is None:\n            IconFactory.__singleton = IconFactory()\n\n        return IconFactory.__singleton\n\n    def get_icon(self, icon_type, path):\n        # key = f&quot;icon-type-&#123;icon_type.name&#125;-&#123;icon_type.__hash__()&#125;&quot;\n        if icon_type in self.__icons:\n            return self.__icons[icon_type]\n\n        self.__icons[icon_type] = Path(path).read_bytes()\n\n\nif __name__ == &quot;__main__&quot;:\n\n    def test_for_100_points():\n        # pathlib.py:1051: size=8941 KiB, count=100, average=89.4 KiB\n        # flyweight_pattern.py:44: size=24.8 KiB, count=401, average=63 B\n        # pathlib.py:508: size=48 B, count=1, average=48 B\n        tracemalloc.start()\n\n        points = [Point(i, i, PointIcon(IconType.RED, &quot;temp.jpg&quot;))\n                  for i in range(0, 100)]\n\n        snapshot = tracemalloc.take_snapshot()\n        stats = snapshot.statistics(&#39;lineno&#39;)\n\n        for stat in stats:\n            result = str(stat).rsplit(&#39;/&#39;, 1)[-1]\n            print(result)\n\n        tracemalloc.stop()\n\n    def test_for_100_points_with_flyweight():\n        tracemalloc.start()\n\n        icon = IconFactory.instance().get_icon(IconType.RED, &quot;temp.jpg&quot;)\n        points = [Point(i, i, icon) for i in range(0, 100)]\n\n        snapshot = tracemalloc.take_snapshot()\n        stats = snapshot.statistics(&#39;lineno&#39;)\n\n        for stat in stats:\n            result = str(stat).rsplit(&#39;/&#39;, 1)[-1]\n            print(result)\n\n        tracemalloc.stop()\n\ntest_for_100_points()\nprint(&#39;---&#39;)\ntest_for_100_points_with_flyweight()\n</code></pre>\n<p>最终输出结果:</p>\n<pre><code class=\"bash\">pathlib.py:1051: size=8941 KiB, count=100, average=89.4 KiB\nflyweight_pattern.py:71: size=24.8 KiB, count=401, average=63 B\nflyweight_pattern.py:37: size=48 B, count=1, average=48 B\npathlib.py:508: size=48 B, count=1, average=48 B\n---\npathlib.py:1051: size=89.4 KiB, count=1, average=89.4 KiB\nflyweight_pattern.py:87: size=10.2 KiB, count=201, average=52 B\nflyweight_pattern.py:51: size=320 B, count=2, average=160 B\nflyweight_pattern.py:60: size=160 B, count=1, average=160 B\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<p>也叫轻量级模式, 轻量模式.</p>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>属于概念比较好理解的模式. 核心思想就是把高内存占用的只读资源共享, 使其能够在多个位置进行重用.</p>\n<p>在不重用的情况下, 每个元素独占一个图片资源, 当重复元素变多就会由于系统资源不足而崩溃.</p>\n<p>最常见的属于各类App中的图片素材, 比如按钮底图, 占位符图片. 比较形象的就是扫雷游戏里那一屏幕密密麻麻的方块图片.</p>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from pathlib import Path\nfrom enum import Enum\nimport tracemalloc\n\n\nclass Point:\n\n    def __init__(self, x, y, icon):\n        self.x = x\n        self.y = y\n        self.icon = icon\n\n    def draw(self):\n        print(f&quot;&gt;&gt; draw point at: (&#123;self.x&#125;,&#123;self.y&#125;) with image:&#123;self.icon&#125;&quot;)\n\n\nclass IconType(Enum):\n    RED = 1\n    GREEN = 2\n    BLUE = 3\n\n\nclass PointIcon:\n\n    def __init__(self, icon_type, path):\n        self.icon_type = icon_type\n        if path:\n            self.icon = Path(path).read_bytes()\n\n\nclass IconFactory:\n\n    __singleton = None\n\n    def __init__(self):\n        self.__icons = &#123;&#125;\n        IconFactory.__singleton = self\n\n    @staticmethod\n    def instance():\n        if IconFactory.__singleton is None:\n            IconFactory.__singleton = IconFactory()\n\n        return IconFactory.__singleton\n\n    def get_icon(self, icon_type, path):\n        # key = f&quot;icon-type-&#123;icon_type.name&#125;-&#123;icon_type.__hash__()&#125;&quot;\n        if icon_type in self.__icons:\n            return self.__icons[icon_type]\n\n        self.__icons[icon_type] = Path(path).read_bytes()\n\n\nif __name__ == &quot;__main__&quot;:\n\n    def test_for_100_points():\n        # pathlib.py:1051: size=8941 KiB, count=100, average=89.4 KiB\n        # flyweight_pattern.py:44: size=24.8 KiB, count=401, average=63 B\n        # pathlib.py:508: size=48 B, count=1, average=48 B\n        tracemalloc.start()\n\n        points = [Point(i, i, PointIcon(IconType.RED, &quot;temp.jpg&quot;))\n                  for i in range(0, 100)]\n\n        snapshot = tracemalloc.take_snapshot()\n        stats = snapshot.statistics(&#39;lineno&#39;)\n\n        for stat in stats:\n            result = str(stat).rsplit(&#39;/&#39;, 1)[-1]\n            print(result)\n\n        tracemalloc.stop()\n\n    def test_for_100_points_with_flyweight():\n        tracemalloc.start()\n\n        icon = IconFactory.instance().get_icon(IconType.RED, &quot;temp.jpg&quot;)\n        points = [Point(i, i, icon) for i in range(0, 100)]\n\n        snapshot = tracemalloc.take_snapshot()\n        stats = snapshot.statistics(&#39;lineno&#39;)\n\n        for stat in stats:\n            result = str(stat).rsplit(&#39;/&#39;, 1)[-1]\n            print(result)\n\n        tracemalloc.stop()\n\ntest_for_100_points()\nprint(&#39;---&#39;)\ntest_for_100_points_with_flyweight()\n</code></pre>\n<p>最终输出结果:</p>\n<pre><code class=\"bash\">pathlib.py:1051: size=8941 KiB, count=100, average=89.4 KiB\nflyweight_pattern.py:71: size=24.8 KiB, count=401, average=63 B\nflyweight_pattern.py:37: size=48 B, count=1, average=48 B\npathlib.py:508: size=48 B, count=1, average=48 B\n---\npathlib.py:1051: size=89.4 KiB, count=1, average=89.4 KiB\nflyweight_pattern.py:87: size=10.2 KiB, count=201, average=52 B\nflyweight_pattern.py:51: size=320 B, count=2, average=160 B\nflyweight_pattern.py:60: size=160 B, count=1, average=160 B\n</code></pre>\n"},{"title":"设计模式-工厂方法模式","date":"2023-11-24T07:53:48.000Z","mermaid":true,"_content":"\n> Defer the creation of an object to sub classes.\n>\n> 推迟子类中某个对象的创建时间.\n>\n{: .prompt-info}\n\n这是在设计模式中对工厂方法模式的定位说明.\n\n简单来说, 工厂方法的用法是定义一个接口, 其实现提供某些基类需要的功能. 基类通过工厂方法获得这一接口的实例, 而子类则可以重写该方法以选择其他的实例.\n\n举一个汽车的例子. 奔驰有自己的原厂车, 但是子品牌AMG就提供性能更强的版本.\n\n```mermaid\nclassDiagram\n    direction LR\n    class Engine{\n        <<interface>>\n        + powerOutput()\n    }\n    class Benz{\n        <<interface>>\n        + speedup()\n        + useEngine()->Engine\n    }\n    class BenzE300L{\n        + speedup()\n        + useEngine()\n    }\n    class BenzAMGE53{\n        + speedup()\n        + useEngine()\n    }\n    class L420TEngine{\n        + powerOutput()\n    }\n    class L630TEngine{\n        + powerOutput()\n    }\n\n    Benz *--> Engine\n    Benz <|-- BenzE300L\n    Benz <|-- BenzAMGE53\n\n    Engine <|-- L420TEngine\n    Engine <|-- L630TEngine\n\n    BenzE300L *--> L420TEngine\n    BenzAMGE53 *--> L630TEngine\n```\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass Engine(ABC):\n\n    @abstractmethod\n    def power_output(self):\n        pass\n\n\nclass L420TEngine(Engine):\n\n    def power_output(self):\n        return 258\n\n\nclass L630TEngine(Engine):\n\n    def power_output(self):\n        return 435\n\n\nclass Benz(ABC):\n\n    def speed_up(self):\n        horsepower = self._use_engine().power_output()\n        t = 100/(10.6+(horsepower-258)*12.2/177)\n        print(f'With {horsepower}hp, 0-100km need {round(t, 2)} seconds.')\n\n    @abstractmethod\n    def _use_engine(self):\n        pass\n\n\nclass BenzE300L(Benz):\n\n    def _use_engine(self):\n        return L420TEngine()\n\n\nclass BenzAMGE53(Benz):\n\n    def _use_engine(self):\n        return L630TEngine()\n\n\nif __name__ == \"__main__\":\n\n    e300 = BenzE300L()\n    e300.speed_up()\n    amg = BenzAMGE53()\n    amg.speed_up()\n```\n\nBenz作为一个抽象类, 实现了大部分的逻辑, 同时把变量部分抽象为接口, 也就是示例中的Engine.\n\n`_use_engine`则扮演了工厂方法角色, 通过该方法返回一个参与业务逻辑所需要的对象.\n\n由于这个对象是`Engine`的实现类, 只需要扩展其他的实现就可以使业务逻辑得到不同的结果.\n\n两个具体车型的子类则是继承自`Benz`抽象类, 重写其工厂方法, 返回其他的实例, 便完成了新的扩展.\n\n> 很多对工厂方法的示例是通过一个工厂对象的静态方法返回一个对象.\n>\n> 那就是用错了...\n>\n> 只要工厂在扩展, 工厂类就需要一直维护, 变的越来越臃肿.\n>\n> 而调用工厂的特定方法也是需要硬编码, 最终变成两边维护.\n>\n{: .prompt-info}\n\n> **工厂方法是通过继承和重写来快速实现对不同组合的扩展**\n>\n{: .prompt-tip}\n","source":"_posts/design-pattern/factory-method-design-pattern-demo.md","raw":"---\ntitle: 设计模式-工厂方法模式\ndate: 2023-11-24 15:53:48 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern', ⭐️]\nmermaid: true\n---\n\n> Defer the creation of an object to sub classes.\n>\n> 推迟子类中某个对象的创建时间.\n>\n{: .prompt-info}\n\n这是在设计模式中对工厂方法模式的定位说明.\n\n简单来说, 工厂方法的用法是定义一个接口, 其实现提供某些基类需要的功能. 基类通过工厂方法获得这一接口的实例, 而子类则可以重写该方法以选择其他的实例.\n\n举一个汽车的例子. 奔驰有自己的原厂车, 但是子品牌AMG就提供性能更强的版本.\n\n```mermaid\nclassDiagram\n    direction LR\n    class Engine{\n        <<interface>>\n        + powerOutput()\n    }\n    class Benz{\n        <<interface>>\n        + speedup()\n        + useEngine()->Engine\n    }\n    class BenzE300L{\n        + speedup()\n        + useEngine()\n    }\n    class BenzAMGE53{\n        + speedup()\n        + useEngine()\n    }\n    class L420TEngine{\n        + powerOutput()\n    }\n    class L630TEngine{\n        + powerOutput()\n    }\n\n    Benz *--> Engine\n    Benz <|-- BenzE300L\n    Benz <|-- BenzAMGE53\n\n    Engine <|-- L420TEngine\n    Engine <|-- L630TEngine\n\n    BenzE300L *--> L420TEngine\n    BenzAMGE53 *--> L630TEngine\n```\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass Engine(ABC):\n\n    @abstractmethod\n    def power_output(self):\n        pass\n\n\nclass L420TEngine(Engine):\n\n    def power_output(self):\n        return 258\n\n\nclass L630TEngine(Engine):\n\n    def power_output(self):\n        return 435\n\n\nclass Benz(ABC):\n\n    def speed_up(self):\n        horsepower = self._use_engine().power_output()\n        t = 100/(10.6+(horsepower-258)*12.2/177)\n        print(f'With {horsepower}hp, 0-100km need {round(t, 2)} seconds.')\n\n    @abstractmethod\n    def _use_engine(self):\n        pass\n\n\nclass BenzE300L(Benz):\n\n    def _use_engine(self):\n        return L420TEngine()\n\n\nclass BenzAMGE53(Benz):\n\n    def _use_engine(self):\n        return L630TEngine()\n\n\nif __name__ == \"__main__\":\n\n    e300 = BenzE300L()\n    e300.speed_up()\n    amg = BenzAMGE53()\n    amg.speed_up()\n```\n\nBenz作为一个抽象类, 实现了大部分的逻辑, 同时把变量部分抽象为接口, 也就是示例中的Engine.\n\n`_use_engine`则扮演了工厂方法角色, 通过该方法返回一个参与业务逻辑所需要的对象.\n\n由于这个对象是`Engine`的实现类, 只需要扩展其他的实现就可以使业务逻辑得到不同的结果.\n\n两个具体车型的子类则是继承自`Benz`抽象类, 重写其工厂方法, 返回其他的实例, 便完成了新的扩展.\n\n> 很多对工厂方法的示例是通过一个工厂对象的静态方法返回一个对象.\n>\n> 那就是用错了...\n>\n> 只要工厂在扩展, 工厂类就需要一直维护, 变的越来越臃肿.\n>\n> 而调用工厂的特定方法也是需要硬编码, 最终变成两边维护.\n>\n{: .prompt-info}\n\n> **工厂方法是通过继承和重写来快速实现对不同组合的扩展**\n>\n{: .prompt-tip}\n","slug":"design-pattern-factory-method-design-pattern-demo","published":1,"updated":"2023-12-13T08:43:58.098Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5vj00bhi3erfmdhblyj","content":"<blockquote>\n<p>Defer the creation of an object to sub classes.</p>\n<p>推迟子类中某个对象的创建时间.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<p>这是在设计模式中对工厂方法模式的定位说明.</p>\n<p>简单来说, 工厂方法的用法是定义一个接口, 其实现提供某些基类需要的功能. 基类通过工厂方法获得这一接口的实例, 而子类则可以重写该方法以选择其他的实例.</p>\n<p>举一个汽车的例子. 奔驰有自己的原厂车, 但是子品牌AMG就提供性能更强的版本.</p>\n<pre><code class=\"mermaid\">classDiagram\n    direction LR\n    class Engine&#123;\n        &lt;&lt;interface&gt;&gt;\n        + powerOutput()\n    &#125;\n    class Benz&#123;\n        &lt;&lt;interface&gt;&gt;\n        + speedup()\n        + useEngine()-&gt;Engine\n    &#125;\n    class BenzE300L&#123;\n        + speedup()\n        + useEngine()\n    &#125;\n    class BenzAMGE53&#123;\n        + speedup()\n        + useEngine()\n    &#125;\n    class L420TEngine&#123;\n        + powerOutput()\n    &#125;\n    class L630TEngine&#123;\n        + powerOutput()\n    &#125;\n\n    Benz *--&gt; Engine\n    Benz &lt;|-- BenzE300L\n    Benz &lt;|-- BenzAMGE53\n\n    Engine &lt;|-- L420TEngine\n    Engine &lt;|-- L630TEngine\n\n    BenzE300L *--&gt; L420TEngine\n    BenzAMGE53 *--&gt; L630TEngine\n</code></pre>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\n\n\nclass Engine(ABC):\n\n    @abstractmethod\n    def power_output(self):\n        pass\n\n\nclass L420TEngine(Engine):\n\n    def power_output(self):\n        return 258\n\n\nclass L630TEngine(Engine):\n\n    def power_output(self):\n        return 435\n\n\nclass Benz(ABC):\n\n    def speed_up(self):\n        horsepower = self._use_engine().power_output()\n        t = 100/(10.6+(horsepower-258)*12.2/177)\n        print(f&#39;With &#123;horsepower&#125;hp, 0-100km need &#123;round(t, 2)&#125; seconds.&#39;)\n\n    @abstractmethod\n    def _use_engine(self):\n        pass\n\n\nclass BenzE300L(Benz):\n\n    def _use_engine(self):\n        return L420TEngine()\n\n\nclass BenzAMGE53(Benz):\n\n    def _use_engine(self):\n        return L630TEngine()\n\n\nif __name__ == &quot;__main__&quot;:\n\n    e300 = BenzE300L()\n    e300.speed_up()\n    amg = BenzAMGE53()\n    amg.speed_up()\n</code></pre>\n<p>Benz作为一个抽象类, 实现了大部分的逻辑, 同时把变量部分抽象为接口, 也就是示例中的Engine.</p>\n<p><code>_use_engine</code>则扮演了工厂方法角色, 通过该方法返回一个参与业务逻辑所需要的对象.</p>\n<p>由于这个对象是<code>Engine</code>的实现类, 只需要扩展其他的实现就可以使业务逻辑得到不同的结果.</p>\n<p>两个具体车型的子类则是继承自<code>Benz</code>抽象类, 重写其工厂方法, 返回其他的实例, 便完成了新的扩展.</p>\n<blockquote>\n<p>很多对工厂方法的示例是通过一个工厂对象的静态方法返回一个对象.</p>\n<p>那就是用错了…</p>\n<p>只要工厂在扩展, 工厂类就需要一直维护, 变的越来越臃肿.</p>\n<p>而调用工厂的特定方法也是需要硬编码, 最终变成两边维护.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<blockquote>\n<p><strong>工厂方法是通过继承和重写来快速实现对不同组合的扩展</strong></p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<blockquote>\n<p>Defer the creation of an object to sub classes.</p>\n<p>推迟子类中某个对象的创建时间.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<p>这是在设计模式中对工厂方法模式的定位说明.</p>\n<p>简单来说, 工厂方法的用法是定义一个接口, 其实现提供某些基类需要的功能. 基类通过工厂方法获得这一接口的实例, 而子类则可以重写该方法以选择其他的实例.</p>\n<p>举一个汽车的例子. 奔驰有自己的原厂车, 但是子品牌AMG就提供性能更强的版本.</p>\n<pre><code class=\"mermaid\">classDiagram\n    direction LR\n    class Engine&#123;\n        &lt;&lt;interface&gt;&gt;\n        + powerOutput()\n    &#125;\n    class Benz&#123;\n        &lt;&lt;interface&gt;&gt;\n        + speedup()\n        + useEngine()-&gt;Engine\n    &#125;\n    class BenzE300L&#123;\n        + speedup()\n        + useEngine()\n    &#125;\n    class BenzAMGE53&#123;\n        + speedup()\n        + useEngine()\n    &#125;\n    class L420TEngine&#123;\n        + powerOutput()\n    &#125;\n    class L630TEngine&#123;\n        + powerOutput()\n    &#125;\n\n    Benz *--&gt; Engine\n    Benz &lt;|-- BenzE300L\n    Benz &lt;|-- BenzAMGE53\n\n    Engine &lt;|-- L420TEngine\n    Engine &lt;|-- L630TEngine\n\n    BenzE300L *--&gt; L420TEngine\n    BenzAMGE53 *--&gt; L630TEngine\n</code></pre>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\n\n\nclass Engine(ABC):\n\n    @abstractmethod\n    def power_output(self):\n        pass\n\n\nclass L420TEngine(Engine):\n\n    def power_output(self):\n        return 258\n\n\nclass L630TEngine(Engine):\n\n    def power_output(self):\n        return 435\n\n\nclass Benz(ABC):\n\n    def speed_up(self):\n        horsepower = self._use_engine().power_output()\n        t = 100/(10.6+(horsepower-258)*12.2/177)\n        print(f&#39;With &#123;horsepower&#125;hp, 0-100km need &#123;round(t, 2)&#125; seconds.&#39;)\n\n    @abstractmethod\n    def _use_engine(self):\n        pass\n\n\nclass BenzE300L(Benz):\n\n    def _use_engine(self):\n        return L420TEngine()\n\n\nclass BenzAMGE53(Benz):\n\n    def _use_engine(self):\n        return L630TEngine()\n\n\nif __name__ == &quot;__main__&quot;:\n\n    e300 = BenzE300L()\n    e300.speed_up()\n    amg = BenzAMGE53()\n    amg.speed_up()\n</code></pre>\n<p>Benz作为一个抽象类, 实现了大部分的逻辑, 同时把变量部分抽象为接口, 也就是示例中的Engine.</p>\n<p><code>_use_engine</code>则扮演了工厂方法角色, 通过该方法返回一个参与业务逻辑所需要的对象.</p>\n<p>由于这个对象是<code>Engine</code>的实现类, 只需要扩展其他的实现就可以使业务逻辑得到不同的结果.</p>\n<p>两个具体车型的子类则是继承自<code>Benz</code>抽象类, 重写其工厂方法, 返回其他的实例, 便完成了新的扩展.</p>\n<blockquote>\n<p>很多对工厂方法的示例是通过一个工厂对象的静态方法返回一个对象.</p>\n<p>那就是用错了…</p>\n<p>只要工厂在扩展, 工厂类就需要一直维护, 变的越来越臃肿.</p>\n<p>而调用工厂的特定方法也是需要硬编码, 最终变成两边维护.</p>\n</blockquote>\n<p>{: .prompt-info}</p>\n<blockquote>\n<p><strong>工厂方法是通过继承和重写来快速实现对不同组合的扩展</strong></p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n"},{"title":"设计模式-中介模式","date":"2023-11-20T23:46:31.000Z","mermaid":true,"_content":"\n## 应用场景\n\n通常用于多个元素之间的统一通信调度. 举例来说, 一个用户界面拥有多个类型的UI:\n\n* ListBox\n* TextBox\n* button\n\n当选中listbox中的项时同步修改textbox中的文字. 而当textbox中包含文字时按钮可用, 当textbox中的文字为空时按钮不可用.\n\n```mermaid\nclassDiagram\n    note for ListBox \"selected():<br/>textbox.setContent(...)\"\n    class ListBox{\n        + selected()\n    }\n    note for TextBox \"changed():<br/>button.setEnabled(...)\"\n    class TextBox{\n        + changed()\n    }\n    note for Button \"clicked():<br/>textbox.getContent(...)<br/>//update\"\n    class Button{\n        + clicked()\n    }\n\n    ListBox --> TextBox : 数据交互\n    ListBox --> Button : 状态控制\n    TextBox --> Button : 状态控制\n    Button --> TextBox: 数据交互\n```\n\n虽然功能不复杂, 但是相互之间的连线却是不少. 如果只是单纯的进行UI罗列, 同时直接在UI之间进行交互, 一旦UI数量增多, 就会变得相当难以维护.\n\n中介模式便是为了应对这一问题, 通过一个中介类管理所有的交互状态, 使不同的UI之间彼此隔绝.\n\n```mermaid\nclassDiagram\n    class ListBox{\n        + selected()\n    }\n    \n    class TextBox{\n        + changed()\n    }\n    \n    class Button{\n        + clicked()\n    }\n\n    class Madiator{\n        + update()\n    }\n\n    ListBox <--> Madiator\n    TextBox <--> Madiator\n    Button <--> Madiator\n```\n\n任何一个UI的状态发生改变, 仅需要通知中介对象, 至于其他UI应该做什么对应的调整发生变动的UI本身不需要关心, 也就有了逻辑统一的管理和维护.\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass DialogBox(ABC):\n\n    @abstractmethod\n    def update(self, src, payload=None):\n        pass\n\n\nclass UIControl(ABC):\n\n    __owner = None\n\n    def __init__(self, name, title=None):\n        self.is_enabled = True\n        self.name = name\n        self.title = title\n\n    @abstractmethod\n    def draw(self):\n        pass\n\n    @property\n    def owner(self) -> DialogBox:\n        return self.__owner\n\n    @owner.setter\n    def owner(self, value: DialogBox):\n        self.__owner = value\n\n\nclass UIButton(UIControl):\n\n    def draw(self):\n        print(\"draw button\")\n\n    def click(self):\n        if self.owner:\n            self.owner.update(self)\n\n        print(\"click button\")\n\n\nclass UITextBox(UIControl):\n\n    def __init__(self, name, content=None):\n        self.__content = content\n        super().__init__(name)\n\n    def draw(self):\n        print(\"draw text box\")\n\n    def text_changed(self):\n        if self.owner:\n            self.owner.update(self)\n        print(\"text changed\")\n\n    @property\n    def content(self):\n        return self.__content\n\n    @content.setter\n    def content(self, value):\n        self.__content = value\n        self.text_changed()\n\n\nclass UIListBox(UIControl):\n\n    def __init__(self, name, *items):\n        self.__items = items\n        super().__init__(name)\n        self.__selected = -1\n\n    def on_selected(self, index):\n        print(f\"selected item on index: {index}\")\n        if self.owner:\n            self.owner.update(self)\n\n    @property\n    def selected(self):\n        return None if self.__selected == -1 \\\n            else (self.__selected, self.items[self.__selected])\n\n    @selected.setter\n    def selected(self, value):\n        if value > 0 and self.__selected != value:\n            self.__selected = value\n            self.on_selected(value)\n\n    @property\n    def items(self):\n        return self.__items\n\n    @items.setter\n    def items(self, value):\n        self.__items = value\n\n    def draw(self):\n        print(\"draw listbox\")\n\n\nclass DemoPageDialog(DialogBox):\n\n    def __init__(self, *ui_list):\n        self.__ui_list = ui_list\n        for ui in ui_list:\n            if isinstance(ui, UIControl):\n                ui.owner = self\n\n    def update(self, src: UIControl, payload=None):\n        if src not in self.__ui_list:\n            return\n\n        if isinstance(src, UIButton):\n            print(\">> save text to database...\")\n        elif isinstance(src, UITextBox):\n            print(f\">> textbox content change to {src.content}\")\n            print(\">> set button enabled...\")\n        elif isinstance(src, UIListBox):\n            print(f\">> listbox selected on:{src.selected}\")\n\n\nif __name__ == \"__main__\":\n\n    btn = UIButton(\"btn\")\n    txt = UITextBox(\"title\")\n    listbox = UIListBox(\"list\", \"title1\", \"title2\", \"title3\")\n\n    DemoPageDialog(btn, listbox, txt)\n\n    listbox.selected = 1\n    txt.content = \"new content...\"\n    btn.click()\n\n```\n\n输出结果:\n\n```bash\nselected item on index: 1\n>> listbox selected on:(1, 'title2')\n>> textbox content change to new content...\n>> set button enabled...\ntext changed\n>> save text to database...\nclick button\n```\n","source":"_posts/design-pattern/mediator-design-pattern-demo.md","raw":"---\ntitle: 设计模式-中介模式\ndate: 2023-11-21 07:46:31 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n## 应用场景\n\n通常用于多个元素之间的统一通信调度. 举例来说, 一个用户界面拥有多个类型的UI:\n\n* ListBox\n* TextBox\n* button\n\n当选中listbox中的项时同步修改textbox中的文字. 而当textbox中包含文字时按钮可用, 当textbox中的文字为空时按钮不可用.\n\n```mermaid\nclassDiagram\n    note for ListBox \"selected():<br/>textbox.setContent(...)\"\n    class ListBox{\n        + selected()\n    }\n    note for TextBox \"changed():<br/>button.setEnabled(...)\"\n    class TextBox{\n        + changed()\n    }\n    note for Button \"clicked():<br/>textbox.getContent(...)<br/>//update\"\n    class Button{\n        + clicked()\n    }\n\n    ListBox --> TextBox : 数据交互\n    ListBox --> Button : 状态控制\n    TextBox --> Button : 状态控制\n    Button --> TextBox: 数据交互\n```\n\n虽然功能不复杂, 但是相互之间的连线却是不少. 如果只是单纯的进行UI罗列, 同时直接在UI之间进行交互, 一旦UI数量增多, 就会变得相当难以维护.\n\n中介模式便是为了应对这一问题, 通过一个中介类管理所有的交互状态, 使不同的UI之间彼此隔绝.\n\n```mermaid\nclassDiagram\n    class ListBox{\n        + selected()\n    }\n    \n    class TextBox{\n        + changed()\n    }\n    \n    class Button{\n        + clicked()\n    }\n\n    class Madiator{\n        + update()\n    }\n\n    ListBox <--> Madiator\n    TextBox <--> Madiator\n    Button <--> Madiator\n```\n\n任何一个UI的状态发生改变, 仅需要通知中介对象, 至于其他UI应该做什么对应的调整发生变动的UI本身不需要关心, 也就有了逻辑统一的管理和维护.\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass DialogBox(ABC):\n\n    @abstractmethod\n    def update(self, src, payload=None):\n        pass\n\n\nclass UIControl(ABC):\n\n    __owner = None\n\n    def __init__(self, name, title=None):\n        self.is_enabled = True\n        self.name = name\n        self.title = title\n\n    @abstractmethod\n    def draw(self):\n        pass\n\n    @property\n    def owner(self) -> DialogBox:\n        return self.__owner\n\n    @owner.setter\n    def owner(self, value: DialogBox):\n        self.__owner = value\n\n\nclass UIButton(UIControl):\n\n    def draw(self):\n        print(\"draw button\")\n\n    def click(self):\n        if self.owner:\n            self.owner.update(self)\n\n        print(\"click button\")\n\n\nclass UITextBox(UIControl):\n\n    def __init__(self, name, content=None):\n        self.__content = content\n        super().__init__(name)\n\n    def draw(self):\n        print(\"draw text box\")\n\n    def text_changed(self):\n        if self.owner:\n            self.owner.update(self)\n        print(\"text changed\")\n\n    @property\n    def content(self):\n        return self.__content\n\n    @content.setter\n    def content(self, value):\n        self.__content = value\n        self.text_changed()\n\n\nclass UIListBox(UIControl):\n\n    def __init__(self, name, *items):\n        self.__items = items\n        super().__init__(name)\n        self.__selected = -1\n\n    def on_selected(self, index):\n        print(f\"selected item on index: {index}\")\n        if self.owner:\n            self.owner.update(self)\n\n    @property\n    def selected(self):\n        return None if self.__selected == -1 \\\n            else (self.__selected, self.items[self.__selected])\n\n    @selected.setter\n    def selected(self, value):\n        if value > 0 and self.__selected != value:\n            self.__selected = value\n            self.on_selected(value)\n\n    @property\n    def items(self):\n        return self.__items\n\n    @items.setter\n    def items(self, value):\n        self.__items = value\n\n    def draw(self):\n        print(\"draw listbox\")\n\n\nclass DemoPageDialog(DialogBox):\n\n    def __init__(self, *ui_list):\n        self.__ui_list = ui_list\n        for ui in ui_list:\n            if isinstance(ui, UIControl):\n                ui.owner = self\n\n    def update(self, src: UIControl, payload=None):\n        if src not in self.__ui_list:\n            return\n\n        if isinstance(src, UIButton):\n            print(\">> save text to database...\")\n        elif isinstance(src, UITextBox):\n            print(f\">> textbox content change to {src.content}\")\n            print(\">> set button enabled...\")\n        elif isinstance(src, UIListBox):\n            print(f\">> listbox selected on:{src.selected}\")\n\n\nif __name__ == \"__main__\":\n\n    btn = UIButton(\"btn\")\n    txt = UITextBox(\"title\")\n    listbox = UIListBox(\"list\", \"title1\", \"title2\", \"title3\")\n\n    DemoPageDialog(btn, listbox, txt)\n\n    listbox.selected = 1\n    txt.content = \"new content...\"\n    btn.click()\n\n```\n\n输出结果:\n\n```bash\nselected item on index: 1\n>> listbox selected on:(1, 'title2')\n>> textbox content change to new content...\n>> set button enabled...\ntext changed\n>> save text to database...\nclick button\n```\n","slug":"design-pattern-mediator-design-pattern-demo","published":1,"updated":"2023-12-13T08:43:58.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5vk00bji3erc5hi1ucd","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>通常用于多个元素之间的统一通信调度. 举例来说, 一个用户界面拥有多个类型的UI:</p>\n<ul>\n<li>ListBox</li>\n<li>TextBox</li>\n<li>button</li>\n</ul>\n<p>当选中listbox中的项时同步修改textbox中的文字. 而当textbox中包含文字时按钮可用, 当textbox中的文字为空时按钮不可用.</p>\n<pre><code class=\"mermaid\">classDiagram\n    note for ListBox &quot;selected():&lt;br/&gt;textbox.setContent(...)&quot;\n    class ListBox&#123;\n        + selected()\n    &#125;\n    note for TextBox &quot;changed():&lt;br/&gt;button.setEnabled(...)&quot;\n    class TextBox&#123;\n        + changed()\n    &#125;\n    note for Button &quot;clicked():&lt;br/&gt;textbox.getContent(...)&lt;br/&gt;//update&quot;\n    class Button&#123;\n        + clicked()\n    &#125;\n\n    ListBox --&gt; TextBox : 数据交互\n    ListBox --&gt; Button : 状态控制\n    TextBox --&gt; Button : 状态控制\n    Button --&gt; TextBox: 数据交互\n</code></pre>\n<p>虽然功能不复杂, 但是相互之间的连线却是不少. 如果只是单纯的进行UI罗列, 同时直接在UI之间进行交互, 一旦UI数量增多, 就会变得相当难以维护.</p>\n<p>中介模式便是为了应对这一问题, 通过一个中介类管理所有的交互状态, 使不同的UI之间彼此隔绝.</p>\n<pre><code class=\"mermaid\">classDiagram\n    class ListBox&#123;\n        + selected()\n    &#125;\n    \n    class TextBox&#123;\n        + changed()\n    &#125;\n    \n    class Button&#123;\n        + clicked()\n    &#125;\n\n    class Madiator&#123;\n        + update()\n    &#125;\n\n    ListBox &lt;--&gt; Madiator\n    TextBox &lt;--&gt; Madiator\n    Button &lt;--&gt; Madiator\n</code></pre>\n<p>任何一个UI的状态发生改变, 仅需要通知中介对象, 至于其他UI应该做什么对应的调整发生变动的UI本身不需要关心, 也就有了逻辑统一的管理和维护.</p>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\n\n\nclass DialogBox(ABC):\n\n    @abstractmethod\n    def update(self, src, payload=None):\n        pass\n\n\nclass UIControl(ABC):\n\n    __owner = None\n\n    def __init__(self, name, title=None):\n        self.is_enabled = True\n        self.name = name\n        self.title = title\n\n    @abstractmethod\n    def draw(self):\n        pass\n\n    @property\n    def owner(self) -&gt; DialogBox:\n        return self.__owner\n\n    @owner.setter\n    def owner(self, value: DialogBox):\n        self.__owner = value\n\n\nclass UIButton(UIControl):\n\n    def draw(self):\n        print(&quot;draw button&quot;)\n\n    def click(self):\n        if self.owner:\n            self.owner.update(self)\n\n        print(&quot;click button&quot;)\n\n\nclass UITextBox(UIControl):\n\n    def __init__(self, name, content=None):\n        self.__content = content\n        super().__init__(name)\n\n    def draw(self):\n        print(&quot;draw text box&quot;)\n\n    def text_changed(self):\n        if self.owner:\n            self.owner.update(self)\n        print(&quot;text changed&quot;)\n\n    @property\n    def content(self):\n        return self.__content\n\n    @content.setter\n    def content(self, value):\n        self.__content = value\n        self.text_changed()\n\n\nclass UIListBox(UIControl):\n\n    def __init__(self, name, *items):\n        self.__items = items\n        super().__init__(name)\n        self.__selected = -1\n\n    def on_selected(self, index):\n        print(f&quot;selected item on index: &#123;index&#125;&quot;)\n        if self.owner:\n            self.owner.update(self)\n\n    @property\n    def selected(self):\n        return None if self.__selected == -1 \\\n            else (self.__selected, self.items[self.__selected])\n\n    @selected.setter\n    def selected(self, value):\n        if value &gt; 0 and self.__selected != value:\n            self.__selected = value\n            self.on_selected(value)\n\n    @property\n    def items(self):\n        return self.__items\n\n    @items.setter\n    def items(self, value):\n        self.__items = value\n\n    def draw(self):\n        print(&quot;draw listbox&quot;)\n\n\nclass DemoPageDialog(DialogBox):\n\n    def __init__(self, *ui_list):\n        self.__ui_list = ui_list\n        for ui in ui_list:\n            if isinstance(ui, UIControl):\n                ui.owner = self\n\n    def update(self, src: UIControl, payload=None):\n        if src not in self.__ui_list:\n            return\n\n        if isinstance(src, UIButton):\n            print(&quot;&gt;&gt; save text to database...&quot;)\n        elif isinstance(src, UITextBox):\n            print(f&quot;&gt;&gt; textbox content change to &#123;src.content&#125;&quot;)\n            print(&quot;&gt;&gt; set button enabled...&quot;)\n        elif isinstance(src, UIListBox):\n            print(f&quot;&gt;&gt; listbox selected on:&#123;src.selected&#125;&quot;)\n\n\nif __name__ == &quot;__main__&quot;:\n\n    btn = UIButton(&quot;btn&quot;)\n    txt = UITextBox(&quot;title&quot;)\n    listbox = UIListBox(&quot;list&quot;, &quot;title1&quot;, &quot;title2&quot;, &quot;title3&quot;)\n\n    DemoPageDialog(btn, listbox, txt)\n\n    listbox.selected = 1\n    txt.content = &quot;new content...&quot;\n    btn.click()\n</code></pre>\n<p>输出结果:</p>\n<pre><code class=\"bash\">selected item on index: 1\n&gt;&gt; listbox selected on:(1, &#39;title2&#39;)\n&gt;&gt; textbox content change to new content...\n&gt;&gt; set button enabled...\ntext changed\n&gt;&gt; save text to database...\nclick button\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>通常用于多个元素之间的统一通信调度. 举例来说, 一个用户界面拥有多个类型的UI:</p>\n<ul>\n<li>ListBox</li>\n<li>TextBox</li>\n<li>button</li>\n</ul>\n<p>当选中listbox中的项时同步修改textbox中的文字. 而当textbox中包含文字时按钮可用, 当textbox中的文字为空时按钮不可用.</p>\n<pre><code class=\"mermaid\">classDiagram\n    note for ListBox &quot;selected():&lt;br/&gt;textbox.setContent(...)&quot;\n    class ListBox&#123;\n        + selected()\n    &#125;\n    note for TextBox &quot;changed():&lt;br/&gt;button.setEnabled(...)&quot;\n    class TextBox&#123;\n        + changed()\n    &#125;\n    note for Button &quot;clicked():&lt;br/&gt;textbox.getContent(...)&lt;br/&gt;//update&quot;\n    class Button&#123;\n        + clicked()\n    &#125;\n\n    ListBox --&gt; TextBox : 数据交互\n    ListBox --&gt; Button : 状态控制\n    TextBox --&gt; Button : 状态控制\n    Button --&gt; TextBox: 数据交互\n</code></pre>\n<p>虽然功能不复杂, 但是相互之间的连线却是不少. 如果只是单纯的进行UI罗列, 同时直接在UI之间进行交互, 一旦UI数量增多, 就会变得相当难以维护.</p>\n<p>中介模式便是为了应对这一问题, 通过一个中介类管理所有的交互状态, 使不同的UI之间彼此隔绝.</p>\n<pre><code class=\"mermaid\">classDiagram\n    class ListBox&#123;\n        + selected()\n    &#125;\n    \n    class TextBox&#123;\n        + changed()\n    &#125;\n    \n    class Button&#123;\n        + clicked()\n    &#125;\n\n    class Madiator&#123;\n        + update()\n    &#125;\n\n    ListBox &lt;--&gt; Madiator\n    TextBox &lt;--&gt; Madiator\n    Button &lt;--&gt; Madiator\n</code></pre>\n<p>任何一个UI的状态发生改变, 仅需要通知中介对象, 至于其他UI应该做什么对应的调整发生变动的UI本身不需要关心, 也就有了逻辑统一的管理和维护.</p>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\n\n\nclass DialogBox(ABC):\n\n    @abstractmethod\n    def update(self, src, payload=None):\n        pass\n\n\nclass UIControl(ABC):\n\n    __owner = None\n\n    def __init__(self, name, title=None):\n        self.is_enabled = True\n        self.name = name\n        self.title = title\n\n    @abstractmethod\n    def draw(self):\n        pass\n\n    @property\n    def owner(self) -&gt; DialogBox:\n        return self.__owner\n\n    @owner.setter\n    def owner(self, value: DialogBox):\n        self.__owner = value\n\n\nclass UIButton(UIControl):\n\n    def draw(self):\n        print(&quot;draw button&quot;)\n\n    def click(self):\n        if self.owner:\n            self.owner.update(self)\n\n        print(&quot;click button&quot;)\n\n\nclass UITextBox(UIControl):\n\n    def __init__(self, name, content=None):\n        self.__content = content\n        super().__init__(name)\n\n    def draw(self):\n        print(&quot;draw text box&quot;)\n\n    def text_changed(self):\n        if self.owner:\n            self.owner.update(self)\n        print(&quot;text changed&quot;)\n\n    @property\n    def content(self):\n        return self.__content\n\n    @content.setter\n    def content(self, value):\n        self.__content = value\n        self.text_changed()\n\n\nclass UIListBox(UIControl):\n\n    def __init__(self, name, *items):\n        self.__items = items\n        super().__init__(name)\n        self.__selected = -1\n\n    def on_selected(self, index):\n        print(f&quot;selected item on index: &#123;index&#125;&quot;)\n        if self.owner:\n            self.owner.update(self)\n\n    @property\n    def selected(self):\n        return None if self.__selected == -1 \\\n            else (self.__selected, self.items[self.__selected])\n\n    @selected.setter\n    def selected(self, value):\n        if value &gt; 0 and self.__selected != value:\n            self.__selected = value\n            self.on_selected(value)\n\n    @property\n    def items(self):\n        return self.__items\n\n    @items.setter\n    def items(self, value):\n        self.__items = value\n\n    def draw(self):\n        print(&quot;draw listbox&quot;)\n\n\nclass DemoPageDialog(DialogBox):\n\n    def __init__(self, *ui_list):\n        self.__ui_list = ui_list\n        for ui in ui_list:\n            if isinstance(ui, UIControl):\n                ui.owner = self\n\n    def update(self, src: UIControl, payload=None):\n        if src not in self.__ui_list:\n            return\n\n        if isinstance(src, UIButton):\n            print(&quot;&gt;&gt; save text to database...&quot;)\n        elif isinstance(src, UITextBox):\n            print(f&quot;&gt;&gt; textbox content change to &#123;src.content&#125;&quot;)\n            print(&quot;&gt;&gt; set button enabled...&quot;)\n        elif isinstance(src, UIListBox):\n            print(f&quot;&gt;&gt; listbox selected on:&#123;src.selected&#125;&quot;)\n\n\nif __name__ == &quot;__main__&quot;:\n\n    btn = UIButton(&quot;btn&quot;)\n    txt = UITextBox(&quot;title&quot;)\n    listbox = UIListBox(&quot;list&quot;, &quot;title1&quot;, &quot;title2&quot;, &quot;title3&quot;)\n\n    DemoPageDialog(btn, listbox, txt)\n\n    listbox.selected = 1\n    txt.content = &quot;new content...&quot;\n    btn.click()\n</code></pre>\n<p>输出结果:</p>\n<pre><code class=\"bash\">selected item on index: 1\n&gt;&gt; listbox selected on:(1, &#39;title2&#39;)\n&gt;&gt; textbox content change to new content...\n&gt;&gt; set button enabled...\ntext changed\n&gt;&gt; save text to database...\nclick button\n</code></pre>\n"},{"title":"设计模式-单例模式","date":"2023-11-24T02:20:49.000Z","mermaid":true,"_content":"\n## 应用场景\n\n单例模式属于比较常见的基础设计模式. 即一个类在全局中仅存在一个实例化的对象.\n\n比较常见的地方比如项目的配置管理对象. 因为保存了各个模块之间的统一配置信息以保证其在相同的环境下运行. 单例模式就是很好的选择.\n\n## 简单的单例实现\n\n简单的java单例\n\n```java\npublic class ConfigManager {\n\n    private static ConfigManager instance = new ConfigManager();\n    private Map<String, Object> config = new HashMap<String, Object>();\n\n    private ConfigManager() {\n    }\n\n    public static ConfigManager getInstance() {\n        return instance;\n    }\n\n    public Object getConfig(String key) {\n        return config.get(key);\n    }\n\n    public void setConfig(String key, Object value) {\n        config.put(key, value);\n    }\n}\n```\n\n## python中的单例实现\n\n作为比较常用的设计模式, python对于单例的实现相较java来说就差了点意思.\n\n### 通过模块实现\n\n在python中每一个`.py`文件都被看做一个模块, 而模块本身就是单例的.\n\n因此最简单的单例实现方式就是直接在模块中定义类, 创建单例实例供外部引用\n\n```python\n# singleton.py\nclass Singleton:\n\n    desc = \"this is a Singleton Class\"\n\n    def action(self):\n        print(self.desc)\n\n\ninstance = Singleton()\n\n# app.py\nfrom singleton import instance\n\ninstance.action()\n\n```\n\n### 通过装饰器实现单例\n\n```python\nimport functools\n\n\ndef singleton(cls):\n    __instance = {}\n\n    @functools.wraps(cls)\n    def instance(*args, **kwargs):\n        if cls not in __instance:\n            __instance[cls] = cls(*args, **kwargs)\n        return __instance[cls]\n    return instance\n\n\n@singleton\nclass Singleton:\n\n    def __init__(self, name):\n        self.name = name\n\n    def __repr__(self):\n        return \"<Singleton name='%s' id=0x'%x'>\" % (self.name, id(self))\n\n\nif __name__ == \"__main__\":\n    s1 = Singleton(\"a\")\n    s2 = Singleton(\"b\")\n\n    print(repr(s1))\n    print(repr(s2))\n```\n\n输出结果:\n\n```bash\n<Singleton name='a' id='0x100c49ed0'>\n<Singleton name='a' id='0x100c49ed0'>\n```\n\n虽然构造`s2`时使用了新的名称, 但是在最终输出的时候获得却是同一个对象, 名称和地址都没有改变.\n\n### 通过类实现\n\n```python\nclass Singleton:\n\n    def __init__(self, name):\n        self.name = name\n\n    @classmethod\n    def instance(cls, *args, **kwargs):\n        if not hasattr(Singleton, '_instance'):\n            Singleton._instance = Singleton(*args, **kwargs)\n\n        return Singleton._instance\n\n    def __str__(self):\n        return f\"{self.name}@0x{hex(id(self))}\"\n\n\nif __name__ == \"__main__\":\n    s1 = Singleton.instance(\"s1\")\n    s2 = Singleton.instance(\"s2\")\n    s3 = Singleton(\"s3\")\n\n    print(s1, s2, s3)\n\n```\n\n输出结果:\n\n```bash\ns1@0x100f86090 s1@0x100f86090 s3@0x100f86210\n```\n\n### 单例模式的线程安全问题\n\n从结果上来看, 在调用instance()方法获取实例的时候是能够实现单例的, 但是存在两个问题:\n\n1. python的类不是线程安全的, 如果获取实例的间隔小于初始化的时间, 则可能存在多个实例.\n2. 没有私有化的构造函数, 无法避免因为直接创建对象实例的误操作而产生的影响.\n\n如果延长类的构建时间, 并通过线程来调用单例类:\n\n```python\n def task(name):\n        s = Singleton.instance(name)\n        print(s)\n\n    for i in range(0, 3):\n        threading.Thread(target=task, args=[f\"name{i}\",]).start()\n```\n\n得到的输出结果就是:\n\n```bash\nname2@0x102b3d110\nname0@0x102b3ca90\nname1@0x102b3cdd0\n```\n\n显然, 每一个线程都创建了一个对象的实例.\n\n为了解决线程安全的问题, 需要对类的定义做一下处理:\n\n```python\n@classmethod\n    def instance(cls, *args, **kwargs):\n        if not hasattr(Singleton, '_instance'):\n            with Singleton.__instance_lock:\n                if not hasattr(Singleton, '_instance'):\n                    Singleton._instance = Singleton(*args, **kwargs)\n\n        return Singleton._instance\n```\n\n> 进行两次`if not hasattr(Singleton, '_instance'):`判断的作用:\n>\n> 1. 判断当前有没有实例, 如果没有, 看看有没有锁, 如果有锁说明其他对象正在创建实例, 等待解锁;\n> 2. 在别的线程解锁自己锁定后, 判断是否存在实例, 如果没有则创建实例\n>\n> 外层判断最大的作用是避免在已经有实例的情况下开启线程锁, 增加资源消耗.\n>\n> 内层判断的作用是避免其他线程创建成功后再次进行重复创建.\n>\n> 总的来说, 外层判断可以省略, 但是会略问增加资源消耗. 但内层判断必须保留, 否则总是会创建新的实例.\n>\n{: .prompt-tip}\n\n再次调用之前的多线程函数获得结果:\n\n```bash\nname0@0x1050e0b90\nname0@0x1050e0b90\nname0@0x1050e0b90\n```\n\n而同样的线程安全问题, 在通过装饰器实现的单例中同样存在. 因此对于装饰器方法也应进行修改:\n\n```python\ndef singleton(cls):\n    __instance = {}\n    __instance_lock = threading.Lock()\n\n    @functools.wraps(cls)\n    def instance(*args, **kwargs):\n        if cls not in __instance:\n            with __instance_lock:\n                if cls not in __instance:\n                    __instance[cls] = cls(*args, **kwargs)\n\n        return __instance[cls]\n    return instance\n```\n\n### 基于__new__方法实现单例\n\n通过上面的两种几种形式都可以实现单例, 但依旧有一个问题没有解决, 就是没有避免直接创建实例的误操作.\n\n在python中对象的实例化首先是通过`object`对象的`__new__`方法创建, 然后再调用`__init__`方法进行初始化的.\n\n所以重写`__new__`方法也可以实现单例.\n\n```python\nimport threading\n\n\nclass Singleton:\n\n    __instance_lock = threading.Lock()\n\n    def __init__(self):\n        if not hasattr(self, 'count'):\n            self.count = 0\n        self.count += 1\n\n    @staticmethod\n    def instance():\n        return Singleton()\n\n    def __new__(cls, *args, **kwargs):\n        if not hasattr(cls, '_instance'):\n            with cls.__instance_lock:\n                if not hasattr(cls, '_instance'):\n                    cls._instance = object.__new__(cls)\n\n        return cls._instance\n\n    def __str__(self):\n        return f\"<Singleton@{hex(id(self))} called:{self.count}>\"\n\n\nif __name__ == \"__main__\":\n\n    def single_thread():\n        s1 = Singleton()\n        s2 = Singleton()\n        s3 = Singleton.instance()\n\n        print(s1, s2, s3)\n\n    def task1():\n        s = Singleton()\n        print(s)\n\n    def task2():\n        s = Singleton.instance()\n        print(s)\n\n    def multiple_thread():\n        for _ in range(3):\n            threading.Thread(target=task1).start()\n            threading.Thread(target=task2).start()\n\n    multiple_thread()\n```\n\n输出结果:\n\n```bash\n<Singleton@0x1047dcd50 called:1>\n<Singleton@0x1047dcd50 called:2>\n<Singleton@0x1047dcd50 called:3>\n<Singleton@0x1047dcd50 called:4>\n<Singleton@0x1047dcd50 called:5>\n<Singleton@0x1047dcd50 called:6>\n```\n\n在instance()静态方法中直接返回了一个实例化对象, 而通过重写`__new__`方法则修改了对象的创建方式.\n\n如此一来, 无论是通过instance方法还是直接创建, 都可以获得一个线程安全的单例对象.\n\n> 需要注意的是, 每次获取单例对象的时候本`__init__`方法都会被执行, 对象的生命周期并没有发生改变, 只是把创建对象的内存分配方式进行了修改.\n>\n> 也就是说, 如果向初始化对象传递参数, 那么单例对象会被重复初始化, 并且状态停留在最后一次初始化的状态下. 而之前的初始化信息则会丢失.\n>\n{: .prompt-warning}\n\n### 通过metaclass来实现单例\n\n基于metaclass来实现单例, 同样是通过修改初始化方式. 在python中对象实例的创建流程大致如下图所示:\n\n![img](/assets/img/img_202311241307079570.png)\n\n本质上来说, 代码`Foo()`实际上是调用了metaclass也就是type的`__call__`方法.\n\n而type的__call__方法则是调用Foo继承自object或者重写的`__new__`方法获得一个新的空对象.\n\n随后再的调用Foo的`__init__`方法, 对空对象进行初始化, 最后将初始化完成的对象返回给调用者.\n\n所以, 实际返回实例化对象的方法是type.__call__, 而不是类的__init__.\n\n通过自定一个type类的子类, 重写其`__call__`方法, 便可以实现单例模式.\n\n修改后的流程大致如下图所示:\n\n![img](/assets/img/img_202311241434531606.png)\n\npython实现代码:\n\n```python\nimport threading\n\n\nclass SingletonMeta(type):\n\n    __instance_lock = threading.Lock()\n\n    def __call__(cls, *args, **kwargs):\n        if not hasattr(cls, '_instance'):\n            with SingletonMeta.__instance_lock:\n                if not hasattr(cls, '_instance'):\n                    obj = object.__new__(cls)\n                    cls.__init__(obj, *args, **kwargs)\n                    cls._instance = obj\n        return cls._instance\n\n\nclass Singleton(metaclass=SingletonMeta):\n\n    def __init__(self, name):\n        self.name = name\n\n    def __str__(self):\n        return f\"<{self.name}@{hex(id(self))}>\"\n\n\nif __name__ == \"__main__\":\n\n    def task(n):\n        s = Singleton(f\"s{n}\")\n        print(s)\n\n    for i in range(3):\n        threading.Thread(target=task, args=(i,)).start()\n```\n\n输出结果:\n\n```bash\n<s0@0x100db4a90>\n<s0@0x100db4a90>\n<s0@0x100db4a90>\n```\n\n## 总结\n\n虽然python实现单例的方式有很多, 但是总的来说还是觉得没有java简单便利.\n\n从几种放发的对比上来说, 最简单的莫过于通过模块实现.\n\n从重用的角度来说, 装饰器和元类模式是最好的.\n\n通过类方法实现在安全性上略差, 无法避免使用过程中误操作的实例化的潜在问题.\n\n通过__new__方法则是在重用性上有比较大的短板.\n\n综合来说, 直接通过模块实现单例, 或者通过元类来实现单例效果最佳.\n","source":"_posts/design-pattern/singleton-design-pattern-demo.md","raw":"---\ntitle: 设计模式-单例模式\ndate: 2023-11-24 10:20:49 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern', ⭐️]\nmermaid: true\n---\n\n## 应用场景\n\n单例模式属于比较常见的基础设计模式. 即一个类在全局中仅存在一个实例化的对象.\n\n比较常见的地方比如项目的配置管理对象. 因为保存了各个模块之间的统一配置信息以保证其在相同的环境下运行. 单例模式就是很好的选择.\n\n## 简单的单例实现\n\n简单的java单例\n\n```java\npublic class ConfigManager {\n\n    private static ConfigManager instance = new ConfigManager();\n    private Map<String, Object> config = new HashMap<String, Object>();\n\n    private ConfigManager() {\n    }\n\n    public static ConfigManager getInstance() {\n        return instance;\n    }\n\n    public Object getConfig(String key) {\n        return config.get(key);\n    }\n\n    public void setConfig(String key, Object value) {\n        config.put(key, value);\n    }\n}\n```\n\n## python中的单例实现\n\n作为比较常用的设计模式, python对于单例的实现相较java来说就差了点意思.\n\n### 通过模块实现\n\n在python中每一个`.py`文件都被看做一个模块, 而模块本身就是单例的.\n\n因此最简单的单例实现方式就是直接在模块中定义类, 创建单例实例供外部引用\n\n```python\n# singleton.py\nclass Singleton:\n\n    desc = \"this is a Singleton Class\"\n\n    def action(self):\n        print(self.desc)\n\n\ninstance = Singleton()\n\n# app.py\nfrom singleton import instance\n\ninstance.action()\n\n```\n\n### 通过装饰器实现单例\n\n```python\nimport functools\n\n\ndef singleton(cls):\n    __instance = {}\n\n    @functools.wraps(cls)\n    def instance(*args, **kwargs):\n        if cls not in __instance:\n            __instance[cls] = cls(*args, **kwargs)\n        return __instance[cls]\n    return instance\n\n\n@singleton\nclass Singleton:\n\n    def __init__(self, name):\n        self.name = name\n\n    def __repr__(self):\n        return \"<Singleton name='%s' id=0x'%x'>\" % (self.name, id(self))\n\n\nif __name__ == \"__main__\":\n    s1 = Singleton(\"a\")\n    s2 = Singleton(\"b\")\n\n    print(repr(s1))\n    print(repr(s2))\n```\n\n输出结果:\n\n```bash\n<Singleton name='a' id='0x100c49ed0'>\n<Singleton name='a' id='0x100c49ed0'>\n```\n\n虽然构造`s2`时使用了新的名称, 但是在最终输出的时候获得却是同一个对象, 名称和地址都没有改变.\n\n### 通过类实现\n\n```python\nclass Singleton:\n\n    def __init__(self, name):\n        self.name = name\n\n    @classmethod\n    def instance(cls, *args, **kwargs):\n        if not hasattr(Singleton, '_instance'):\n            Singleton._instance = Singleton(*args, **kwargs)\n\n        return Singleton._instance\n\n    def __str__(self):\n        return f\"{self.name}@0x{hex(id(self))}\"\n\n\nif __name__ == \"__main__\":\n    s1 = Singleton.instance(\"s1\")\n    s2 = Singleton.instance(\"s2\")\n    s3 = Singleton(\"s3\")\n\n    print(s1, s2, s3)\n\n```\n\n输出结果:\n\n```bash\ns1@0x100f86090 s1@0x100f86090 s3@0x100f86210\n```\n\n### 单例模式的线程安全问题\n\n从结果上来看, 在调用instance()方法获取实例的时候是能够实现单例的, 但是存在两个问题:\n\n1. python的类不是线程安全的, 如果获取实例的间隔小于初始化的时间, 则可能存在多个实例.\n2. 没有私有化的构造函数, 无法避免因为直接创建对象实例的误操作而产生的影响.\n\n如果延长类的构建时间, 并通过线程来调用单例类:\n\n```python\n def task(name):\n        s = Singleton.instance(name)\n        print(s)\n\n    for i in range(0, 3):\n        threading.Thread(target=task, args=[f\"name{i}\",]).start()\n```\n\n得到的输出结果就是:\n\n```bash\nname2@0x102b3d110\nname0@0x102b3ca90\nname1@0x102b3cdd0\n```\n\n显然, 每一个线程都创建了一个对象的实例.\n\n为了解决线程安全的问题, 需要对类的定义做一下处理:\n\n```python\n@classmethod\n    def instance(cls, *args, **kwargs):\n        if not hasattr(Singleton, '_instance'):\n            with Singleton.__instance_lock:\n                if not hasattr(Singleton, '_instance'):\n                    Singleton._instance = Singleton(*args, **kwargs)\n\n        return Singleton._instance\n```\n\n> 进行两次`if not hasattr(Singleton, '_instance'):`判断的作用:\n>\n> 1. 判断当前有没有实例, 如果没有, 看看有没有锁, 如果有锁说明其他对象正在创建实例, 等待解锁;\n> 2. 在别的线程解锁自己锁定后, 判断是否存在实例, 如果没有则创建实例\n>\n> 外层判断最大的作用是避免在已经有实例的情况下开启线程锁, 增加资源消耗.\n>\n> 内层判断的作用是避免其他线程创建成功后再次进行重复创建.\n>\n> 总的来说, 外层判断可以省略, 但是会略问增加资源消耗. 但内层判断必须保留, 否则总是会创建新的实例.\n>\n{: .prompt-tip}\n\n再次调用之前的多线程函数获得结果:\n\n```bash\nname0@0x1050e0b90\nname0@0x1050e0b90\nname0@0x1050e0b90\n```\n\n而同样的线程安全问题, 在通过装饰器实现的单例中同样存在. 因此对于装饰器方法也应进行修改:\n\n```python\ndef singleton(cls):\n    __instance = {}\n    __instance_lock = threading.Lock()\n\n    @functools.wraps(cls)\n    def instance(*args, **kwargs):\n        if cls not in __instance:\n            with __instance_lock:\n                if cls not in __instance:\n                    __instance[cls] = cls(*args, **kwargs)\n\n        return __instance[cls]\n    return instance\n```\n\n### 基于__new__方法实现单例\n\n通过上面的两种几种形式都可以实现单例, 但依旧有一个问题没有解决, 就是没有避免直接创建实例的误操作.\n\n在python中对象的实例化首先是通过`object`对象的`__new__`方法创建, 然后再调用`__init__`方法进行初始化的.\n\n所以重写`__new__`方法也可以实现单例.\n\n```python\nimport threading\n\n\nclass Singleton:\n\n    __instance_lock = threading.Lock()\n\n    def __init__(self):\n        if not hasattr(self, 'count'):\n            self.count = 0\n        self.count += 1\n\n    @staticmethod\n    def instance():\n        return Singleton()\n\n    def __new__(cls, *args, **kwargs):\n        if not hasattr(cls, '_instance'):\n            with cls.__instance_lock:\n                if not hasattr(cls, '_instance'):\n                    cls._instance = object.__new__(cls)\n\n        return cls._instance\n\n    def __str__(self):\n        return f\"<Singleton@{hex(id(self))} called:{self.count}>\"\n\n\nif __name__ == \"__main__\":\n\n    def single_thread():\n        s1 = Singleton()\n        s2 = Singleton()\n        s3 = Singleton.instance()\n\n        print(s1, s2, s3)\n\n    def task1():\n        s = Singleton()\n        print(s)\n\n    def task2():\n        s = Singleton.instance()\n        print(s)\n\n    def multiple_thread():\n        for _ in range(3):\n            threading.Thread(target=task1).start()\n            threading.Thread(target=task2).start()\n\n    multiple_thread()\n```\n\n输出结果:\n\n```bash\n<Singleton@0x1047dcd50 called:1>\n<Singleton@0x1047dcd50 called:2>\n<Singleton@0x1047dcd50 called:3>\n<Singleton@0x1047dcd50 called:4>\n<Singleton@0x1047dcd50 called:5>\n<Singleton@0x1047dcd50 called:6>\n```\n\n在instance()静态方法中直接返回了一个实例化对象, 而通过重写`__new__`方法则修改了对象的创建方式.\n\n如此一来, 无论是通过instance方法还是直接创建, 都可以获得一个线程安全的单例对象.\n\n> 需要注意的是, 每次获取单例对象的时候本`__init__`方法都会被执行, 对象的生命周期并没有发生改变, 只是把创建对象的内存分配方式进行了修改.\n>\n> 也就是说, 如果向初始化对象传递参数, 那么单例对象会被重复初始化, 并且状态停留在最后一次初始化的状态下. 而之前的初始化信息则会丢失.\n>\n{: .prompt-warning}\n\n### 通过metaclass来实现单例\n\n基于metaclass来实现单例, 同样是通过修改初始化方式. 在python中对象实例的创建流程大致如下图所示:\n\n![img](/assets/img/img_202311241307079570.png)\n\n本质上来说, 代码`Foo()`实际上是调用了metaclass也就是type的`__call__`方法.\n\n而type的__call__方法则是调用Foo继承自object或者重写的`__new__`方法获得一个新的空对象.\n\n随后再的调用Foo的`__init__`方法, 对空对象进行初始化, 最后将初始化完成的对象返回给调用者.\n\n所以, 实际返回实例化对象的方法是type.__call__, 而不是类的__init__.\n\n通过自定一个type类的子类, 重写其`__call__`方法, 便可以实现单例模式.\n\n修改后的流程大致如下图所示:\n\n![img](/assets/img/img_202311241434531606.png)\n\npython实现代码:\n\n```python\nimport threading\n\n\nclass SingletonMeta(type):\n\n    __instance_lock = threading.Lock()\n\n    def __call__(cls, *args, **kwargs):\n        if not hasattr(cls, '_instance'):\n            with SingletonMeta.__instance_lock:\n                if not hasattr(cls, '_instance'):\n                    obj = object.__new__(cls)\n                    cls.__init__(obj, *args, **kwargs)\n                    cls._instance = obj\n        return cls._instance\n\n\nclass Singleton(metaclass=SingletonMeta):\n\n    def __init__(self, name):\n        self.name = name\n\n    def __str__(self):\n        return f\"<{self.name}@{hex(id(self))}>\"\n\n\nif __name__ == \"__main__\":\n\n    def task(n):\n        s = Singleton(f\"s{n}\")\n        print(s)\n\n    for i in range(3):\n        threading.Thread(target=task, args=(i,)).start()\n```\n\n输出结果:\n\n```bash\n<s0@0x100db4a90>\n<s0@0x100db4a90>\n<s0@0x100db4a90>\n```\n\n## 总结\n\n虽然python实现单例的方式有很多, 但是总的来说还是觉得没有java简单便利.\n\n从几种放发的对比上来说, 最简单的莫过于通过模块实现.\n\n从重用的角度来说, 装饰器和元类模式是最好的.\n\n通过类方法实现在安全性上略差, 无法避免使用过程中误操作的实例化的潜在问题.\n\n通过__new__方法则是在重用性上有比较大的短板.\n\n综合来说, 直接通过模块实现单例, 或者通过元类来实现单例效果最佳.\n","slug":"design-pattern-singleton-design-pattern-demo","published":1,"updated":"2023-12-13T08:43:58.101Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5vk00bmi3er1y76gj4o","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>单例模式属于比较常见的基础设计模式. 即一个类在全局中仅存在一个实例化的对象.</p>\n<p>比较常见的地方比如项目的配置管理对象. 因为保存了各个模块之间的统一配置信息以保证其在相同的环境下运行. 单例模式就是很好的选择.</p>\n<h2 id=\"简单的单例实现\"><a href=\"#简单的单例实现\" class=\"headerlink\" title=\"简单的单例实现\"></a>简单的单例实现</h2><p>简单的java单例</p>\n<pre><code class=\"java\">public class ConfigManager &#123;\n\n    private static ConfigManager instance = new ConfigManager();\n    private Map&lt;String, Object&gt; config = new HashMap&lt;String, Object&gt;();\n\n    private ConfigManager() &#123;\n    &#125;\n\n    public static ConfigManager getInstance() &#123;\n        return instance;\n    &#125;\n\n    public Object getConfig(String key) &#123;\n        return config.get(key);\n    &#125;\n\n    public void setConfig(String key, Object value) &#123;\n        config.put(key, value);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"python中的单例实现\"><a href=\"#python中的单例实现\" class=\"headerlink\" title=\"python中的单例实现\"></a>python中的单例实现</h2><p>作为比较常用的设计模式, python对于单例的实现相较java来说就差了点意思.</p>\n<h3 id=\"通过模块实现\"><a href=\"#通过模块实现\" class=\"headerlink\" title=\"通过模块实现\"></a>通过模块实现</h3><p>在python中每一个<code>.py</code>文件都被看做一个模块, 而模块本身就是单例的.</p>\n<p>因此最简单的单例实现方式就是直接在模块中定义类, 创建单例实例供外部引用</p>\n<pre><code class=\"python\"># singleton.py\nclass Singleton:\n\n    desc = &quot;this is a Singleton Class&quot;\n\n    def action(self):\n        print(self.desc)\n\n\ninstance = Singleton()\n\n# app.py\nfrom singleton import instance\n\ninstance.action()\n</code></pre>\n<h3 id=\"通过装饰器实现单例\"><a href=\"#通过装饰器实现单例\" class=\"headerlink\" title=\"通过装饰器实现单例\"></a>通过装饰器实现单例</h3><pre><code class=\"python\">import functools\n\n\ndef singleton(cls):\n    __instance = &#123;&#125;\n\n    @functools.wraps(cls)\n    def instance(*args, **kwargs):\n        if cls not in __instance:\n            __instance[cls] = cls(*args, **kwargs)\n        return __instance[cls]\n    return instance\n\n\n@singleton\nclass Singleton:\n\n    def __init__(self, name):\n        self.name = name\n\n    def __repr__(self):\n        return &quot;&lt;Singleton name=&#39;%s&#39; id=0x&#39;%x&#39;&gt;&quot; % (self.name, id(self))\n\n\nif __name__ == &quot;__main__&quot;:\n    s1 = Singleton(&quot;a&quot;)\n    s2 = Singleton(&quot;b&quot;)\n\n    print(repr(s1))\n    print(repr(s2))\n</code></pre>\n<p>输出结果:</p>\n<pre><code class=\"bash\">&lt;Singleton name=&#39;a&#39; id=&#39;0x100c49ed0&#39;&gt;\n&lt;Singleton name=&#39;a&#39; id=&#39;0x100c49ed0&#39;&gt;\n</code></pre>\n<p>虽然构造<code>s2</code>时使用了新的名称, 但是在最终输出的时候获得却是同一个对象, 名称和地址都没有改变.</p>\n<h3 id=\"通过类实现\"><a href=\"#通过类实现\" class=\"headerlink\" title=\"通过类实现\"></a>通过类实现</h3><pre><code class=\"python\">class Singleton:\n\n    def __init__(self, name):\n        self.name = name\n\n    @classmethod\n    def instance(cls, *args, **kwargs):\n        if not hasattr(Singleton, &#39;_instance&#39;):\n            Singleton._instance = Singleton(*args, **kwargs)\n\n        return Singleton._instance\n\n    def __str__(self):\n        return f&quot;&#123;self.name&#125;@0x&#123;hex(id(self))&#125;&quot;\n\n\nif __name__ == &quot;__main__&quot;:\n    s1 = Singleton.instance(&quot;s1&quot;)\n    s2 = Singleton.instance(&quot;s2&quot;)\n    s3 = Singleton(&quot;s3&quot;)\n\n    print(s1, s2, s3)\n</code></pre>\n<p>输出结果:</p>\n<pre><code class=\"bash\">s1@0x100f86090 s1@0x100f86090 s3@0x100f86210\n</code></pre>\n<h3 id=\"单例模式的线程安全问题\"><a href=\"#单例模式的线程安全问题\" class=\"headerlink\" title=\"单例模式的线程安全问题\"></a>单例模式的线程安全问题</h3><p>从结果上来看, 在调用instance()方法获取实例的时候是能够实现单例的, 但是存在两个问题:</p>\n<ol>\n<li>python的类不是线程安全的, 如果获取实例的间隔小于初始化的时间, 则可能存在多个实例.</li>\n<li>没有私有化的构造函数, 无法避免因为直接创建对象实例的误操作而产生的影响.</li>\n</ol>\n<p>如果延长类的构建时间, 并通过线程来调用单例类:</p>\n<pre><code class=\"python\"> def task(name):\n        s = Singleton.instance(name)\n        print(s)\n\n    for i in range(0, 3):\n        threading.Thread(target=task, args=[f&quot;name&#123;i&#125;&quot;,]).start()\n</code></pre>\n<p>得到的输出结果就是:</p>\n<pre><code class=\"bash\">name2@0x102b3d110\nname0@0x102b3ca90\nname1@0x102b3cdd0\n</code></pre>\n<p>显然, 每一个线程都创建了一个对象的实例.</p>\n<p>为了解决线程安全的问题, 需要对类的定义做一下处理:</p>\n<pre><code class=\"python\">@classmethod\n    def instance(cls, *args, **kwargs):\n        if not hasattr(Singleton, &#39;_instance&#39;):\n            with Singleton.__instance_lock:\n                if not hasattr(Singleton, &#39;_instance&#39;):\n                    Singleton._instance = Singleton(*args, **kwargs)\n\n        return Singleton._instance\n</code></pre>\n<blockquote>\n<p>进行两次<code>if not hasattr(Singleton, &#39;_instance&#39;):</code>判断的作用:</p>\n<ol>\n<li>判断当前有没有实例, 如果没有, 看看有没有锁, 如果有锁说明其他对象正在创建实例, 等待解锁;</li>\n<li>在别的线程解锁自己锁定后, 判断是否存在实例, 如果没有则创建实例</li>\n</ol>\n<p>外层判断最大的作用是避免在已经有实例的情况下开启线程锁, 增加资源消耗.</p>\n<p>内层判断的作用是避免其他线程创建成功后再次进行重复创建.</p>\n<p>总的来说, 外层判断可以省略, 但是会略问增加资源消耗. 但内层判断必须保留, 否则总是会创建新的实例.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<p>再次调用之前的多线程函数获得结果:</p>\n<pre><code class=\"bash\">name0@0x1050e0b90\nname0@0x1050e0b90\nname0@0x1050e0b90\n</code></pre>\n<p>而同样的线程安全问题, 在通过装饰器实现的单例中同样存在. 因此对于装饰器方法也应进行修改:</p>\n<pre><code class=\"python\">def singleton(cls):\n    __instance = &#123;&#125;\n    __instance_lock = threading.Lock()\n\n    @functools.wraps(cls)\n    def instance(*args, **kwargs):\n        if cls not in __instance:\n            with __instance_lock:\n                if cls not in __instance:\n                    __instance[cls] = cls(*args, **kwargs)\n\n        return __instance[cls]\n    return instance\n</code></pre>\n<h3 id=\"基于-new-方法实现单例\"><a href=\"#基于-new-方法实现单例\" class=\"headerlink\" title=\"基于__new__方法实现单例\"></a>基于__new__方法实现单例</h3><p>通过上面的两种几种形式都可以实现单例, 但依旧有一个问题没有解决, 就是没有避免直接创建实例的误操作.</p>\n<p>在python中对象的实例化首先是通过<code>object</code>对象的<code>__new__</code>方法创建, 然后再调用<code>__init__</code>方法进行初始化的.</p>\n<p>所以重写<code>__new__</code>方法也可以实现单例.</p>\n<pre><code class=\"python\">import threading\n\n\nclass Singleton:\n\n    __instance_lock = threading.Lock()\n\n    def __init__(self):\n        if not hasattr(self, &#39;count&#39;):\n            self.count = 0\n        self.count += 1\n\n    @staticmethod\n    def instance():\n        return Singleton()\n\n    def __new__(cls, *args, **kwargs):\n        if not hasattr(cls, &#39;_instance&#39;):\n            with cls.__instance_lock:\n                if not hasattr(cls, &#39;_instance&#39;):\n                    cls._instance = object.__new__(cls)\n\n        return cls._instance\n\n    def __str__(self):\n        return f&quot;&lt;Singleton@&#123;hex(id(self))&#125; called:&#123;self.count&#125;&gt;&quot;\n\n\nif __name__ == &quot;__main__&quot;:\n\n    def single_thread():\n        s1 = Singleton()\n        s2 = Singleton()\n        s3 = Singleton.instance()\n\n        print(s1, s2, s3)\n\n    def task1():\n        s = Singleton()\n        print(s)\n\n    def task2():\n        s = Singleton.instance()\n        print(s)\n\n    def multiple_thread():\n        for _ in range(3):\n            threading.Thread(target=task1).start()\n            threading.Thread(target=task2).start()\n\n    multiple_thread()\n</code></pre>\n<p>输出结果:</p>\n<pre><code class=\"bash\">&lt;Singleton@0x1047dcd50 called:1&gt;\n&lt;Singleton@0x1047dcd50 called:2&gt;\n&lt;Singleton@0x1047dcd50 called:3&gt;\n&lt;Singleton@0x1047dcd50 called:4&gt;\n&lt;Singleton@0x1047dcd50 called:5&gt;\n&lt;Singleton@0x1047dcd50 called:6&gt;\n</code></pre>\n<p>在instance()静态方法中直接返回了一个实例化对象, 而通过重写<code>__new__</code>方法则修改了对象的创建方式.</p>\n<p>如此一来, 无论是通过instance方法还是直接创建, 都可以获得一个线程安全的单例对象.</p>\n<blockquote>\n<p>需要注意的是, 每次获取单例对象的时候本<code>__init__</code>方法都会被执行, 对象的生命周期并没有发生改变, 只是把创建对象的内存分配方式进行了修改.</p>\n<p>也就是说, 如果向初始化对象传递参数, 那么单例对象会被重复初始化, 并且状态停留在最后一次初始化的状态下. 而之前的初始化信息则会丢失.</p>\n</blockquote>\n<p>{: .prompt-warning}</p>\n<h3 id=\"通过metaclass来实现单例\"><a href=\"#通过metaclass来实现单例\" class=\"headerlink\" title=\"通过metaclass来实现单例\"></a>通过metaclass来实现单例</h3><p>基于metaclass来实现单例, 同样是通过修改初始化方式. 在python中对象实例的创建流程大致如下图所示:</p>\n<p><img src=\"/assets/img/img_202311241307079570.png\" alt=\"img\"></p>\n<p>本质上来说, 代码<code>Foo()</code>实际上是调用了metaclass也就是type的<code>__call__</code>方法.</p>\n<p>而type的__call__方法则是调用Foo继承自object或者重写的<code>__new__</code>方法获得一个新的空对象.</p>\n<p>随后再的调用Foo的<code>__init__</code>方法, 对空对象进行初始化, 最后将初始化完成的对象返回给调用者.</p>\n<p>所以, 实际返回实例化对象的方法是type.<strong>call</strong>, 而不是类的__init__.</p>\n<p>通过自定一个type类的子类, 重写其<code>__call__</code>方法, 便可以实现单例模式.</p>\n<p>修改后的流程大致如下图所示:</p>\n<p><img src=\"/assets/img/img_202311241434531606.png\" alt=\"img\"></p>\n<p>python实现代码:</p>\n<pre><code class=\"python\">import threading\n\n\nclass SingletonMeta(type):\n\n    __instance_lock = threading.Lock()\n\n    def __call__(cls, *args, **kwargs):\n        if not hasattr(cls, &#39;_instance&#39;):\n            with SingletonMeta.__instance_lock:\n                if not hasattr(cls, &#39;_instance&#39;):\n                    obj = object.__new__(cls)\n                    cls.__init__(obj, *args, **kwargs)\n                    cls._instance = obj\n        return cls._instance\n\n\nclass Singleton(metaclass=SingletonMeta):\n\n    def __init__(self, name):\n        self.name = name\n\n    def __str__(self):\n        return f&quot;&lt;&#123;self.name&#125;@&#123;hex(id(self))&#125;&gt;&quot;\n\n\nif __name__ == &quot;__main__&quot;:\n\n    def task(n):\n        s = Singleton(f&quot;s&#123;n&#125;&quot;)\n        print(s)\n\n    for i in range(3):\n        threading.Thread(target=task, args=(i,)).start()\n</code></pre>\n<p>输出结果:</p>\n<pre><code class=\"bash\">&lt;s0@0x100db4a90&gt;\n&lt;s0@0x100db4a90&gt;\n&lt;s0@0x100db4a90&gt;\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>虽然python实现单例的方式有很多, 但是总的来说还是觉得没有java简单便利.</p>\n<p>从几种放发的对比上来说, 最简单的莫过于通过模块实现.</p>\n<p>从重用的角度来说, 装饰器和元类模式是最好的.</p>\n<p>通过类方法实现在安全性上略差, 无法避免使用过程中误操作的实例化的潜在问题.</p>\n<p>通过__new__方法则是在重用性上有比较大的短板.</p>\n<p>综合来说, 直接通过模块实现单例, 或者通过元类来实现单例效果最佳.</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>单例模式属于比较常见的基础设计模式. 即一个类在全局中仅存在一个实例化的对象.</p>\n<p>比较常见的地方比如项目的配置管理对象. 因为保存了各个模块之间的统一配置信息以保证其在相同的环境下运行. 单例模式就是很好的选择.</p>\n<h2 id=\"简单的单例实现\"><a href=\"#简单的单例实现\" class=\"headerlink\" title=\"简单的单例实现\"></a>简单的单例实现</h2><p>简单的java单例</p>\n<pre><code class=\"java\">public class ConfigManager &#123;\n\n    private static ConfigManager instance = new ConfigManager();\n    private Map&lt;String, Object&gt; config = new HashMap&lt;String, Object&gt;();\n\n    private ConfigManager() &#123;\n    &#125;\n\n    public static ConfigManager getInstance() &#123;\n        return instance;\n    &#125;\n\n    public Object getConfig(String key) &#123;\n        return config.get(key);\n    &#125;\n\n    public void setConfig(String key, Object value) &#123;\n        config.put(key, value);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"python中的单例实现\"><a href=\"#python中的单例实现\" class=\"headerlink\" title=\"python中的单例实现\"></a>python中的单例实现</h2><p>作为比较常用的设计模式, python对于单例的实现相较java来说就差了点意思.</p>\n<h3 id=\"通过模块实现\"><a href=\"#通过模块实现\" class=\"headerlink\" title=\"通过模块实现\"></a>通过模块实现</h3><p>在python中每一个<code>.py</code>文件都被看做一个模块, 而模块本身就是单例的.</p>\n<p>因此最简单的单例实现方式就是直接在模块中定义类, 创建单例实例供外部引用</p>\n<pre><code class=\"python\"># singleton.py\nclass Singleton:\n\n    desc = &quot;this is a Singleton Class&quot;\n\n    def action(self):\n        print(self.desc)\n\n\ninstance = Singleton()\n\n# app.py\nfrom singleton import instance\n\ninstance.action()\n</code></pre>\n<h3 id=\"通过装饰器实现单例\"><a href=\"#通过装饰器实现单例\" class=\"headerlink\" title=\"通过装饰器实现单例\"></a>通过装饰器实现单例</h3><pre><code class=\"python\">import functools\n\n\ndef singleton(cls):\n    __instance = &#123;&#125;\n\n    @functools.wraps(cls)\n    def instance(*args, **kwargs):\n        if cls not in __instance:\n            __instance[cls] = cls(*args, **kwargs)\n        return __instance[cls]\n    return instance\n\n\n@singleton\nclass Singleton:\n\n    def __init__(self, name):\n        self.name = name\n\n    def __repr__(self):\n        return &quot;&lt;Singleton name=&#39;%s&#39; id=0x&#39;%x&#39;&gt;&quot; % (self.name, id(self))\n\n\nif __name__ == &quot;__main__&quot;:\n    s1 = Singleton(&quot;a&quot;)\n    s2 = Singleton(&quot;b&quot;)\n\n    print(repr(s1))\n    print(repr(s2))\n</code></pre>\n<p>输出结果:</p>\n<pre><code class=\"bash\">&lt;Singleton name=&#39;a&#39; id=&#39;0x100c49ed0&#39;&gt;\n&lt;Singleton name=&#39;a&#39; id=&#39;0x100c49ed0&#39;&gt;\n</code></pre>\n<p>虽然构造<code>s2</code>时使用了新的名称, 但是在最终输出的时候获得却是同一个对象, 名称和地址都没有改变.</p>\n<h3 id=\"通过类实现\"><a href=\"#通过类实现\" class=\"headerlink\" title=\"通过类实现\"></a>通过类实现</h3><pre><code class=\"python\">class Singleton:\n\n    def __init__(self, name):\n        self.name = name\n\n    @classmethod\n    def instance(cls, *args, **kwargs):\n        if not hasattr(Singleton, &#39;_instance&#39;):\n            Singleton._instance = Singleton(*args, **kwargs)\n\n        return Singleton._instance\n\n    def __str__(self):\n        return f&quot;&#123;self.name&#125;@0x&#123;hex(id(self))&#125;&quot;\n\n\nif __name__ == &quot;__main__&quot;:\n    s1 = Singleton.instance(&quot;s1&quot;)\n    s2 = Singleton.instance(&quot;s2&quot;)\n    s3 = Singleton(&quot;s3&quot;)\n\n    print(s1, s2, s3)\n</code></pre>\n<p>输出结果:</p>\n<pre><code class=\"bash\">s1@0x100f86090 s1@0x100f86090 s3@0x100f86210\n</code></pre>\n<h3 id=\"单例模式的线程安全问题\"><a href=\"#单例模式的线程安全问题\" class=\"headerlink\" title=\"单例模式的线程安全问题\"></a>单例模式的线程安全问题</h3><p>从结果上来看, 在调用instance()方法获取实例的时候是能够实现单例的, 但是存在两个问题:</p>\n<ol>\n<li>python的类不是线程安全的, 如果获取实例的间隔小于初始化的时间, 则可能存在多个实例.</li>\n<li>没有私有化的构造函数, 无法避免因为直接创建对象实例的误操作而产生的影响.</li>\n</ol>\n<p>如果延长类的构建时间, 并通过线程来调用单例类:</p>\n<pre><code class=\"python\"> def task(name):\n        s = Singleton.instance(name)\n        print(s)\n\n    for i in range(0, 3):\n        threading.Thread(target=task, args=[f&quot;name&#123;i&#125;&quot;,]).start()\n</code></pre>\n<p>得到的输出结果就是:</p>\n<pre><code class=\"bash\">name2@0x102b3d110\nname0@0x102b3ca90\nname1@0x102b3cdd0\n</code></pre>\n<p>显然, 每一个线程都创建了一个对象的实例.</p>\n<p>为了解决线程安全的问题, 需要对类的定义做一下处理:</p>\n<pre><code class=\"python\">@classmethod\n    def instance(cls, *args, **kwargs):\n        if not hasattr(Singleton, &#39;_instance&#39;):\n            with Singleton.__instance_lock:\n                if not hasattr(Singleton, &#39;_instance&#39;):\n                    Singleton._instance = Singleton(*args, **kwargs)\n\n        return Singleton._instance\n</code></pre>\n<blockquote>\n<p>进行两次<code>if not hasattr(Singleton, &#39;_instance&#39;):</code>判断的作用:</p>\n<ol>\n<li>判断当前有没有实例, 如果没有, 看看有没有锁, 如果有锁说明其他对象正在创建实例, 等待解锁;</li>\n<li>在别的线程解锁自己锁定后, 判断是否存在实例, 如果没有则创建实例</li>\n</ol>\n<p>外层判断最大的作用是避免在已经有实例的情况下开启线程锁, 增加资源消耗.</p>\n<p>内层判断的作用是避免其他线程创建成功后再次进行重复创建.</p>\n<p>总的来说, 外层判断可以省略, 但是会略问增加资源消耗. 但内层判断必须保留, 否则总是会创建新的实例.</p>\n</blockquote>\n<p>{: .prompt-tip}</p>\n<p>再次调用之前的多线程函数获得结果:</p>\n<pre><code class=\"bash\">name0@0x1050e0b90\nname0@0x1050e0b90\nname0@0x1050e0b90\n</code></pre>\n<p>而同样的线程安全问题, 在通过装饰器实现的单例中同样存在. 因此对于装饰器方法也应进行修改:</p>\n<pre><code class=\"python\">def singleton(cls):\n    __instance = &#123;&#125;\n    __instance_lock = threading.Lock()\n\n    @functools.wraps(cls)\n    def instance(*args, **kwargs):\n        if cls not in __instance:\n            with __instance_lock:\n                if cls not in __instance:\n                    __instance[cls] = cls(*args, **kwargs)\n\n        return __instance[cls]\n    return instance\n</code></pre>\n<h3 id=\"基于-new-方法实现单例\"><a href=\"#基于-new-方法实现单例\" class=\"headerlink\" title=\"基于__new__方法实现单例\"></a>基于__new__方法实现单例</h3><p>通过上面的两种几种形式都可以实现单例, 但依旧有一个问题没有解决, 就是没有避免直接创建实例的误操作.</p>\n<p>在python中对象的实例化首先是通过<code>object</code>对象的<code>__new__</code>方法创建, 然后再调用<code>__init__</code>方法进行初始化的.</p>\n<p>所以重写<code>__new__</code>方法也可以实现单例.</p>\n<pre><code class=\"python\">import threading\n\n\nclass Singleton:\n\n    __instance_lock = threading.Lock()\n\n    def __init__(self):\n        if not hasattr(self, &#39;count&#39;):\n            self.count = 0\n        self.count += 1\n\n    @staticmethod\n    def instance():\n        return Singleton()\n\n    def __new__(cls, *args, **kwargs):\n        if not hasattr(cls, &#39;_instance&#39;):\n            with cls.__instance_lock:\n                if not hasattr(cls, &#39;_instance&#39;):\n                    cls._instance = object.__new__(cls)\n\n        return cls._instance\n\n    def __str__(self):\n        return f&quot;&lt;Singleton@&#123;hex(id(self))&#125; called:&#123;self.count&#125;&gt;&quot;\n\n\nif __name__ == &quot;__main__&quot;:\n\n    def single_thread():\n        s1 = Singleton()\n        s2 = Singleton()\n        s3 = Singleton.instance()\n\n        print(s1, s2, s3)\n\n    def task1():\n        s = Singleton()\n        print(s)\n\n    def task2():\n        s = Singleton.instance()\n        print(s)\n\n    def multiple_thread():\n        for _ in range(3):\n            threading.Thread(target=task1).start()\n            threading.Thread(target=task2).start()\n\n    multiple_thread()\n</code></pre>\n<p>输出结果:</p>\n<pre><code class=\"bash\">&lt;Singleton@0x1047dcd50 called:1&gt;\n&lt;Singleton@0x1047dcd50 called:2&gt;\n&lt;Singleton@0x1047dcd50 called:3&gt;\n&lt;Singleton@0x1047dcd50 called:4&gt;\n&lt;Singleton@0x1047dcd50 called:5&gt;\n&lt;Singleton@0x1047dcd50 called:6&gt;\n</code></pre>\n<p>在instance()静态方法中直接返回了一个实例化对象, 而通过重写<code>__new__</code>方法则修改了对象的创建方式.</p>\n<p>如此一来, 无论是通过instance方法还是直接创建, 都可以获得一个线程安全的单例对象.</p>\n<blockquote>\n<p>需要注意的是, 每次获取单例对象的时候本<code>__init__</code>方法都会被执行, 对象的生命周期并没有发生改变, 只是把创建对象的内存分配方式进行了修改.</p>\n<p>也就是说, 如果向初始化对象传递参数, 那么单例对象会被重复初始化, 并且状态停留在最后一次初始化的状态下. 而之前的初始化信息则会丢失.</p>\n</blockquote>\n<p>{: .prompt-warning}</p>\n<h3 id=\"通过metaclass来实现单例\"><a href=\"#通过metaclass来实现单例\" class=\"headerlink\" title=\"通过metaclass来实现单例\"></a>通过metaclass来实现单例</h3><p>基于metaclass来实现单例, 同样是通过修改初始化方式. 在python中对象实例的创建流程大致如下图所示:</p>\n<p><img src=\"/assets/img/img_202311241307079570.png\" alt=\"img\"></p>\n<p>本质上来说, 代码<code>Foo()</code>实际上是调用了metaclass也就是type的<code>__call__</code>方法.</p>\n<p>而type的__call__方法则是调用Foo继承自object或者重写的<code>__new__</code>方法获得一个新的空对象.</p>\n<p>随后再的调用Foo的<code>__init__</code>方法, 对空对象进行初始化, 最后将初始化完成的对象返回给调用者.</p>\n<p>所以, 实际返回实例化对象的方法是type.<strong>call</strong>, 而不是类的__init__.</p>\n<p>通过自定一个type类的子类, 重写其<code>__call__</code>方法, 便可以实现单例模式.</p>\n<p>修改后的流程大致如下图所示:</p>\n<p><img src=\"/assets/img/img_202311241434531606.png\" alt=\"img\"></p>\n<p>python实现代码:</p>\n<pre><code class=\"python\">import threading\n\n\nclass SingletonMeta(type):\n\n    __instance_lock = threading.Lock()\n\n    def __call__(cls, *args, **kwargs):\n        if not hasattr(cls, &#39;_instance&#39;):\n            with SingletonMeta.__instance_lock:\n                if not hasattr(cls, &#39;_instance&#39;):\n                    obj = object.__new__(cls)\n                    cls.__init__(obj, *args, **kwargs)\n                    cls._instance = obj\n        return cls._instance\n\n\nclass Singleton(metaclass=SingletonMeta):\n\n    def __init__(self, name):\n        self.name = name\n\n    def __str__(self):\n        return f&quot;&lt;&#123;self.name&#125;@&#123;hex(id(self))&#125;&gt;&quot;\n\n\nif __name__ == &quot;__main__&quot;:\n\n    def task(n):\n        s = Singleton(f&quot;s&#123;n&#125;&quot;)\n        print(s)\n\n    for i in range(3):\n        threading.Thread(target=task, args=(i,)).start()\n</code></pre>\n<p>输出结果:</p>\n<pre><code class=\"bash\">&lt;s0@0x100db4a90&gt;\n&lt;s0@0x100db4a90&gt;\n&lt;s0@0x100db4a90&gt;\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>虽然python实现单例的方式有很多, 但是总的来说还是觉得没有java简单便利.</p>\n<p>从几种放发的对比上来说, 最简单的莫过于通过模块实现.</p>\n<p>从重用的角度来说, 装饰器和元类模式是最好的.</p>\n<p>通过类方法实现在安全性上略差, 无法避免使用过程中误操作的实例化的潜在问题.</p>\n<p>通过__new__方法则是在重用性上有比较大的短板.</p>\n<p>综合来说, 直接通过模块实现单例, 或者通过元类来实现单例效果最佳.</p>\n"},{"title":"设计模式-代理模式","date":"2023-11-23T16:25:25.000Z","mermaid":true,"_content":"\n## 应用场景\n\n代理模式是使用一个与目标对象外观完全一样的对象来用用作中间通信.\n\n与适配器不同, 适配器的作用是让一边的接口与另一边进行适配, 也就是改变了目标对象的外观.\n\n而对代理对象的操作与直接对目标操作没有任何区别.\n\n代理模式最大的作用就是解决在直接操作目标对象时的一些条件限制. 比如加速代理, 梯子代理等等.\n\n或者通过延迟加载降低通信频率, 减少资源消耗, 如ORM相关的对象等等.\n\n```mermaid\nclassDiagram\n    direction LR\n    class Client{\n        \n    }\n\n    class Subject{\n        <<intertface>>\n        + request()\n    }\n\n    class RealSubject{\n        + request()\n    }\n\n    class Proxy{\n        + request()\n    }\n\n    Client *--> Subject\n    Subject <|-- RealSubject : 实现\n    Subject <|-- Proxy : 实现\n    RealSubject <--* Proxy : 调用\n```\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\nfrom pathlib import Path\nimport os\nimport tracemalloc\n\n\nclass Books(ABC):\n\n    @abstractmethod\n    def show(self):\n        pass\n\n    @abstractmethod\n    def get_book_name(self):\n        pass\n\n\nclass Ebook(Books):\n\n    def __init__(self, name, path):\n        self.__name = name\n        self.__content = Path(path).read_text(encoding='utf-8')\n\n    def show(self):\n        print(f\"Content of book:{self.__name}`:\\n\\t{self.__content[0:20]}\")\n\n    def get_book_name(self):\n        return self.__name\n\n\nclass EBookProxy(Books):\n\n    def __init__(self, name, path):\n        self.__name = name\n        self.__path = path\n        self.__ebook = None\n\n    def show(self):\n        if self.__ebook is None:\n            self.__ebook = Ebook(self.__name, self.__path)\n\n        self.__ebook.show()\n\n    def get_book_name(self):\n        return self.__name\n\n\nclass BookStore:\n\n    def __init__(self, *books):\n        self.__books = {book.get_book_name(): book for book in books}\n\n    def book_list(self):\n        print(self.__books.keys())\n\n    def show_book(self, name):\n        if name in self.__books:\n            self.__books[name].show()\n\n\nif __name__ == \"__main__\":\n\n    def memory_test(clz):\n        tracemalloc.start()\n\n        books_dir = os.path.join(\n            os.path.abspath(os.path.curdir),\n            'ebooks')\n\n        book_list = os.listdir(books_dir)\n\n        books = [clz(name, os.path.join(books_dir, name))\n                 for name in book_list]\n\n        store = BookStore(*books)\n\n        store.book_list()\n        store.show_book(\"book 2.txt\")\n        snapshot = tracemalloc.take_snapshot()\n        stats = snapshot.statistics('lineno')\n\n        for stat in stats:\n            result = str(stat).rsplit('/', 1)[-1]\n            print(f\">> {result}\")\n\n        tracemalloc.stop()\n\n    memory_test(Ebook)\n    print(\"----\")\n    memory_test(EBookProxy)\n```\n\n最终输出结果:\n\n```bash\ndict_keys(['book 1.txt', 'book 2.txt', 'book 3.txt'])\nContent of book:book 2.txt`:\n## 应用场景\n\n代理模式是使用一个与目\n>> pathlib.py:1059: size=14.8 KiB, count=3, average=5068 B\n>> proxy_pattern.py:83: size=968 B, count=7, average=138 B\n>> proxy_pattern.py:86: size=320 B, count=2, average=160 B\n>> proxy_pattern.py:81: size=209 B, count=4, average=52 B\n>> pathlib.py:1044: size=201 B, count=3, average=67 B\n>> <frozen posixpath>:88: size=111 B, count=1, average=111 B\n>> proxy_pattern.py:36: size=48 B, count=1, average=48 B\n>> pathlib.py:540: size=48 B, count=1, average=48 B\n>> pathlib.py:496: size=48 B, count=1, average=48 B\n----\ndict_keys(['book 1.txt', 'book 2.txt', 'book 3.txt'])\nContent of book:book 2.txt`:\n## 应用场景\n\n代理模式是使用一个与目\n>> pathlib.py:1059: size=5068 B, count=1, average=5068 B\n>> proxy_pattern.py:83: size=968 B, count=7, average=138 B\n>> <frozen posixpath>:88: size=477 B, count=4, average=119 B\n>> proxy_pattern.py:86: size=312 B, count=2, average=156 B\n>> proxy_pattern.py:51: size=296 B, count=2, average=148 B\n>> proxy_pattern.py:81: size=209 B, count=4, average=52 B\n>> pathlib.py:1044: size=67 B, count=1, average=67 B\n```\n\n可以看到, 两种方式都能够正确执行程序, 但在通过代理进行延迟加载之后, 最大内存消耗的对象体积从`14.8K`降低到了`0.5k`.\n","source":"_posts/design-pattern/proxy-design-pattern-demo.md","raw":"---\ntitle: 设计模式-代理模式\ndate: 2023-11-24 00:25:25 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n## 应用场景\n\n代理模式是使用一个与目标对象外观完全一样的对象来用用作中间通信.\n\n与适配器不同, 适配器的作用是让一边的接口与另一边进行适配, 也就是改变了目标对象的外观.\n\n而对代理对象的操作与直接对目标操作没有任何区别.\n\n代理模式最大的作用就是解决在直接操作目标对象时的一些条件限制. 比如加速代理, 梯子代理等等.\n\n或者通过延迟加载降低通信频率, 减少资源消耗, 如ORM相关的对象等等.\n\n```mermaid\nclassDiagram\n    direction LR\n    class Client{\n        \n    }\n\n    class Subject{\n        <<intertface>>\n        + request()\n    }\n\n    class RealSubject{\n        + request()\n    }\n\n    class Proxy{\n        + request()\n    }\n\n    Client *--> Subject\n    Subject <|-- RealSubject : 实现\n    Subject <|-- Proxy : 实现\n    RealSubject <--* Proxy : 调用\n```\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\nfrom pathlib import Path\nimport os\nimport tracemalloc\n\n\nclass Books(ABC):\n\n    @abstractmethod\n    def show(self):\n        pass\n\n    @abstractmethod\n    def get_book_name(self):\n        pass\n\n\nclass Ebook(Books):\n\n    def __init__(self, name, path):\n        self.__name = name\n        self.__content = Path(path).read_text(encoding='utf-8')\n\n    def show(self):\n        print(f\"Content of book:{self.__name}`:\\n\\t{self.__content[0:20]}\")\n\n    def get_book_name(self):\n        return self.__name\n\n\nclass EBookProxy(Books):\n\n    def __init__(self, name, path):\n        self.__name = name\n        self.__path = path\n        self.__ebook = None\n\n    def show(self):\n        if self.__ebook is None:\n            self.__ebook = Ebook(self.__name, self.__path)\n\n        self.__ebook.show()\n\n    def get_book_name(self):\n        return self.__name\n\n\nclass BookStore:\n\n    def __init__(self, *books):\n        self.__books = {book.get_book_name(): book for book in books}\n\n    def book_list(self):\n        print(self.__books.keys())\n\n    def show_book(self, name):\n        if name in self.__books:\n            self.__books[name].show()\n\n\nif __name__ == \"__main__\":\n\n    def memory_test(clz):\n        tracemalloc.start()\n\n        books_dir = os.path.join(\n            os.path.abspath(os.path.curdir),\n            'ebooks')\n\n        book_list = os.listdir(books_dir)\n\n        books = [clz(name, os.path.join(books_dir, name))\n                 for name in book_list]\n\n        store = BookStore(*books)\n\n        store.book_list()\n        store.show_book(\"book 2.txt\")\n        snapshot = tracemalloc.take_snapshot()\n        stats = snapshot.statistics('lineno')\n\n        for stat in stats:\n            result = str(stat).rsplit('/', 1)[-1]\n            print(f\">> {result}\")\n\n        tracemalloc.stop()\n\n    memory_test(Ebook)\n    print(\"----\")\n    memory_test(EBookProxy)\n```\n\n最终输出结果:\n\n```bash\ndict_keys(['book 1.txt', 'book 2.txt', 'book 3.txt'])\nContent of book:book 2.txt`:\n## 应用场景\n\n代理模式是使用一个与目\n>> pathlib.py:1059: size=14.8 KiB, count=3, average=5068 B\n>> proxy_pattern.py:83: size=968 B, count=7, average=138 B\n>> proxy_pattern.py:86: size=320 B, count=2, average=160 B\n>> proxy_pattern.py:81: size=209 B, count=4, average=52 B\n>> pathlib.py:1044: size=201 B, count=3, average=67 B\n>> <frozen posixpath>:88: size=111 B, count=1, average=111 B\n>> proxy_pattern.py:36: size=48 B, count=1, average=48 B\n>> pathlib.py:540: size=48 B, count=1, average=48 B\n>> pathlib.py:496: size=48 B, count=1, average=48 B\n----\ndict_keys(['book 1.txt', 'book 2.txt', 'book 3.txt'])\nContent of book:book 2.txt`:\n## 应用场景\n\n代理模式是使用一个与目\n>> pathlib.py:1059: size=5068 B, count=1, average=5068 B\n>> proxy_pattern.py:83: size=968 B, count=7, average=138 B\n>> <frozen posixpath>:88: size=477 B, count=4, average=119 B\n>> proxy_pattern.py:86: size=312 B, count=2, average=156 B\n>> proxy_pattern.py:51: size=296 B, count=2, average=148 B\n>> proxy_pattern.py:81: size=209 B, count=4, average=52 B\n>> pathlib.py:1044: size=67 B, count=1, average=67 B\n```\n\n可以看到, 两种方式都能够正确执行程序, 但在通过代理进行延迟加载之后, 最大内存消耗的对象体积从`14.8K`降低到了`0.5k`.\n","slug":"design-pattern-proxy-design-pattern-demo","published":1,"updated":"2023-12-13T08:43:58.100Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5vk00bpi3er26ps7cta","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>代理模式是使用一个与目标对象外观完全一样的对象来用用作中间通信.</p>\n<p>与适配器不同, 适配器的作用是让一边的接口与另一边进行适配, 也就是改变了目标对象的外观.</p>\n<p>而对代理对象的操作与直接对目标操作没有任何区别.</p>\n<p>代理模式最大的作用就是解决在直接操作目标对象时的一些条件限制. 比如加速代理, 梯子代理等等.</p>\n<p>或者通过延迟加载降低通信频率, 减少资源消耗, 如ORM相关的对象等等.</p>\n<pre><code class=\"mermaid\">classDiagram\n    direction LR\n    class Client&#123;\n        \n    &#125;\n\n    class Subject&#123;\n        &lt;&lt;intertface&gt;&gt;\n        + request()\n    &#125;\n\n    class RealSubject&#123;\n        + request()\n    &#125;\n\n    class Proxy&#123;\n        + request()\n    &#125;\n\n    Client *--&gt; Subject\n    Subject &lt;|-- RealSubject : 实现\n    Subject &lt;|-- Proxy : 实现\n    RealSubject &lt;--* Proxy : 调用\n</code></pre>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\nfrom pathlib import Path\nimport os\nimport tracemalloc\n\n\nclass Books(ABC):\n\n    @abstractmethod\n    def show(self):\n        pass\n\n    @abstractmethod\n    def get_book_name(self):\n        pass\n\n\nclass Ebook(Books):\n\n    def __init__(self, name, path):\n        self.__name = name\n        self.__content = Path(path).read_text(encoding=&#39;utf-8&#39;)\n\n    def show(self):\n        print(f&quot;Content of book:&#123;self.__name&#125;`:\\n\\t&#123;self.__content[0:20]&#125;&quot;)\n\n    def get_book_name(self):\n        return self.__name\n\n\nclass EBookProxy(Books):\n\n    def __init__(self, name, path):\n        self.__name = name\n        self.__path = path\n        self.__ebook = None\n\n    def show(self):\n        if self.__ebook is None:\n            self.__ebook = Ebook(self.__name, self.__path)\n\n        self.__ebook.show()\n\n    def get_book_name(self):\n        return self.__name\n\n\nclass BookStore:\n\n    def __init__(self, *books):\n        self.__books = &#123;book.get_book_name(): book for book in books&#125;\n\n    def book_list(self):\n        print(self.__books.keys())\n\n    def show_book(self, name):\n        if name in self.__books:\n            self.__books[name].show()\n\n\nif __name__ == &quot;__main__&quot;:\n\n    def memory_test(clz):\n        tracemalloc.start()\n\n        books_dir = os.path.join(\n            os.path.abspath(os.path.curdir),\n            &#39;ebooks&#39;)\n\n        book_list = os.listdir(books_dir)\n\n        books = [clz(name, os.path.join(books_dir, name))\n                 for name in book_list]\n\n        store = BookStore(*books)\n\n        store.book_list()\n        store.show_book(&quot;book 2.txt&quot;)\n        snapshot = tracemalloc.take_snapshot()\n        stats = snapshot.statistics(&#39;lineno&#39;)\n\n        for stat in stats:\n            result = str(stat).rsplit(&#39;/&#39;, 1)[-1]\n            print(f&quot;&gt;&gt; &#123;result&#125;&quot;)\n\n        tracemalloc.stop()\n\n    memory_test(Ebook)\n    print(&quot;----&quot;)\n    memory_test(EBookProxy)\n</code></pre>\n<p>最终输出结果:</p>\n<pre><code class=\"bash\">dict_keys([&#39;book 1.txt&#39;, &#39;book 2.txt&#39;, &#39;book 3.txt&#39;])\nContent of book:book 2.txt`:\n## 应用场景\n\n代理模式是使用一个与目\n&gt;&gt; pathlib.py:1059: size=14.8 KiB, count=3, average=5068 B\n&gt;&gt; proxy_pattern.py:83: size=968 B, count=7, average=138 B\n&gt;&gt; proxy_pattern.py:86: size=320 B, count=2, average=160 B\n&gt;&gt; proxy_pattern.py:81: size=209 B, count=4, average=52 B\n&gt;&gt; pathlib.py:1044: size=201 B, count=3, average=67 B\n&gt;&gt; &lt;frozen posixpath&gt;:88: size=111 B, count=1, average=111 B\n&gt;&gt; proxy_pattern.py:36: size=48 B, count=1, average=48 B\n&gt;&gt; pathlib.py:540: size=48 B, count=1, average=48 B\n&gt;&gt; pathlib.py:496: size=48 B, count=1, average=48 B\n----\ndict_keys([&#39;book 1.txt&#39;, &#39;book 2.txt&#39;, &#39;book 3.txt&#39;])\nContent of book:book 2.txt`:\n## 应用场景\n\n代理模式是使用一个与目\n&gt;&gt; pathlib.py:1059: size=5068 B, count=1, average=5068 B\n&gt;&gt; proxy_pattern.py:83: size=968 B, count=7, average=138 B\n&gt;&gt; &lt;frozen posixpath&gt;:88: size=477 B, count=4, average=119 B\n&gt;&gt; proxy_pattern.py:86: size=312 B, count=2, average=156 B\n&gt;&gt; proxy_pattern.py:51: size=296 B, count=2, average=148 B\n&gt;&gt; proxy_pattern.py:81: size=209 B, count=4, average=52 B\n&gt;&gt; pathlib.py:1044: size=67 B, count=1, average=67 B\n</code></pre>\n<p>可以看到, 两种方式都能够正确执行程序, 但在通过代理进行延迟加载之后, 最大内存消耗的对象体积从<code>14.8K</code>降低到了<code>0.5k</code>.</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>代理模式是使用一个与目标对象外观完全一样的对象来用用作中间通信.</p>\n<p>与适配器不同, 适配器的作用是让一边的接口与另一边进行适配, 也就是改变了目标对象的外观.</p>\n<p>而对代理对象的操作与直接对目标操作没有任何区别.</p>\n<p>代理模式最大的作用就是解决在直接操作目标对象时的一些条件限制. 比如加速代理, 梯子代理等等.</p>\n<p>或者通过延迟加载降低通信频率, 减少资源消耗, 如ORM相关的对象等等.</p>\n<pre><code class=\"mermaid\">classDiagram\n    direction LR\n    class Client&#123;\n        \n    &#125;\n\n    class Subject&#123;\n        &lt;&lt;intertface&gt;&gt;\n        + request()\n    &#125;\n\n    class RealSubject&#123;\n        + request()\n    &#125;\n\n    class Proxy&#123;\n        + request()\n    &#125;\n\n    Client *--&gt; Subject\n    Subject &lt;|-- RealSubject : 实现\n    Subject &lt;|-- Proxy : 实现\n    RealSubject &lt;--* Proxy : 调用\n</code></pre>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\nfrom pathlib import Path\nimport os\nimport tracemalloc\n\n\nclass Books(ABC):\n\n    @abstractmethod\n    def show(self):\n        pass\n\n    @abstractmethod\n    def get_book_name(self):\n        pass\n\n\nclass Ebook(Books):\n\n    def __init__(self, name, path):\n        self.__name = name\n        self.__content = Path(path).read_text(encoding=&#39;utf-8&#39;)\n\n    def show(self):\n        print(f&quot;Content of book:&#123;self.__name&#125;`:\\n\\t&#123;self.__content[0:20]&#125;&quot;)\n\n    def get_book_name(self):\n        return self.__name\n\n\nclass EBookProxy(Books):\n\n    def __init__(self, name, path):\n        self.__name = name\n        self.__path = path\n        self.__ebook = None\n\n    def show(self):\n        if self.__ebook is None:\n            self.__ebook = Ebook(self.__name, self.__path)\n\n        self.__ebook.show()\n\n    def get_book_name(self):\n        return self.__name\n\n\nclass BookStore:\n\n    def __init__(self, *books):\n        self.__books = &#123;book.get_book_name(): book for book in books&#125;\n\n    def book_list(self):\n        print(self.__books.keys())\n\n    def show_book(self, name):\n        if name in self.__books:\n            self.__books[name].show()\n\n\nif __name__ == &quot;__main__&quot;:\n\n    def memory_test(clz):\n        tracemalloc.start()\n\n        books_dir = os.path.join(\n            os.path.abspath(os.path.curdir),\n            &#39;ebooks&#39;)\n\n        book_list = os.listdir(books_dir)\n\n        books = [clz(name, os.path.join(books_dir, name))\n                 for name in book_list]\n\n        store = BookStore(*books)\n\n        store.book_list()\n        store.show_book(&quot;book 2.txt&quot;)\n        snapshot = tracemalloc.take_snapshot()\n        stats = snapshot.statistics(&#39;lineno&#39;)\n\n        for stat in stats:\n            result = str(stat).rsplit(&#39;/&#39;, 1)[-1]\n            print(f&quot;&gt;&gt; &#123;result&#125;&quot;)\n\n        tracemalloc.stop()\n\n    memory_test(Ebook)\n    print(&quot;----&quot;)\n    memory_test(EBookProxy)\n</code></pre>\n<p>最终输出结果:</p>\n<pre><code class=\"bash\">dict_keys([&#39;book 1.txt&#39;, &#39;book 2.txt&#39;, &#39;book 3.txt&#39;])\nContent of book:book 2.txt`:\n## 应用场景\n\n代理模式是使用一个与目\n&gt;&gt; pathlib.py:1059: size=14.8 KiB, count=3, average=5068 B\n&gt;&gt; proxy_pattern.py:83: size=968 B, count=7, average=138 B\n&gt;&gt; proxy_pattern.py:86: size=320 B, count=2, average=160 B\n&gt;&gt; proxy_pattern.py:81: size=209 B, count=4, average=52 B\n&gt;&gt; pathlib.py:1044: size=201 B, count=3, average=67 B\n&gt;&gt; &lt;frozen posixpath&gt;:88: size=111 B, count=1, average=111 B\n&gt;&gt; proxy_pattern.py:36: size=48 B, count=1, average=48 B\n&gt;&gt; pathlib.py:540: size=48 B, count=1, average=48 B\n&gt;&gt; pathlib.py:496: size=48 B, count=1, average=48 B\n----\ndict_keys([&#39;book 1.txt&#39;, &#39;book 2.txt&#39;, &#39;book 3.txt&#39;])\nContent of book:book 2.txt`:\n## 应用场景\n\n代理模式是使用一个与目\n&gt;&gt; pathlib.py:1059: size=5068 B, count=1, average=5068 B\n&gt;&gt; proxy_pattern.py:83: size=968 B, count=7, average=138 B\n&gt;&gt; &lt;frozen posixpath&gt;:88: size=477 B, count=4, average=119 B\n&gt;&gt; proxy_pattern.py:86: size=312 B, count=2, average=156 B\n&gt;&gt; proxy_pattern.py:51: size=296 B, count=2, average=148 B\n&gt;&gt; proxy_pattern.py:81: size=209 B, count=4, average=52 B\n&gt;&gt; pathlib.py:1044: size=67 B, count=1, average=67 B\n</code></pre>\n<p>可以看到, 两种方式都能够正确执行程序, 但在通过代理进行延迟加载之后, 最大内存消耗的对象体积从<code>14.8K</code>降低到了<code>0.5k</code>.</p>\n"},{"title":"设计模式-访问者模式","date":"2023-11-21T11:08:33.000Z","mermaid":true,"_content":"\n## 应用场景\n\n访问者模式最常见的应用场景在于对已有功能的扩展. 假设有这样一套类:\n\n```mermaid\nclassDiagram\n    class HTMLNode{\n        <<interface>>\n        get_text()\n        highlight()\n    }\n    class DIV{\n        get_text()\n        highlight()\n    }\n    class Paragraph{\n        get_text()\n        highlight()\n    }\n    class Link{\n        get_text()\n        highlight()\n    }\n    class Head{\n        get_text()\n        highlight()\n    }\n    class Body{\n        get_text()\n        highlight()\n    }\n    class Others{\n        get_text()\n        highlight()\n    }\n\n    DIV --|> HTMLNode\n    Paragraph --|> HTMLNode\n    Link --|> HTMLNode\n    Body --|> HTMLNode\n    Head --|> HTMLNode\n    Others --|> HTMLNode\n```\n\n定义一个`HTMLNode`, 然后定义各种类型的HTML标签对应的类来继承该接口. 从结构上来讲并没有什么问题.\n\n但会存在两个问题:\n\n1. 在编码的过程中需要再所有的子类中实现接口中的方法, 通常伴随着大量的重复内容.\n2. 如果忽然有一天发现接口需要增加某个功能, 那直接面对的就是一堆的编译错误. 因为所有实现了这个接口的类都必须单独重新实现这一新增的接口方法. 显然违背了开关原则.\n\n这时就可以考虑使用访问者模式, 不将新方法添加到接口里, 而是让接口依赖于另外一个管理操作的接口, 由其具体实现对象来进行不同的操作. 大致结构如下:\n\n```mermaid\nclassDiagram\n    class HTMLNode{\n        <<interface>>\n        execute(operation)\n    }\n    class DIV{\n        execute(operation)\n    }\n    class Paragraph{\n        execute(operation)\n    }\n    class Link{\n        execute(operation)\n    }\n    class Others{\n        execute(operation)\n    }\n\n    class NodeOperation{\n        <<interface>>\n        apply(HTMLNode)\n    }\n\n    class GetTextOperation{\n        apply(HTMLNode)\n    }\n\n    class HighLightOperation{\n        apply(HTMLNode)\n    }\n\n    class MoreOperations{\n        apply(HTMLNode)\n    }\n\n    DIV --|> HTMLNode\n    Paragraph --|> HTMLNode\n    Link --|> HTMLNode\n    Others --|> HTMLNode\n    HTMLNode *--> NodeOperation\n\n    NodeOperation <|-- GetTextOperation\n    NodeOperation <|-- HighLightOperation\n    NodeOperation <|-- MoreOperations\n```\n\n如此一来便将对象和操作进行了分离, 当希望对象能够执行新的操作时也不需要对对象本身进行修改, 而是通过扩展`Operation`的实现类即可完成.\n\n就好比身为汽车人领袖的擎天柱, 出厂设定时苦哈哈的实现了汽车人接口, 从此要么腿儿着要么滚着~\n\n遥望翱翔天际的好兄弟威震天, 心里想着什么时候咱爷们儿也能体验一把飞一般的赶脚~嘴上还是得跟伙计们高声呐喊, Autobots! Roll out!\n\n恰逢好兄弟威震天的小老弟天火到访, 那真是打瞌睡掉枕头~咱擎爷一点不含糊, 下手干净利索快, `execute`了天火老爷子就给自己`apply`上了~~出厂标配不会飞? 那都不叫事儿~\n\n![preview](/assets/img/img_202311211957171241.png)\n\n别跟我说电影里是天火老爷子给自己拆了, 不光历史是个任人打扮的老娘...小姑娘, 电影也一样~\n\n咱擎爷那是正面人物! 这种浓眉大眼的正面人物怎么能叛变革命呢!\n\n于是擎爷名正言顺的拾取了顶级飞行套件天火套装~~穿了一次飞没多远发现自己晕高, 落地就给扔了~\n\n突出一个拔那啥无情.\n\n你说就这顶配版渣男的造型, 要是哪天想穿个皮草了? 超能勇士不得变成下一个大冤, 不是, 下一个为了正义牺牲的大英雄了.\n\n也就俩人邂逅在热带, 保不齐皮厚了对发动机散热不好. 这家伙要来趟东北?\n\n![preview](/assets/img/img_202311212007505770.png)\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass Parts(ABC):\n\n    @abstractmethod\n    def apply(self, target, *args, **kwargs):\n        pass\n\n\nclass Autobot(ABC):\n\n    def __init__(self, name, slogan=None):\n        self.name = name\n        self.slogan = slogan\n        self.flyable = False\n\n    @abstractmethod\n    def rolling(self):\n        pass\n\n    def powerup(self, part: Parts):\n        part.apply(self)\n\n\nclass Prime(Autobot):\n\n    def __init__(self):\n        super().__init__(\"OPtimus Prime\", \"Freedom is everyone's right.\")\n\n    def rolling(self):\n        if self.flyable:\n            print(self.name + ' is ro~ro~的.')\n        else:\n            print(self.name + \" is rolling out~!\")\n\n    def powerup(self, part: Parts):\n        part.apply(self)\n        print(f\">> {self.name}: You will always live in our memory.\")\n\n\nclass Bumblebee(Autobot):\n\n    def __init__(self):\n        super().__init__(\"Bumblebee\", \"bi...\")\n\n    def rolling(self):\n        print(\"bi bi di di ga...\")\n\n\nclass JetFire(Parts):\n\n    def apply(self, target, *args, **kwargs):\n        if isinstance(target, Autobot):\n            print(f\">> JetFire: {target.name}! 我$%^&*...\")\n            target.flyable = True\n            print(\n                f\">> NOTICE: {target.name} picked up JetFire Suit! He can fly now!\")\n\n\nif __name__ == \"__main__\":\n    prime = Prime()\n    prime.rolling()\n    prime.powerup(JetFire())\n    prime.rolling()\n\n```\n\n嗯...输出结果:\n\n```bash\nOptimus Prime is rolling out~!\n>> JetFire: OPtimus Prime! 我$%^&*...\n>> NOTICE: OPtimus Prime picked up JetFire Suit! He can fly now!\n>> OPtimus Prime: You will always live in our memory.\nOPtimus Prime is ro~ro~的.\n```\n","source":"_posts/design-pattern/visitor-design-pattern.md","raw":"---\ntitle: 设计模式-访问者模式\ndate: 2023-11-21 19:08:33 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern', ⭐️]\nmermaid: true\n---\n\n## 应用场景\n\n访问者模式最常见的应用场景在于对已有功能的扩展. 假设有这样一套类:\n\n```mermaid\nclassDiagram\n    class HTMLNode{\n        <<interface>>\n        get_text()\n        highlight()\n    }\n    class DIV{\n        get_text()\n        highlight()\n    }\n    class Paragraph{\n        get_text()\n        highlight()\n    }\n    class Link{\n        get_text()\n        highlight()\n    }\n    class Head{\n        get_text()\n        highlight()\n    }\n    class Body{\n        get_text()\n        highlight()\n    }\n    class Others{\n        get_text()\n        highlight()\n    }\n\n    DIV --|> HTMLNode\n    Paragraph --|> HTMLNode\n    Link --|> HTMLNode\n    Body --|> HTMLNode\n    Head --|> HTMLNode\n    Others --|> HTMLNode\n```\n\n定义一个`HTMLNode`, 然后定义各种类型的HTML标签对应的类来继承该接口. 从结构上来讲并没有什么问题.\n\n但会存在两个问题:\n\n1. 在编码的过程中需要再所有的子类中实现接口中的方法, 通常伴随着大量的重复内容.\n2. 如果忽然有一天发现接口需要增加某个功能, 那直接面对的就是一堆的编译错误. 因为所有实现了这个接口的类都必须单独重新实现这一新增的接口方法. 显然违背了开关原则.\n\n这时就可以考虑使用访问者模式, 不将新方法添加到接口里, 而是让接口依赖于另外一个管理操作的接口, 由其具体实现对象来进行不同的操作. 大致结构如下:\n\n```mermaid\nclassDiagram\n    class HTMLNode{\n        <<interface>>\n        execute(operation)\n    }\n    class DIV{\n        execute(operation)\n    }\n    class Paragraph{\n        execute(operation)\n    }\n    class Link{\n        execute(operation)\n    }\n    class Others{\n        execute(operation)\n    }\n\n    class NodeOperation{\n        <<interface>>\n        apply(HTMLNode)\n    }\n\n    class GetTextOperation{\n        apply(HTMLNode)\n    }\n\n    class HighLightOperation{\n        apply(HTMLNode)\n    }\n\n    class MoreOperations{\n        apply(HTMLNode)\n    }\n\n    DIV --|> HTMLNode\n    Paragraph --|> HTMLNode\n    Link --|> HTMLNode\n    Others --|> HTMLNode\n    HTMLNode *--> NodeOperation\n\n    NodeOperation <|-- GetTextOperation\n    NodeOperation <|-- HighLightOperation\n    NodeOperation <|-- MoreOperations\n```\n\n如此一来便将对象和操作进行了分离, 当希望对象能够执行新的操作时也不需要对对象本身进行修改, 而是通过扩展`Operation`的实现类即可完成.\n\n就好比身为汽车人领袖的擎天柱, 出厂设定时苦哈哈的实现了汽车人接口, 从此要么腿儿着要么滚着~\n\n遥望翱翔天际的好兄弟威震天, 心里想着什么时候咱爷们儿也能体验一把飞一般的赶脚~嘴上还是得跟伙计们高声呐喊, Autobots! Roll out!\n\n恰逢好兄弟威震天的小老弟天火到访, 那真是打瞌睡掉枕头~咱擎爷一点不含糊, 下手干净利索快, `execute`了天火老爷子就给自己`apply`上了~~出厂标配不会飞? 那都不叫事儿~\n\n![preview](/assets/img/img_202311211957171241.png)\n\n别跟我说电影里是天火老爷子给自己拆了, 不光历史是个任人打扮的老娘...小姑娘, 电影也一样~\n\n咱擎爷那是正面人物! 这种浓眉大眼的正面人物怎么能叛变革命呢!\n\n于是擎爷名正言顺的拾取了顶级飞行套件天火套装~~穿了一次飞没多远发现自己晕高, 落地就给扔了~\n\n突出一个拔那啥无情.\n\n你说就这顶配版渣男的造型, 要是哪天想穿个皮草了? 超能勇士不得变成下一个大冤, 不是, 下一个为了正义牺牲的大英雄了.\n\n也就俩人邂逅在热带, 保不齐皮厚了对发动机散热不好. 这家伙要来趟东北?\n\n![preview](/assets/img/img_202311212007505770.png)\n\n## 简单的python实现\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass Parts(ABC):\n\n    @abstractmethod\n    def apply(self, target, *args, **kwargs):\n        pass\n\n\nclass Autobot(ABC):\n\n    def __init__(self, name, slogan=None):\n        self.name = name\n        self.slogan = slogan\n        self.flyable = False\n\n    @abstractmethod\n    def rolling(self):\n        pass\n\n    def powerup(self, part: Parts):\n        part.apply(self)\n\n\nclass Prime(Autobot):\n\n    def __init__(self):\n        super().__init__(\"OPtimus Prime\", \"Freedom is everyone's right.\")\n\n    def rolling(self):\n        if self.flyable:\n            print(self.name + ' is ro~ro~的.')\n        else:\n            print(self.name + \" is rolling out~!\")\n\n    def powerup(self, part: Parts):\n        part.apply(self)\n        print(f\">> {self.name}: You will always live in our memory.\")\n\n\nclass Bumblebee(Autobot):\n\n    def __init__(self):\n        super().__init__(\"Bumblebee\", \"bi...\")\n\n    def rolling(self):\n        print(\"bi bi di di ga...\")\n\n\nclass JetFire(Parts):\n\n    def apply(self, target, *args, **kwargs):\n        if isinstance(target, Autobot):\n            print(f\">> JetFire: {target.name}! 我$%^&*...\")\n            target.flyable = True\n            print(\n                f\">> NOTICE: {target.name} picked up JetFire Suit! He can fly now!\")\n\n\nif __name__ == \"__main__\":\n    prime = Prime()\n    prime.rolling()\n    prime.powerup(JetFire())\n    prime.rolling()\n\n```\n\n嗯...输出结果:\n\n```bash\nOptimus Prime is rolling out~!\n>> JetFire: OPtimus Prime! 我$%^&*...\n>> NOTICE: OPtimus Prime picked up JetFire Suit! He can fly now!\n>> OPtimus Prime: You will always live in our memory.\nOPtimus Prime is ro~ro~的.\n```\n","slug":"design-pattern-visitor-design-pattern","published":1,"updated":"2023-12-13T08:43:58.102Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5vk00bsi3erdtnnh9g5","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>访问者模式最常见的应用场景在于对已有功能的扩展. 假设有这样一套类:</p>\n<pre><code class=\"mermaid\">classDiagram\n    class HTMLNode&#123;\n        &lt;&lt;interface&gt;&gt;\n        get_text()\n        highlight()\n    &#125;\n    class DIV&#123;\n        get_text()\n        highlight()\n    &#125;\n    class Paragraph&#123;\n        get_text()\n        highlight()\n    &#125;\n    class Link&#123;\n        get_text()\n        highlight()\n    &#125;\n    class Head&#123;\n        get_text()\n        highlight()\n    &#125;\n    class Body&#123;\n        get_text()\n        highlight()\n    &#125;\n    class Others&#123;\n        get_text()\n        highlight()\n    &#125;\n\n    DIV --|&gt; HTMLNode\n    Paragraph --|&gt; HTMLNode\n    Link --|&gt; HTMLNode\n    Body --|&gt; HTMLNode\n    Head --|&gt; HTMLNode\n    Others --|&gt; HTMLNode\n</code></pre>\n<p>定义一个<code>HTMLNode</code>, 然后定义各种类型的HTML标签对应的类来继承该接口. 从结构上来讲并没有什么问题.</p>\n<p>但会存在两个问题:</p>\n<ol>\n<li>在编码的过程中需要再所有的子类中实现接口中的方法, 通常伴随着大量的重复内容.</li>\n<li>如果忽然有一天发现接口需要增加某个功能, 那直接面对的就是一堆的编译错误. 因为所有实现了这个接口的类都必须单独重新实现这一新增的接口方法. 显然违背了开关原则.</li>\n</ol>\n<p>这时就可以考虑使用访问者模式, 不将新方法添加到接口里, 而是让接口依赖于另外一个管理操作的接口, 由其具体实现对象来进行不同的操作. 大致结构如下:</p>\n<pre><code class=\"mermaid\">classDiagram\n    class HTMLNode&#123;\n        &lt;&lt;interface&gt;&gt;\n        execute(operation)\n    &#125;\n    class DIV&#123;\n        execute(operation)\n    &#125;\n    class Paragraph&#123;\n        execute(operation)\n    &#125;\n    class Link&#123;\n        execute(operation)\n    &#125;\n    class Others&#123;\n        execute(operation)\n    &#125;\n\n    class NodeOperation&#123;\n        &lt;&lt;interface&gt;&gt;\n        apply(HTMLNode)\n    &#125;\n\n    class GetTextOperation&#123;\n        apply(HTMLNode)\n    &#125;\n\n    class HighLightOperation&#123;\n        apply(HTMLNode)\n    &#125;\n\n    class MoreOperations&#123;\n        apply(HTMLNode)\n    &#125;\n\n    DIV --|&gt; HTMLNode\n    Paragraph --|&gt; HTMLNode\n    Link --|&gt; HTMLNode\n    Others --|&gt; HTMLNode\n    HTMLNode *--&gt; NodeOperation\n\n    NodeOperation &lt;|-- GetTextOperation\n    NodeOperation &lt;|-- HighLightOperation\n    NodeOperation &lt;|-- MoreOperations\n</code></pre>\n<p>如此一来便将对象和操作进行了分离, 当希望对象能够执行新的操作时也不需要对对象本身进行修改, 而是通过扩展<code>Operation</code>的实现类即可完成.</p>\n<p>就好比身为汽车人领袖的擎天柱, 出厂设定时苦哈哈的实现了汽车人接口, 从此要么腿儿着要么滚着~</p>\n<p>遥望翱翔天际的好兄弟威震天, 心里想着什么时候咱爷们儿也能体验一把飞一般的赶脚~嘴上还是得跟伙计们高声呐喊, Autobots! Roll out!</p>\n<p>恰逢好兄弟威震天的小老弟天火到访, 那真是打瞌睡掉枕头<del>咱擎爷一点不含糊, 下手干净利索快, <code>execute</code>了天火老爷子就给自己<code>apply</code>上了~~出厂标配不会飞? 那都不叫事儿</del></p>\n<p><img src=\"/assets/img/img_202311211957171241.png\" alt=\"preview\"></p>\n<p>别跟我说电影里是天火老爷子给自己拆了, 不光历史是个任人打扮的老娘…小姑娘, 电影也一样~</p>\n<p>咱擎爷那是正面人物! 这种浓眉大眼的正面人物怎么能叛变革命呢!</p>\n<p>于是擎爷名正言顺的拾取了顶级飞行套件天火套装~~穿了一次飞没多远发现自己晕高, 落地就给扔了~</p>\n<p>突出一个拔那啥无情.</p>\n<p>你说就这顶配版渣男的造型, 要是哪天想穿个皮草了? 超能勇士不得变成下一个大冤, 不是, 下一个为了正义牺牲的大英雄了.</p>\n<p>也就俩人邂逅在热带, 保不齐皮厚了对发动机散热不好. 这家伙要来趟东北?</p>\n<p><img src=\"/assets/img/img_202311212007505770.png\" alt=\"preview\"></p>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\n\n\nclass Parts(ABC):\n\n    @abstractmethod\n    def apply(self, target, *args, **kwargs):\n        pass\n\n\nclass Autobot(ABC):\n\n    def __init__(self, name, slogan=None):\n        self.name = name\n        self.slogan = slogan\n        self.flyable = False\n\n    @abstractmethod\n    def rolling(self):\n        pass\n\n    def powerup(self, part: Parts):\n        part.apply(self)\n\n\nclass Prime(Autobot):\n\n    def __init__(self):\n        super().__init__(&quot;OPtimus Prime&quot;, &quot;Freedom is everyone&#39;s right.&quot;)\n\n    def rolling(self):\n        if self.flyable:\n            print(self.name + &#39; is ro~ro~的.&#39;)\n        else:\n            print(self.name + &quot; is rolling out~!&quot;)\n\n    def powerup(self, part: Parts):\n        part.apply(self)\n        print(f&quot;&gt;&gt; &#123;self.name&#125;: You will always live in our memory.&quot;)\n\n\nclass Bumblebee(Autobot):\n\n    def __init__(self):\n        super().__init__(&quot;Bumblebee&quot;, &quot;bi...&quot;)\n\n    def rolling(self):\n        print(&quot;bi bi di di ga...&quot;)\n\n\nclass JetFire(Parts):\n\n    def apply(self, target, *args, **kwargs):\n        if isinstance(target, Autobot):\n            print(f&quot;&gt;&gt; JetFire: &#123;target.name&#125;! 我$%^&amp;*...&quot;)\n            target.flyable = True\n            print(\n                f&quot;&gt;&gt; NOTICE: &#123;target.name&#125; picked up JetFire Suit! He can fly now!&quot;)\n\n\nif __name__ == &quot;__main__&quot;:\n    prime = Prime()\n    prime.rolling()\n    prime.powerup(JetFire())\n    prime.rolling()\n</code></pre>\n<p>嗯…输出结果:</p>\n<pre><code class=\"bash\">Optimus Prime is rolling out~!\n&gt;&gt; JetFire: OPtimus Prime! 我$%^&amp;*...\n&gt;&gt; NOTICE: OPtimus Prime picked up JetFire Suit! He can fly now!\n&gt;&gt; OPtimus Prime: You will always live in our memory.\nOPtimus Prime is ro~ro~的.\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>访问者模式最常见的应用场景在于对已有功能的扩展. 假设有这样一套类:</p>\n<pre><code class=\"mermaid\">classDiagram\n    class HTMLNode&#123;\n        &lt;&lt;interface&gt;&gt;\n        get_text()\n        highlight()\n    &#125;\n    class DIV&#123;\n        get_text()\n        highlight()\n    &#125;\n    class Paragraph&#123;\n        get_text()\n        highlight()\n    &#125;\n    class Link&#123;\n        get_text()\n        highlight()\n    &#125;\n    class Head&#123;\n        get_text()\n        highlight()\n    &#125;\n    class Body&#123;\n        get_text()\n        highlight()\n    &#125;\n    class Others&#123;\n        get_text()\n        highlight()\n    &#125;\n\n    DIV --|&gt; HTMLNode\n    Paragraph --|&gt; HTMLNode\n    Link --|&gt; HTMLNode\n    Body --|&gt; HTMLNode\n    Head --|&gt; HTMLNode\n    Others --|&gt; HTMLNode\n</code></pre>\n<p>定义一个<code>HTMLNode</code>, 然后定义各种类型的HTML标签对应的类来继承该接口. 从结构上来讲并没有什么问题.</p>\n<p>但会存在两个问题:</p>\n<ol>\n<li>在编码的过程中需要再所有的子类中实现接口中的方法, 通常伴随着大量的重复内容.</li>\n<li>如果忽然有一天发现接口需要增加某个功能, 那直接面对的就是一堆的编译错误. 因为所有实现了这个接口的类都必须单独重新实现这一新增的接口方法. 显然违背了开关原则.</li>\n</ol>\n<p>这时就可以考虑使用访问者模式, 不将新方法添加到接口里, 而是让接口依赖于另外一个管理操作的接口, 由其具体实现对象来进行不同的操作. 大致结构如下:</p>\n<pre><code class=\"mermaid\">classDiagram\n    class HTMLNode&#123;\n        &lt;&lt;interface&gt;&gt;\n        execute(operation)\n    &#125;\n    class DIV&#123;\n        execute(operation)\n    &#125;\n    class Paragraph&#123;\n        execute(operation)\n    &#125;\n    class Link&#123;\n        execute(operation)\n    &#125;\n    class Others&#123;\n        execute(operation)\n    &#125;\n\n    class NodeOperation&#123;\n        &lt;&lt;interface&gt;&gt;\n        apply(HTMLNode)\n    &#125;\n\n    class GetTextOperation&#123;\n        apply(HTMLNode)\n    &#125;\n\n    class HighLightOperation&#123;\n        apply(HTMLNode)\n    &#125;\n\n    class MoreOperations&#123;\n        apply(HTMLNode)\n    &#125;\n\n    DIV --|&gt; HTMLNode\n    Paragraph --|&gt; HTMLNode\n    Link --|&gt; HTMLNode\n    Others --|&gt; HTMLNode\n    HTMLNode *--&gt; NodeOperation\n\n    NodeOperation &lt;|-- GetTextOperation\n    NodeOperation &lt;|-- HighLightOperation\n    NodeOperation &lt;|-- MoreOperations\n</code></pre>\n<p>如此一来便将对象和操作进行了分离, 当希望对象能够执行新的操作时也不需要对对象本身进行修改, 而是通过扩展<code>Operation</code>的实现类即可完成.</p>\n<p>就好比身为汽车人领袖的擎天柱, 出厂设定时苦哈哈的实现了汽车人接口, 从此要么腿儿着要么滚着~</p>\n<p>遥望翱翔天际的好兄弟威震天, 心里想着什么时候咱爷们儿也能体验一把飞一般的赶脚~嘴上还是得跟伙计们高声呐喊, Autobots! Roll out!</p>\n<p>恰逢好兄弟威震天的小老弟天火到访, 那真是打瞌睡掉枕头<del>咱擎爷一点不含糊, 下手干净利索快, <code>execute</code>了天火老爷子就给自己<code>apply</code>上了~~出厂标配不会飞? 那都不叫事儿</del></p>\n<p><img src=\"/assets/img/img_202311211957171241.png\" alt=\"preview\"></p>\n<p>别跟我说电影里是天火老爷子给自己拆了, 不光历史是个任人打扮的老娘…小姑娘, 电影也一样~</p>\n<p>咱擎爷那是正面人物! 这种浓眉大眼的正面人物怎么能叛变革命呢!</p>\n<p>于是擎爷名正言顺的拾取了顶级飞行套件天火套装~~穿了一次飞没多远发现自己晕高, 落地就给扔了~</p>\n<p>突出一个拔那啥无情.</p>\n<p>你说就这顶配版渣男的造型, 要是哪天想穿个皮草了? 超能勇士不得变成下一个大冤, 不是, 下一个为了正义牺牲的大英雄了.</p>\n<p>也就俩人邂逅在热带, 保不齐皮厚了对发动机散热不好. 这家伙要来趟东北?</p>\n<p><img src=\"/assets/img/img_202311212007505770.png\" alt=\"preview\"></p>\n<h2 id=\"简单的python实现\"><a href=\"#简单的python实现\" class=\"headerlink\" title=\"简单的python实现\"></a>简单的python实现</h2><pre><code class=\"python\">from abc import ABC, abstractmethod\n\n\nclass Parts(ABC):\n\n    @abstractmethod\n    def apply(self, target, *args, **kwargs):\n        pass\n\n\nclass Autobot(ABC):\n\n    def __init__(self, name, slogan=None):\n        self.name = name\n        self.slogan = slogan\n        self.flyable = False\n\n    @abstractmethod\n    def rolling(self):\n        pass\n\n    def powerup(self, part: Parts):\n        part.apply(self)\n\n\nclass Prime(Autobot):\n\n    def __init__(self):\n        super().__init__(&quot;OPtimus Prime&quot;, &quot;Freedom is everyone&#39;s right.&quot;)\n\n    def rolling(self):\n        if self.flyable:\n            print(self.name + &#39; is ro~ro~的.&#39;)\n        else:\n            print(self.name + &quot; is rolling out~!&quot;)\n\n    def powerup(self, part: Parts):\n        part.apply(self)\n        print(f&quot;&gt;&gt; &#123;self.name&#125;: You will always live in our memory.&quot;)\n\n\nclass Bumblebee(Autobot):\n\n    def __init__(self):\n        super().__init__(&quot;Bumblebee&quot;, &quot;bi...&quot;)\n\n    def rolling(self):\n        print(&quot;bi bi di di ga...&quot;)\n\n\nclass JetFire(Parts):\n\n    def apply(self, target, *args, **kwargs):\n        if isinstance(target, Autobot):\n            print(f&quot;&gt;&gt; JetFire: &#123;target.name&#125;! 我$%^&amp;*...&quot;)\n            target.flyable = True\n            print(\n                f&quot;&gt;&gt; NOTICE: &#123;target.name&#125; picked up JetFire Suit! He can fly now!&quot;)\n\n\nif __name__ == &quot;__main__&quot;:\n    prime = Prime()\n    prime.rolling()\n    prime.powerup(JetFire())\n    prime.rolling()\n</code></pre>\n<p>嗯…输出结果:</p>\n<pre><code class=\"bash\">Optimus Prime is rolling out~!\n&gt;&gt; JetFire: OPtimus Prime! 我$%^&amp;*...\n&gt;&gt; NOTICE: OPtimus Prime picked up JetFire Suit! He can fly now!\n&gt;&gt; OPtimus Prime: You will always live in our memory.\nOPtimus Prime is ro~ro~的.\n</code></pre>\n"},{"title":"设计模式-策略模式","date":"2023-11-19T20:08:39.000Z","mermaid":true,"_content":"\n## 应用场景\n\n策略模式与状态模式很像, 都属于行为模式. 从最终呈现的UML类图上来看可能两者没什么太大区别.\n\n区别在于, 状态模式主要目的是让主体可以依据不同的状态确定行为. 比如不同的工具执行不同的操作.\n\n策略模式则主要用来封装算法, 主体状态并没有变化, 但是可以自由组合要执行的行为方式.\n\n举例来说, 编写一个简单的图片文件处理程序, 需要将给定的图片进行压缩, 然后为其添加滤镜.\n\n```python\nimport abc\n\n\nclass ImageCompresser(abc.ABC):\n\n    @abc.abstractmethod\n    def compress(self, name):\n        pass\n\n\nclass PngCompresser(ImageCompresser):\n\n    def compress(self, name):\n        print(f\"compressing png file {name}\")\n\n\nclass JpegCompresser(ImageCompresser):\n\n    def compress(self, name):\n        print(f\"compressing jpeg file {name}\")\n\n\nclass ImageFilter(abc.ABC):\n\n    @abc.abstractmethod\n    def apply(self, name):\n        pass\n\n\nclass BlackAndWhiteFilter(ImageFilter):\n\n    def apply(self, name):\n        print(f\"apply black and white filter for {name}\")\n\n\nclass BlurFilter(ImageFilter):\n\n    def apply(self, name):\n        print(f\"apply blur filter for {name}\")\n\n\nclass ImageHandler:\n\n    def handle_image(self, name,\n                     *filters: ImageFilter,\n                     compressor: ImageCompresser = None):\n        if compressor:\n            compressor.compress(name)\n\n        for img_filter in filters:\n            img_filter.apply(name)\n\n        print(f\"saving image:{name}\")\n        print(\"done.\")\n\n\nif __name__ == \"__main__\":\n\n    handler = ImageHandler()\n    handler.handle_image(\"some image\",\n                         BlackAndWhiteFilter(), BlurFilter(),\n                         compressor=PngCompresser())\n\n```\n","source":"_posts/design-pattern/strategy-design-pattern-demo.md","raw":"---\ntitle: 设计模式-策略模式\ndate: 2023-11-20 04:08:39 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n## 应用场景\n\n策略模式与状态模式很像, 都属于行为模式. 从最终呈现的UML类图上来看可能两者没什么太大区别.\n\n区别在于, 状态模式主要目的是让主体可以依据不同的状态确定行为. 比如不同的工具执行不同的操作.\n\n策略模式则主要用来封装算法, 主体状态并没有变化, 但是可以自由组合要执行的行为方式.\n\n举例来说, 编写一个简单的图片文件处理程序, 需要将给定的图片进行压缩, 然后为其添加滤镜.\n\n```python\nimport abc\n\n\nclass ImageCompresser(abc.ABC):\n\n    @abc.abstractmethod\n    def compress(self, name):\n        pass\n\n\nclass PngCompresser(ImageCompresser):\n\n    def compress(self, name):\n        print(f\"compressing png file {name}\")\n\n\nclass JpegCompresser(ImageCompresser):\n\n    def compress(self, name):\n        print(f\"compressing jpeg file {name}\")\n\n\nclass ImageFilter(abc.ABC):\n\n    @abc.abstractmethod\n    def apply(self, name):\n        pass\n\n\nclass BlackAndWhiteFilter(ImageFilter):\n\n    def apply(self, name):\n        print(f\"apply black and white filter for {name}\")\n\n\nclass BlurFilter(ImageFilter):\n\n    def apply(self, name):\n        print(f\"apply blur filter for {name}\")\n\n\nclass ImageHandler:\n\n    def handle_image(self, name,\n                     *filters: ImageFilter,\n                     compressor: ImageCompresser = None):\n        if compressor:\n            compressor.compress(name)\n\n        for img_filter in filters:\n            img_filter.apply(name)\n\n        print(f\"saving image:{name}\")\n        print(\"done.\")\n\n\nif __name__ == \"__main__\":\n\n    handler = ImageHandler()\n    handler.handle_image(\"some image\",\n                         BlackAndWhiteFilter(), BlurFilter(),\n                         compressor=PngCompresser())\n\n```\n","slug":"design-pattern-strategy-design-pattern-demo","published":1,"updated":"2023-12-13T08:43:58.101Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5vl00bvi3erdkdc1tch","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>策略模式与状态模式很像, 都属于行为模式. 从最终呈现的UML类图上来看可能两者没什么太大区别.</p>\n<p>区别在于, 状态模式主要目的是让主体可以依据不同的状态确定行为. 比如不同的工具执行不同的操作.</p>\n<p>策略模式则主要用来封装算法, 主体状态并没有变化, 但是可以自由组合要执行的行为方式.</p>\n<p>举例来说, 编写一个简单的图片文件处理程序, 需要将给定的图片进行压缩, 然后为其添加滤镜.</p>\n<pre><code class=\"python\">import abc\n\n\nclass ImageCompresser(abc.ABC):\n\n    @abc.abstractmethod\n    def compress(self, name):\n        pass\n\n\nclass PngCompresser(ImageCompresser):\n\n    def compress(self, name):\n        print(f&quot;compressing png file &#123;name&#125;&quot;)\n\n\nclass JpegCompresser(ImageCompresser):\n\n    def compress(self, name):\n        print(f&quot;compressing jpeg file &#123;name&#125;&quot;)\n\n\nclass ImageFilter(abc.ABC):\n\n    @abc.abstractmethod\n    def apply(self, name):\n        pass\n\n\nclass BlackAndWhiteFilter(ImageFilter):\n\n    def apply(self, name):\n        print(f&quot;apply black and white filter for &#123;name&#125;&quot;)\n\n\nclass BlurFilter(ImageFilter):\n\n    def apply(self, name):\n        print(f&quot;apply blur filter for &#123;name&#125;&quot;)\n\n\nclass ImageHandler:\n\n    def handle_image(self, name,\n                     *filters: ImageFilter,\n                     compressor: ImageCompresser = None):\n        if compressor:\n            compressor.compress(name)\n\n        for img_filter in filters:\n            img_filter.apply(name)\n\n        print(f&quot;saving image:&#123;name&#125;&quot;)\n        print(&quot;done.&quot;)\n\n\nif __name__ == &quot;__main__&quot;:\n\n    handler = ImageHandler()\n    handler.handle_image(&quot;some image&quot;,\n                         BlackAndWhiteFilter(), BlurFilter(),\n                         compressor=PngCompresser())\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>策略模式与状态模式很像, 都属于行为模式. 从最终呈现的UML类图上来看可能两者没什么太大区别.</p>\n<p>区别在于, 状态模式主要目的是让主体可以依据不同的状态确定行为. 比如不同的工具执行不同的操作.</p>\n<p>策略模式则主要用来封装算法, 主体状态并没有变化, 但是可以自由组合要执行的行为方式.</p>\n<p>举例来说, 编写一个简单的图片文件处理程序, 需要将给定的图片进行压缩, 然后为其添加滤镜.</p>\n<pre><code class=\"python\">import abc\n\n\nclass ImageCompresser(abc.ABC):\n\n    @abc.abstractmethod\n    def compress(self, name):\n        pass\n\n\nclass PngCompresser(ImageCompresser):\n\n    def compress(self, name):\n        print(f&quot;compressing png file &#123;name&#125;&quot;)\n\n\nclass JpegCompresser(ImageCompresser):\n\n    def compress(self, name):\n        print(f&quot;compressing jpeg file &#123;name&#125;&quot;)\n\n\nclass ImageFilter(abc.ABC):\n\n    @abc.abstractmethod\n    def apply(self, name):\n        pass\n\n\nclass BlackAndWhiteFilter(ImageFilter):\n\n    def apply(self, name):\n        print(f&quot;apply black and white filter for &#123;name&#125;&quot;)\n\n\nclass BlurFilter(ImageFilter):\n\n    def apply(self, name):\n        print(f&quot;apply blur filter for &#123;name&#125;&quot;)\n\n\nclass ImageHandler:\n\n    def handle_image(self, name,\n                     *filters: ImageFilter,\n                     compressor: ImageCompresser = None):\n        if compressor:\n            compressor.compress(name)\n\n        for img_filter in filters:\n            img_filter.apply(name)\n\n        print(f&quot;saving image:&#123;name&#125;&quot;)\n        print(&quot;done.&quot;)\n\n\nif __name__ == &quot;__main__&quot;:\n\n    handler = ImageHandler()\n    handler.handle_image(&quot;some image&quot;,\n                         BlackAndWhiteFilter(), BlurFilter(),\n                         compressor=PngCompresser())\n</code></pre>\n"},{"title":"设计模式-状态模式","date":"2023-11-19T17:06:45.000Z","mermaid":true,"_content":"\n## 应用场景\n\n当执行同一种操作时基于不同的状态出现不同的效果.\n\n比如在画图软件中, 如果选中了画笔, 按住鼠标在画布上拖动就会绘制线条.\n\n如果选中了选择工具, 按住鼠标在画布上拖动就会出现一个选择框.\n\n对于鼠标的操作行为是相同的, 但是基于选中工具的状态不同, 则会执行不同的操作.\n\n## 基础实现方式\n\n可以创建一个枚举类, 用来列出所有的工具类型, 然后让画布包含一个枚举成员, 并在操作时判断这个成员的值.\n\n```mermaid\nclassDiagram\n    direction LR\n    class Canvas{\n        - ToolType\n        + operation()\n    }\n    class ToolType{\n        <<enumration>>\n        SELECT,\n        BRUSH,\n        ERASER\n    }\n    Canvas *-- ToolType\n```\n\n简单模拟代码如下:\n\n```python\n\nclass ToolType(Enum):\n    SELECT = 1\n    BRUSH = 2\n    ERASE = 3\n\n\nclass Canvas:\n\n    def __init__(self, tool_type=ToolType.SELECT):\n        self.__tool_type = tool_type\n\n    def operation(self):\n        if self.__tool_type == ToolType.SELECT:\n            print(\"using select tool \")\n        elif self.__tool_type == ToolType.BRUSH:\n            print(\"using brush tool \")\n        elif self.__tool_type == ToolType.ERASE:\n            print(\"using erase tool \")\n\nif __name__ == \"__main__\":\n    canvas = Canvas()\n    canvas.operation()\n    canvas.tool_type = ToolType.BRUSH\n    canvas.operation()            \n```\n\n但问题显而易见, 当工具增多时既要维护大量的枚举类型, 还要维护大量的枚举判断, 使得代码难以阅读, 极大的增加了维护成本.\n\n## 使用状态设计模式解决\n\n状态模式的本质是通过运行时的多态来完成不同状态下的不同操作.\n\n```mermaid\nclassDiagram\n    class Canvas{\n        curreentTool\n        +operation()\n    }\n\n    class Tool{\n        <<interface>>\n        +operation()\n    }\n\n    class SelectTool{\n        +operation()\n    }\n\n    class BrushTool{\n        +operation()\n    }\n\n    Canvas *-- Tool\n    SelectTool ..|> Tool\n    BrushTool ..|> Tool\n```\n\n如此一来, 如果在任何时候希望添加一个新的工具, 直接创建一个新的类来实现`Tool`接口即可以完成对程序的扩展, 而无需再修改原有的代码逻辑.\n\n事实上, 所有需要通过类似`select...case`或者大量`if...else if`判断的场景都可以通过状态模式来解决.\n\n状态设计模式, 也是`OCP(Open Closed Principle)`的一种体现, 即对扩展开放, 但是对修改关闭.\n\n* open for extension\n* closed for modification\n\n简单的python实现代码:\n\n```python\nimport abc\n\n\nclass Tool(abc.ABC):\n\n    @abc.abstractmethod\n    def operation(self):\n        pass\n\n\nclass SelectTool(Tool):\n\n    def operation(self):\n        print(\"select something...\")\n\n\nclass BrushTool(Tool):\n\n    def operation(self):\n        print(\"brush something...\")\n\n\nclass Canvas:\n\n    def __init__(self, tool=None):\n        self.__tool = tool or SelectTool()\n\n    @property\n    def tool(self):\n        return self.__tool.__str__\n\n    @tool.setter\n    def tool(self, value: Tool):\n        self.__tool = value\n\n    def operation(self):\n        self.__tool.operation()\n\n\nif __name__ == \"__main__\":\n    canvas = Canvas()\n    canvas.operation()\n    canvas.tool = BrushTool()\n    canvas.operation()\n```\n","source":"_posts/design-pattern/state-design-pattern.md","raw":"---\ntitle: 设计模式-状态模式\ndate: 2023-11-20 01:06:45 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n## 应用场景\n\n当执行同一种操作时基于不同的状态出现不同的效果.\n\n比如在画图软件中, 如果选中了画笔, 按住鼠标在画布上拖动就会绘制线条.\n\n如果选中了选择工具, 按住鼠标在画布上拖动就会出现一个选择框.\n\n对于鼠标的操作行为是相同的, 但是基于选中工具的状态不同, 则会执行不同的操作.\n\n## 基础实现方式\n\n可以创建一个枚举类, 用来列出所有的工具类型, 然后让画布包含一个枚举成员, 并在操作时判断这个成员的值.\n\n```mermaid\nclassDiagram\n    direction LR\n    class Canvas{\n        - ToolType\n        + operation()\n    }\n    class ToolType{\n        <<enumration>>\n        SELECT,\n        BRUSH,\n        ERASER\n    }\n    Canvas *-- ToolType\n```\n\n简单模拟代码如下:\n\n```python\n\nclass ToolType(Enum):\n    SELECT = 1\n    BRUSH = 2\n    ERASE = 3\n\n\nclass Canvas:\n\n    def __init__(self, tool_type=ToolType.SELECT):\n        self.__tool_type = tool_type\n\n    def operation(self):\n        if self.__tool_type == ToolType.SELECT:\n            print(\"using select tool \")\n        elif self.__tool_type == ToolType.BRUSH:\n            print(\"using brush tool \")\n        elif self.__tool_type == ToolType.ERASE:\n            print(\"using erase tool \")\n\nif __name__ == \"__main__\":\n    canvas = Canvas()\n    canvas.operation()\n    canvas.tool_type = ToolType.BRUSH\n    canvas.operation()            \n```\n\n但问题显而易见, 当工具增多时既要维护大量的枚举类型, 还要维护大量的枚举判断, 使得代码难以阅读, 极大的增加了维护成本.\n\n## 使用状态设计模式解决\n\n状态模式的本质是通过运行时的多态来完成不同状态下的不同操作.\n\n```mermaid\nclassDiagram\n    class Canvas{\n        curreentTool\n        +operation()\n    }\n\n    class Tool{\n        <<interface>>\n        +operation()\n    }\n\n    class SelectTool{\n        +operation()\n    }\n\n    class BrushTool{\n        +operation()\n    }\n\n    Canvas *-- Tool\n    SelectTool ..|> Tool\n    BrushTool ..|> Tool\n```\n\n如此一来, 如果在任何时候希望添加一个新的工具, 直接创建一个新的类来实现`Tool`接口即可以完成对程序的扩展, 而无需再修改原有的代码逻辑.\n\n事实上, 所有需要通过类似`select...case`或者大量`if...else if`判断的场景都可以通过状态模式来解决.\n\n状态设计模式, 也是`OCP(Open Closed Principle)`的一种体现, 即对扩展开放, 但是对修改关闭.\n\n* open for extension\n* closed for modification\n\n简单的python实现代码:\n\n```python\nimport abc\n\n\nclass Tool(abc.ABC):\n\n    @abc.abstractmethod\n    def operation(self):\n        pass\n\n\nclass SelectTool(Tool):\n\n    def operation(self):\n        print(\"select something...\")\n\n\nclass BrushTool(Tool):\n\n    def operation(self):\n        print(\"brush something...\")\n\n\nclass Canvas:\n\n    def __init__(self, tool=None):\n        self.__tool = tool or SelectTool()\n\n    @property\n    def tool(self):\n        return self.__tool.__str__\n\n    @tool.setter\n    def tool(self, value: Tool):\n        self.__tool = value\n\n    def operation(self):\n        self.__tool.operation()\n\n\nif __name__ == \"__main__\":\n    canvas = Canvas()\n    canvas.operation()\n    canvas.tool = BrushTool()\n    canvas.operation()\n```\n","slug":"design-pattern-state-design-pattern","published":1,"updated":"2023-12-13T08:43:58.101Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5vl00byi3er4j2vdw55","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>当执行同一种操作时基于不同的状态出现不同的效果.</p>\n<p>比如在画图软件中, 如果选中了画笔, 按住鼠标在画布上拖动就会绘制线条.</p>\n<p>如果选中了选择工具, 按住鼠标在画布上拖动就会出现一个选择框.</p>\n<p>对于鼠标的操作行为是相同的, 但是基于选中工具的状态不同, 则会执行不同的操作.</p>\n<h2 id=\"基础实现方式\"><a href=\"#基础实现方式\" class=\"headerlink\" title=\"基础实现方式\"></a>基础实现方式</h2><p>可以创建一个枚举类, 用来列出所有的工具类型, 然后让画布包含一个枚举成员, 并在操作时判断这个成员的值.</p>\n<pre><code class=\"mermaid\">classDiagram\n    direction LR\n    class Canvas&#123;\n        - ToolType\n        + operation()\n    &#125;\n    class ToolType&#123;\n        &lt;&lt;enumration&gt;&gt;\n        SELECT,\n        BRUSH,\n        ERASER\n    &#125;\n    Canvas *-- ToolType\n</code></pre>\n<p>简单模拟代码如下:</p>\n<pre><code class=\"python\">\nclass ToolType(Enum):\n    SELECT = 1\n    BRUSH = 2\n    ERASE = 3\n\n\nclass Canvas:\n\n    def __init__(self, tool_type=ToolType.SELECT):\n        self.__tool_type = tool_type\n\n    def operation(self):\n        if self.__tool_type == ToolType.SELECT:\n            print(&quot;using select tool &quot;)\n        elif self.__tool_type == ToolType.BRUSH:\n            print(&quot;using brush tool &quot;)\n        elif self.__tool_type == ToolType.ERASE:\n            print(&quot;using erase tool &quot;)\n\nif __name__ == &quot;__main__&quot;:\n    canvas = Canvas()\n    canvas.operation()\n    canvas.tool_type = ToolType.BRUSH\n    canvas.operation()            \n</code></pre>\n<p>但问题显而易见, 当工具增多时既要维护大量的枚举类型, 还要维护大量的枚举判断, 使得代码难以阅读, 极大的增加了维护成本.</p>\n<h2 id=\"使用状态设计模式解决\"><a href=\"#使用状态设计模式解决\" class=\"headerlink\" title=\"使用状态设计模式解决\"></a>使用状态设计模式解决</h2><p>状态模式的本质是通过运行时的多态来完成不同状态下的不同操作.</p>\n<pre><code class=\"mermaid\">classDiagram\n    class Canvas&#123;\n        curreentTool\n        +operation()\n    &#125;\n\n    class Tool&#123;\n        &lt;&lt;interface&gt;&gt;\n        +operation()\n    &#125;\n\n    class SelectTool&#123;\n        +operation()\n    &#125;\n\n    class BrushTool&#123;\n        +operation()\n    &#125;\n\n    Canvas *-- Tool\n    SelectTool ..|&gt; Tool\n    BrushTool ..|&gt; Tool\n</code></pre>\n<p>如此一来, 如果在任何时候希望添加一个新的工具, 直接创建一个新的类来实现<code>Tool</code>接口即可以完成对程序的扩展, 而无需再修改原有的代码逻辑.</p>\n<p>事实上, 所有需要通过类似<code>select...case</code>或者大量<code>if...else if</code>判断的场景都可以通过状态模式来解决.</p>\n<p>状态设计模式, 也是<code>OCP(Open Closed Principle)</code>的一种体现, 即对扩展开放, 但是对修改关闭.</p>\n<ul>\n<li>open for extension</li>\n<li>closed for modification</li>\n</ul>\n<p>简单的python实现代码:</p>\n<pre><code class=\"python\">import abc\n\n\nclass Tool(abc.ABC):\n\n    @abc.abstractmethod\n    def operation(self):\n        pass\n\n\nclass SelectTool(Tool):\n\n    def operation(self):\n        print(&quot;select something...&quot;)\n\n\nclass BrushTool(Tool):\n\n    def operation(self):\n        print(&quot;brush something...&quot;)\n\n\nclass Canvas:\n\n    def __init__(self, tool=None):\n        self.__tool = tool or SelectTool()\n\n    @property\n    def tool(self):\n        return self.__tool.__str__\n\n    @tool.setter\n    def tool(self, value: Tool):\n        self.__tool = value\n\n    def operation(self):\n        self.__tool.operation()\n\n\nif __name__ == &quot;__main__&quot;:\n    canvas = Canvas()\n    canvas.operation()\n    canvas.tool = BrushTool()\n    canvas.operation()\n</code></pre>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>当执行同一种操作时基于不同的状态出现不同的效果.</p>\n<p>比如在画图软件中, 如果选中了画笔, 按住鼠标在画布上拖动就会绘制线条.</p>\n<p>如果选中了选择工具, 按住鼠标在画布上拖动就会出现一个选择框.</p>\n<p>对于鼠标的操作行为是相同的, 但是基于选中工具的状态不同, 则会执行不同的操作.</p>\n<h2 id=\"基础实现方式\"><a href=\"#基础实现方式\" class=\"headerlink\" title=\"基础实现方式\"></a>基础实现方式</h2><p>可以创建一个枚举类, 用来列出所有的工具类型, 然后让画布包含一个枚举成员, 并在操作时判断这个成员的值.</p>\n<pre><code class=\"mermaid\">classDiagram\n    direction LR\n    class Canvas&#123;\n        - ToolType\n        + operation()\n    &#125;\n    class ToolType&#123;\n        &lt;&lt;enumration&gt;&gt;\n        SELECT,\n        BRUSH,\n        ERASER\n    &#125;\n    Canvas *-- ToolType\n</code></pre>\n<p>简单模拟代码如下:</p>\n<pre><code class=\"python\">\nclass ToolType(Enum):\n    SELECT = 1\n    BRUSH = 2\n    ERASE = 3\n\n\nclass Canvas:\n\n    def __init__(self, tool_type=ToolType.SELECT):\n        self.__tool_type = tool_type\n\n    def operation(self):\n        if self.__tool_type == ToolType.SELECT:\n            print(&quot;using select tool &quot;)\n        elif self.__tool_type == ToolType.BRUSH:\n            print(&quot;using brush tool &quot;)\n        elif self.__tool_type == ToolType.ERASE:\n            print(&quot;using erase tool &quot;)\n\nif __name__ == &quot;__main__&quot;:\n    canvas = Canvas()\n    canvas.operation()\n    canvas.tool_type = ToolType.BRUSH\n    canvas.operation()            \n</code></pre>\n<p>但问题显而易见, 当工具增多时既要维护大量的枚举类型, 还要维护大量的枚举判断, 使得代码难以阅读, 极大的增加了维护成本.</p>\n<h2 id=\"使用状态设计模式解决\"><a href=\"#使用状态设计模式解决\" class=\"headerlink\" title=\"使用状态设计模式解决\"></a>使用状态设计模式解决</h2><p>状态模式的本质是通过运行时的多态来完成不同状态下的不同操作.</p>\n<pre><code class=\"mermaid\">classDiagram\n    class Canvas&#123;\n        curreentTool\n        +operation()\n    &#125;\n\n    class Tool&#123;\n        &lt;&lt;interface&gt;&gt;\n        +operation()\n    &#125;\n\n    class SelectTool&#123;\n        +operation()\n    &#125;\n\n    class BrushTool&#123;\n        +operation()\n    &#125;\n\n    Canvas *-- Tool\n    SelectTool ..|&gt; Tool\n    BrushTool ..|&gt; Tool\n</code></pre>\n<p>如此一来, 如果在任何时候希望添加一个新的工具, 直接创建一个新的类来实现<code>Tool</code>接口即可以完成对程序的扩展, 而无需再修改原有的代码逻辑.</p>\n<p>事实上, 所有需要通过类似<code>select...case</code>或者大量<code>if...else if</code>判断的场景都可以通过状态模式来解决.</p>\n<p>状态设计模式, 也是<code>OCP(Open Closed Principle)</code>的一种体现, 即对扩展开放, 但是对修改关闭.</p>\n<ul>\n<li>open for extension</li>\n<li>closed for modification</li>\n</ul>\n<p>简单的python实现代码:</p>\n<pre><code class=\"python\">import abc\n\n\nclass Tool(abc.ABC):\n\n    @abc.abstractmethod\n    def operation(self):\n        pass\n\n\nclass SelectTool(Tool):\n\n    def operation(self):\n        print(&quot;select something...&quot;)\n\n\nclass BrushTool(Tool):\n\n    def operation(self):\n        print(&quot;brush something...&quot;)\n\n\nclass Canvas:\n\n    def __init__(self, tool=None):\n        self.__tool = tool or SelectTool()\n\n    @property\n    def tool(self):\n        return self.__tool.__str__\n\n    @tool.setter\n    def tool(self, value: Tool):\n        self.__tool = value\n\n    def operation(self):\n        self.__tool.operation()\n\n\nif __name__ == &quot;__main__&quot;:\n    canvas = Canvas()\n    canvas.operation()\n    canvas.tool = BrushTool()\n    canvas.operation()\n</code></pre>\n"},{"title":"设计模式-模板方法模式","date":"2023-11-19T20:52:12.000Z","mermaid":true,"_content":"\n## 应用场景\n\n在处理一些大致内容相同, 但是有些细微差距的问题时可以使用模板方法模式. 基于同一套模板下, 不同的具体实现只针对细节发生变化, 而其他的内容则是依照父类模板执行.\n\n举例来说, 一个代驾司机的标准工作流程大致可分为:\n\n1. 接单\n2. 到达指定车主位置\n3. 代驾到指定目的地\n4. 收钱\n5. 要好评,再见~\n\n那么区别在哪? 在于面对不同级别的车子时的心理状态~\n\n顶级豪车得毕恭毕敬, 百万豪车是尊崇有加, 高端家用得谦卑有礼, 低档代步...\n\n所以模板方法模式...精髓在于见人下菜碟, 典型的势利眼模式...\n\n简单的python实现:\n\n```python\nimport abc\n\n\nclass SubstituteDriver(abc.ABC):\n\n    def take_order(self):\n        print(\"接到客户订单\")\n        print(\"赶往指定地点\")\n        self._inner_thought()\n        print(\"代驾到指定目的地\")\n        print(\"收钱\")\n        print(\"要好评, 再见~\")\n\n    @abc.abstractmethod\n    def _inner_thought(self):\n        pass\n\n\nclass SubstituteDriverForAudi(SubstituteDriver):\n\n    def _inner_thought(self):\n        print(\"得多要钱\")\n\n\nclass SubstituteDriverForAlto(SubstituteDriver):\n\n    def _inner_thought(self):\n        print(\"一脸嫌弃\")\n\n\nif __name__ == \"__main__\":\n    audi = SubstituteDriverForAudi()\n    audi.take_order()\n\n    alto = SubstituteDriverForAlto()\n    alto.take_order()\n```\n\n本质上来说, 模板方法模式不一定要基于抽象类, 而是将流程进行明确的划分, 让每一步流程都有自己独立的处理方法. 子类要做的则是继承模板类后, 根据实际情况重写父类的方法以满足自身需求即可.\n","source":"_posts/design-pattern/template-method-pattern.md","raw":"---\ntitle: 设计模式-模板方法模式\ndate: 2023-11-20 04:52:12 +0800\ncategories: [笔记, 设计模式]\ntags: ['design-pattern']\nmermaid: true\n---\n\n## 应用场景\n\n在处理一些大致内容相同, 但是有些细微差距的问题时可以使用模板方法模式. 基于同一套模板下, 不同的具体实现只针对细节发生变化, 而其他的内容则是依照父类模板执行.\n\n举例来说, 一个代驾司机的标准工作流程大致可分为:\n\n1. 接单\n2. 到达指定车主位置\n3. 代驾到指定目的地\n4. 收钱\n5. 要好评,再见~\n\n那么区别在哪? 在于面对不同级别的车子时的心理状态~\n\n顶级豪车得毕恭毕敬, 百万豪车是尊崇有加, 高端家用得谦卑有礼, 低档代步...\n\n所以模板方法模式...精髓在于见人下菜碟, 典型的势利眼模式...\n\n简单的python实现:\n\n```python\nimport abc\n\n\nclass SubstituteDriver(abc.ABC):\n\n    def take_order(self):\n        print(\"接到客户订单\")\n        print(\"赶往指定地点\")\n        self._inner_thought()\n        print(\"代驾到指定目的地\")\n        print(\"收钱\")\n        print(\"要好评, 再见~\")\n\n    @abc.abstractmethod\n    def _inner_thought(self):\n        pass\n\n\nclass SubstituteDriverForAudi(SubstituteDriver):\n\n    def _inner_thought(self):\n        print(\"得多要钱\")\n\n\nclass SubstituteDriverForAlto(SubstituteDriver):\n\n    def _inner_thought(self):\n        print(\"一脸嫌弃\")\n\n\nif __name__ == \"__main__\":\n    audi = SubstituteDriverForAudi()\n    audi.take_order()\n\n    alto = SubstituteDriverForAlto()\n    alto.take_order()\n```\n\n本质上来说, 模板方法模式不一定要基于抽象类, 而是将流程进行明确的划分, 让每一步流程都有自己独立的处理方法. 子类要做的则是继承模板类后, 根据实际情况重写父类的方法以满足自身需求即可.\n","slug":"design-pattern-template-method-pattern","published":1,"updated":"2023-12-13T08:43:58.102Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clq3jh5vl00c1i3er3k93f7g8","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>在处理一些大致内容相同, 但是有些细微差距的问题时可以使用模板方法模式. 基于同一套模板下, 不同的具体实现只针对细节发生变化, 而其他的内容则是依照父类模板执行.</p>\n<p>举例来说, 一个代驾司机的标准工作流程大致可分为:</p>\n<ol>\n<li>接单</li>\n<li>到达指定车主位置</li>\n<li>代驾到指定目的地</li>\n<li>收钱</li>\n<li>要好评,再见~</li>\n</ol>\n<p>那么区别在哪? 在于面对不同级别的车子时的心理状态~</p>\n<p>顶级豪车得毕恭毕敬, 百万豪车是尊崇有加, 高端家用得谦卑有礼, 低档代步…</p>\n<p>所以模板方法模式…精髓在于见人下菜碟, 典型的势利眼模式…</p>\n<p>简单的python实现:</p>\n<pre><code class=\"python\">import abc\n\n\nclass SubstituteDriver(abc.ABC):\n\n    def take_order(self):\n        print(&quot;接到客户订单&quot;)\n        print(&quot;赶往指定地点&quot;)\n        self._inner_thought()\n        print(&quot;代驾到指定目的地&quot;)\n        print(&quot;收钱&quot;)\n        print(&quot;要好评, 再见~&quot;)\n\n    @abc.abstractmethod\n    def _inner_thought(self):\n        pass\n\n\nclass SubstituteDriverForAudi(SubstituteDriver):\n\n    def _inner_thought(self):\n        print(&quot;得多要钱&quot;)\n\n\nclass SubstituteDriverForAlto(SubstituteDriver):\n\n    def _inner_thought(self):\n        print(&quot;一脸嫌弃&quot;)\n\n\nif __name__ == &quot;__main__&quot;:\n    audi = SubstituteDriverForAudi()\n    audi.take_order()\n\n    alto = SubstituteDriverForAlto()\n    alto.take_order()\n</code></pre>\n<p>本质上来说, 模板方法模式不一定要基于抽象类, 而是将流程进行明确的划分, 让每一步流程都有自己独立的处理方法. 子类要做的则是继承模板类后, 根据实际情况重写父类的方法以满足自身需求即可.</p>\n","site":{"data":{"menu":{"Home":"/","Archives":"/archives/","presentation":"/presentations/"}}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>在处理一些大致内容相同, 但是有些细微差距的问题时可以使用模板方法模式. 基于同一套模板下, 不同的具体实现只针对细节发生变化, 而其他的内容则是依照父类模板执行.</p>\n<p>举例来说, 一个代驾司机的标准工作流程大致可分为:</p>\n<ol>\n<li>接单</li>\n<li>到达指定车主位置</li>\n<li>代驾到指定目的地</li>\n<li>收钱</li>\n<li>要好评,再见~</li>\n</ol>\n<p>那么区别在哪? 在于面对不同级别的车子时的心理状态~</p>\n<p>顶级豪车得毕恭毕敬, 百万豪车是尊崇有加, 高端家用得谦卑有礼, 低档代步…</p>\n<p>所以模板方法模式…精髓在于见人下菜碟, 典型的势利眼模式…</p>\n<p>简单的python实现:</p>\n<pre><code class=\"python\">import abc\n\n\nclass SubstituteDriver(abc.ABC):\n\n    def take_order(self):\n        print(&quot;接到客户订单&quot;)\n        print(&quot;赶往指定地点&quot;)\n        self._inner_thought()\n        print(&quot;代驾到指定目的地&quot;)\n        print(&quot;收钱&quot;)\n        print(&quot;要好评, 再见~&quot;)\n\n    @abc.abstractmethod\n    def _inner_thought(self):\n        pass\n\n\nclass SubstituteDriverForAudi(SubstituteDriver):\n\n    def _inner_thought(self):\n        print(&quot;得多要钱&quot;)\n\n\nclass SubstituteDriverForAlto(SubstituteDriver):\n\n    def _inner_thought(self):\n        print(&quot;一脸嫌弃&quot;)\n\n\nif __name__ == &quot;__main__&quot;:\n    audi = SubstituteDriverForAudi()\n    audi.take_order()\n\n    alto = SubstituteDriverForAlto()\n    alto.take_order()\n</code></pre>\n<p>本质上来说, 模板方法模式不一定要基于抽象类, 而是将流程进行明确的划分, 让每一步流程都有自己独立的处理方法. 子类要做的则是继承模板类后, 根据实际情况重写父类的方法以满足自身需求即可.</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clq3jh5uv0005i3erayluha0f","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5uz000qi3erbzk08mbs"},{"post_id":"clq3jh5uv0005i3erayluha0f","category_id":"clq3jh5uy000fi3eref9d6ff0","_id":"clq3jh5uz000vi3er2op1de30"},{"post_id":"clq3jh5ur0000i3er7pos1jbu","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v0000xi3er8bcrapm8"},{"post_id":"clq3jh5ur0000i3er7pos1jbu","category_id":"clq3jh5uy000ki3er8wcu5ikk","_id":"clq3jh5v00011i3er68upgigu"},{"post_id":"clq3jh5uw0006i3erhxy2df2d","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v00014i3erewngbvr5"},{"post_id":"clq3jh5uw0006i3erhxy2df2d","category_id":"clq3jh5uz000si3eratuy0d3y","_id":"clq3jh5v10019i3erg72jeoa5"},{"post_id":"clq3jh5uu0001i3er63pvd6c7","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v2001hi3er8hyjabqu"},{"post_id":"clq3jh5uu0001i3er63pvd6c7","category_id":"clq3jh5v00016i3er5dg2eblr","_id":"clq3jh5v2001ki3erb1n8932p"},{"post_id":"clq3jh5ux000di3er7oi7cu97","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v3001ui3er9w9z6l4t"},{"post_id":"clq3jh5ux000di3er7oi7cu97","category_id":"clq3jh5v1001gi3erbafnb4lj","_id":"clq3jh5v3001xi3erb0lj8orl"},{"post_id":"clq3jh5uv0004i3er49x8foyu","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v3001zi3erdz2a6j4u"},{"post_id":"clq3jh5uv0004i3er49x8foyu","category_id":"clq3jh5v1001gi3erbafnb4lj","_id":"clq3jh5v30023i3er856ab74f"},{"post_id":"clq3jh5ux000ei3ercxxn5wnr","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v40027i3er8uzx22wf"},{"post_id":"clq3jh5ux000ei3ercxxn5wnr","category_id":"clq3jh5v3001ti3erdxx3fa33","_id":"clq3jh5v4002bi3er7s1tf422"},{"post_id":"clq3jh5v4002fi3er6qixg83b","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v5002oi3er47rq8on8"},{"post_id":"clq3jh5v4002fi3er6qixg83b","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5v5002ri3er8htmgomj"},{"post_id":"clq3jh5uz000ni3erd6voc7xp","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v6002ui3er0k4k1k7o"},{"post_id":"clq3jh5uz000ni3erd6voc7xp","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5v6002xi3era6udfvjb"},{"post_id":"clq3jh5v4002hi3erb8kp4ya7","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v60030i3er9qzf77ti"},{"post_id":"clq3jh5v4002hi3erb8kp4ya7","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5v70034i3er20py3z2h"},{"post_id":"clq3jh5uz000pi3er9vljappz","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v70038i3er2rczfqsk"},{"post_id":"clq3jh5uz000pi3er9vljappz","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5v8003ci3eresjkfu04"},{"post_id":"clq3jh5uz000wi3erfcq2gxw1","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v8003fi3er2khpauae"},{"post_id":"clq3jh5uz000wi3erfcq2gxw1","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5v8003ji3erbd868hq0"},{"post_id":"clq3jh5v0000zi3er3p7r5fza","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v9003li3erae3x96s2"},{"post_id":"clq3jh5v0000zi3er3p7r5fza","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5v9003ni3er1k6g49av"},{"post_id":"clq3jh5v00012i3er6db59mam","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v9003qi3ercdeq3ve0"},{"post_id":"clq3jh5v00012i3er6db59mam","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5v9003ti3er81macl5o"},{"post_id":"clq3jh5uw0009i3er2xbtcrxl","category_id":"clq3jh5v0000yi3erehq02oyr","_id":"clq3jh5v9003vi3erfrdo09ai"},{"post_id":"clq3jh5uw0009i3er2xbtcrxl","category_id":"clq3jh5v8003ii3ere7zyh6b4","_id":"clq3jh5v9003xi3er59gj1a4n"},{"post_id":"clq3jh5v00015i3erexcc8ama","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v9003zi3er3czk2x8v"},{"post_id":"clq3jh5v00015i3erexcc8ama","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5v90041i3er7ilr46j3"},{"post_id":"clq3jh5v1001ai3er13tqfwrl","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v90043i3er11981fj9"},{"post_id":"clq3jh5v1001ai3er13tqfwrl","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5v90044i3erf6n354wn"},{"post_id":"clq3jh5v1001bi3eravg9ei7t","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5v90047i3erf9in806w"},{"post_id":"clq3jh5v1001bi3eravg9ei7t","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5v90048i3er6h992ubo"},{"post_id":"clq3jh5v1001ei3er283u9k9n","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5va004bi3eraa7w1loc"},{"post_id":"clq3jh5v1001ei3er283u9k9n","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5va004di3er7e5b8cz0"},{"post_id":"clq3jh5ux000ai3erbfkj385b","category_id":"clq3jh5v0000yi3erehq02oyr","_id":"clq3jh5va004hi3er2bckdlth"},{"post_id":"clq3jh5ux000ai3erbfkj385b","category_id":"clq3jh5v90045i3er9t6g1hcn","_id":"clq3jh5va004ji3er36z07zov"},{"post_id":"clq3jh5v1001fi3er667q225p","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5va004ni3er2ovd1ajg"},{"post_id":"clq3jh5v1001fi3er667q225p","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5va004pi3ercvei6vfi"},{"post_id":"clq3jh5v2001ii3erg39he2m2","category_id":"clq3jh5v0000yi3erehq02oyr","_id":"clq3jh5va004si3erca3qbgla"},{"post_id":"clq3jh5v2001ii3erg39he2m2","category_id":"clq3jh5va004fi3er5e3533ai","_id":"clq3jh5va004ui3er70a7dxer"},{"post_id":"clq3jh5v2001mi3eresfz5nxp","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5va004yi3er22tw52xg"},{"post_id":"clq3jh5v2001mi3eresfz5nxp","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5va0050i3er2vs42l9y"},{"post_id":"clq3jh5v2001pi3erfchh77jc","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5va0053i3erc7no309y"},{"post_id":"clq3jh5v2001pi3erfchh77jc","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5va0054i3erboh02kzp"},{"post_id":"clq3jh5v2001si3ere06y0anh","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vb0057i3er32d9hhl6"},{"post_id":"clq3jh5v2001si3ere06y0anh","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5vb0059i3er5c354zcz"},{"post_id":"clq3jh5v3001vi3erc4qf2j23","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vb005di3erdojh1okj"},{"post_id":"clq3jh5v3001vi3erc4qf2j23","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5vb005fi3ergegp1u0v"},{"post_id":"clq3jh5v3001yi3er3s8x7vrc","category_id":"clq3jh5v0000yi3erehq02oyr","_id":"clq3jh5vb005ii3er7oop2d51"},{"post_id":"clq3jh5v3001yi3er3s8x7vrc","category_id":"clq3jh5v8003ii3ere7zyh6b4","_id":"clq3jh5vb005ji3ergxg9f7og"},{"post_id":"clq3jh5v30021i3ercres23fu","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vb005mi3er2pa6ez4r"},{"post_id":"clq3jh5v30021i3ercres23fu","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5vb005ni3er112gekz4"},{"post_id":"clq3jh5uy000hi3erdfd14os0","category_id":"clq3jh5v0000yi3erehq02oyr","_id":"clq3jh5vb005pi3erdutg9umu"},{"post_id":"clq3jh5uy000hi3erdfd14os0","category_id":"clq3jh5v90045i3er9t6g1hcn","_id":"clq3jh5vb005si3erc1yr4h2j"},{"post_id":"clq3jh5v30025i3er6xzu46kl","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vb005vi3er5s8jcq5t"},{"post_id":"clq3jh5v30025i3er6xzu46kl","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5vb005yi3er2tv569lg"},{"post_id":"clq3jh5v40029i3er986259sd","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vb0061i3er9bahfn76"},{"post_id":"clq3jh5v40029i3er986259sd","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5vc0063i3erfyqe2n01"},{"post_id":"clq3jh5uy000ji3er1gb9cd8p","category_id":"clq3jh5v0000yi3erehq02oyr","_id":"clq3jh5vc0066i3erchc713vp"},{"post_id":"clq3jh5uy000ji3er1gb9cd8p","category_id":"clq3jh5va004fi3er5e3533ai","_id":"clq3jh5vc0069i3er2ojegce2"},{"post_id":"clq3jh5v4002di3er3xur5wy0","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vc006bi3erexr5bxw0"},{"post_id":"clq3jh5v4002di3er3xur5wy0","category_id":"clq3jh5v4002ei3ergxwpacr4","_id":"clq3jh5vc006di3erg4ex1any"},{"post_id":"clq3jh5v5002ji3erb628hybv","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vc006fi3er97rebvtv"},{"post_id":"clq3jh5v5002ji3erb628hybv","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vc006hi3er69q14hci"},{"post_id":"clq3jh5v5002ni3erb3le22d5","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vc006ki3er0atxba0p"},{"post_id":"clq3jh5v5002ni3erb3le22d5","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vc006ni3er4owdef9d"},{"post_id":"clq3jh5v5002pi3er38mhdvy8","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vc006qi3ereg3vclta"},{"post_id":"clq3jh5v5002pi3er38mhdvy8","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vc006si3er8i80ed1p"},{"post_id":"clq3jh5v5002ti3er80nsepzt","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vd006ui3erfgc12ayq"},{"post_id":"clq3jh5v5002ti3er80nsepzt","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vd006wi3er6p3tgwzz"},{"post_id":"clq3jh5uz000ti3ercqpye45m","category_id":"clq3jh5v0000yi3erehq02oyr","_id":"clq3jh5vd006zi3ergfba0v4a"},{"post_id":"clq3jh5uz000ti3ercqpye45m","category_id":"clq3jh5v8003ii3ere7zyh6b4","_id":"clq3jh5vd0072i3ere3ty4coy"},{"post_id":"clq3jh5v6002vi3er5zek68eq","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vd0075i3erdeaof0a9"},{"post_id":"clq3jh5v6002vi3er5zek68eq","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vd0077i3erezcl2w0n"},{"post_id":"clq3jh5v6002yi3er8lg37gxl","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vd0079i3er3rf49663"},{"post_id":"clq3jh5v6002yi3er8lg37gxl","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vd007bi3er55ea34p5"},{"post_id":"clq3jh5v60032i3er6pxt8j3h","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vd007ei3er7y739ubo"},{"post_id":"clq3jh5v60032i3er6pxt8j3h","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vd007hi3er6qfo6ag8"},{"post_id":"clq3jh5v70036i3erfb4salgq","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vd007ki3erd89tgm56"},{"post_id":"clq3jh5v70036i3erfb4salgq","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5ve007mi3er7anp4d7k"},{"post_id":"clq3jh5v8003ai3er6sn77efv","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5ve007oi3ergjega1ft"},{"post_id":"clq3jh5v8003ai3er6sn77efv","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5ve007qi3er5acvdj70"},{"post_id":"clq3jh5v8003ei3erfam2gek3","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5ve007ti3erg7yf9qb6"},{"post_id":"clq3jh5v8003ei3erfam2gek3","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5ve007wi3ergi8zb3f9"},{"post_id":"clq3jh5v8003hi3er55ha3e5w","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5ve007yi3er41o4acie"},{"post_id":"clq3jh5v8003hi3er55ha3e5w","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5ve0080i3er7e43c3xb"},{"post_id":"clq3jh5v8003ki3er9rty9e6h","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5ve0081i3ercx3x9acv"},{"post_id":"clq3jh5v8003ki3er9rty9e6h","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5ve0083i3er3m99bh5m"},{"post_id":"clq3jh5vj00bei3er773p8b6s","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vk00bki3erd5ah7g47"},{"post_id":"clq3jh5vj00bei3er773p8b6s","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vk00bni3er4zfc239b"},{"post_id":"clq3jh5vj00bfi3er5gc6bdja","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vk00bqi3erafj91c6j"},{"post_id":"clq3jh5vj00bfi3er5gc6bdja","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vk00bti3eraqg7hcs7"},{"post_id":"clq3jh5vj00bhi3erfmdhblyj","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vl00bwi3ere631dqzt"},{"post_id":"clq3jh5vj00bhi3erfmdhblyj","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vl00bzi3ergp19fdgn"},{"post_id":"clq3jh5vk00bji3erc5hi1ucd","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vl00c2i3er9i31014x"},{"post_id":"clq3jh5vk00bji3erc5hi1ucd","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vl00c4i3erckgqcuaq"},{"post_id":"clq3jh5vk00bmi3er1y76gj4o","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vl00c6i3er0xq017uw"},{"post_id":"clq3jh5vk00bmi3er1y76gj4o","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vl00c8i3er04rz0a8l"},{"post_id":"clq3jh5vk00bpi3er26ps7cta","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vl00cai3er28b17y5o"},{"post_id":"clq3jh5vk00bpi3er26ps7cta","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vl00cci3ercs9mg4n1"},{"post_id":"clq3jh5vk00bsi3erdtnnh9g5","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vl00cdi3er37d7apkk"},{"post_id":"clq3jh5vk00bsi3erdtnnh9g5","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vl00cei3ercbwtevi9"},{"post_id":"clq3jh5vl00bvi3erdkdc1tch","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vl00cfi3er9el22rxi"},{"post_id":"clq3jh5vl00bvi3erdkdc1tch","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vl00cgi3er8txeb4ag"},{"post_id":"clq3jh5vl00byi3er4j2vdw55","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vl00chi3eramzz0atn"},{"post_id":"clq3jh5vl00byi3er4j2vdw55","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vl00cii3erc81pbtp6"},{"post_id":"clq3jh5vl00c1i3er3k93f7g8","category_id":"clq3jh5uu0002i3er8a01e5ee","_id":"clq3jh5vl00cji3er4ycbaduq"},{"post_id":"clq3jh5vl00c1i3er3k93f7g8","category_id":"clq3jh5vc0065i3er24og82vg","_id":"clq3jh5vl00cki3er440e8odn"}],"PostTag":[{"post_id":"clq3jh5ur0000i3er7pos1jbu","tag_id":"clq3jh5uv0003i3er9lxshoze","_id":"clq3jh5uy000ii3er873wei70"},{"post_id":"clq3jh5ur0000i3er7pos1jbu","tag_id":"clq3jh5uw0008i3erepp24lv6","_id":"clq3jh5uy000li3erapoqcq42"},{"post_id":"clq3jh5ur0000i3er7pos1jbu","tag_id":"clq3jh5ux000ci3er25t74bqf","_id":"clq3jh5uz000oi3era6l8b5zi"},{"post_id":"clq3jh5uu0001i3er63pvd6c7","tag_id":"clq3jh5uy000gi3er6h7t49lw","_id":"clq3jh5uz000ri3erbdytal30"},{"post_id":"clq3jh5uv0004i3er49x8foyu","tag_id":"clq3jh5uy000mi3er42a8db6y","_id":"clq3jh5v00013i3erd3wlawde"},{"post_id":"clq3jh5uv0004i3er49x8foyu","tag_id":"clq3jh5uz000ui3er2r7k396v","_id":"clq3jh5v00017i3er0gamai8g"},{"post_id":"clq3jh5uv0005i3erayluha0f","tag_id":"clq3jh5v00010i3erf7e8g5vu","_id":"clq3jh5v2001li3er5ikx2p1u"},{"post_id":"clq3jh5uv0005i3erayluha0f","tag_id":"clq3jh5v10018i3erhbxj44bs","_id":"clq3jh5v2001oi3erfz8n4onl"},{"post_id":"clq3jh5uv0005i3erayluha0f","tag_id":"clq3jh5v1001di3erc12v5jk7","_id":"clq3jh5v2001ri3era84426wi"},{"post_id":"clq3jh5uw0006i3erhxy2df2d","tag_id":"clq3jh5v00010i3erf7e8g5vu","_id":"clq3jh5v30024i3er8lsp193m"},{"post_id":"clq3jh5uw0006i3erhxy2df2d","tag_id":"clq3jh5v10018i3erhbxj44bs","_id":"clq3jh5v40028i3ercv2w9yzy"},{"post_id":"clq3jh5uw0006i3erhxy2df2d","tag_id":"clq3jh5v1001di3erc12v5jk7","_id":"clq3jh5v4002ci3ercyhlag1j"},{"post_id":"clq3jh5uw0009i3er2xbtcrxl","tag_id":"clq3jh5v30022i3ercluodzl3","_id":"clq3jh5v5002ii3erg3sn06a6"},{"post_id":"clq3jh5uw0009i3er2xbtcrxl","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5v5002li3ere4uid0n6"},{"post_id":"clq3jh5ux000ai3erbfkj385b","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5v60031i3er4v1o0inj"},{"post_id":"clq3jh5ux000ai3erbfkj385b","tag_id":"clq3jh5v30022i3ercluodzl3","_id":"clq3jh5v70035i3eraat42hx5"},{"post_id":"clq3jh5ux000ai3erbfkj385b","tag_id":"clq3jh5v5002si3er1cxd2jof","_id":"clq3jh5v70039i3er7eq42bb0"},{"post_id":"clq3jh5ux000di3er7oi7cu97","tag_id":"clq3jh5uy000mi3er42a8db6y","_id":"clq3jh5v8003di3er42rofxsi"},{"post_id":"clq3jh5ux000ei3ercxxn5wnr","tag_id":"clq3jh5v70037i3erg8hqfqzu","_id":"clq3jh5v9003pi3ergda166ux"},{"post_id":"clq3jh5ux000ei3ercxxn5wnr","tag_id":"clq3jh5v8003gi3erdwchdqs0","_id":"clq3jh5v9003ri3erb52t8ing"},{"post_id":"clq3jh5uy000hi3erdfd14os0","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5va004ci3erey9bc8x7"},{"post_id":"clq3jh5uy000hi3erdfd14os0","tag_id":"clq3jh5v9003si3ercvatcf55","_id":"clq3jh5va004ei3erg2lkbukp"},{"post_id":"clq3jh5uy000hi3erdfd14os0","tag_id":"clq3jh5v9003wi3er5v254j9c","_id":"clq3jh5va004ii3er7mu5hd6r"},{"post_id":"clq3jh5uy000hi3erdfd14os0","tag_id":"clq3jh5v90040i3erc5zn2iox","_id":"clq3jh5va004ki3ercoemg3za"},{"post_id":"clq3jh5uy000hi3erdfd14os0","tag_id":"clq3jh5v90046i3er2hof2vwa","_id":"clq3jh5va004oi3er6boxg3vy"},{"post_id":"clq3jh5uy000ji3er1gb9cd8p","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5va004ti3er8uvuglxn"},{"post_id":"clq3jh5uy000ji3er1gb9cd8p","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5va004vi3er68ew8ix2"},{"post_id":"clq3jh5uy000ji3er1gb9cd8p","tag_id":"clq3jh5va004li3erah107o2i","_id":"clq3jh5va004zi3er1ny2fan7"},{"post_id":"clq3jh5uz000ni3erd6voc7xp","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vb0058i3er75sg85ta"},{"post_id":"clq3jh5uz000ni3erd6voc7xp","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vb005bi3ere3d4co5u"},{"post_id":"clq3jh5uz000ni3erd6voc7xp","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vb005ei3er34sf3uwc"},{"post_id":"clq3jh5uz000pi3er9vljappz","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vb005ri3er90qs7bed"},{"post_id":"clq3jh5uz000pi3er9vljappz","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vb005ui3erbxe9dh4t"},{"post_id":"clq3jh5uz000pi3er9vljappz","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vb005xi3er454xc210"},{"post_id":"clq3jh5uz000pi3er9vljappz","tag_id":"clq3jh5vb005li3er12031pa3","_id":"clq3jh5vb0060i3er326r16kn"},{"post_id":"clq3jh5uz000ti3ercqpye45m","tag_id":"clq3jh5vb005qi3er7yad01uz","_id":"clq3jh5vc0064i3ergexi21a2"},{"post_id":"clq3jh5uz000ti3ercqpye45m","tag_id":"clq3jh5vb005wi3erh2rn4s2o","_id":"clq3jh5vc0067i3er4alr7efg"},{"post_id":"clq3jh5uz000wi3erfcq2gxw1","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vc006ii3erf1jm5dfk"},{"post_id":"clq3jh5uz000wi3erfcq2gxw1","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vc006li3er8oqc2cas"},{"post_id":"clq3jh5uz000wi3erfcq2gxw1","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vc006oi3er8gvzhjna"},{"post_id":"clq3jh5v0000zi3er3p7r5fza","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vd006xi3erb71d95m1"},{"post_id":"clq3jh5v0000zi3er3p7r5fza","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vd0070i3er3bjyciot"},{"post_id":"clq3jh5v0000zi3er3p7r5fza","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vd0073i3ergl0qht29"},{"post_id":"clq3jh5v00012i3er6db59mam","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vd007ci3erhc7x655p"},{"post_id":"clq3jh5v00012i3er6db59mam","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vd007fi3er4x436ig4"},{"post_id":"clq3jh5v00012i3er6db59mam","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vd007ii3erfrvo6cby"},{"post_id":"clq3jh5v00015i3erexcc8ama","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5ve007ri3er9bo318hg"},{"post_id":"clq3jh5v00015i3erexcc8ama","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5ve007ui3er6nov6my1"},{"post_id":"clq3jh5v00015i3erexcc8ama","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5ve007xi3er07wt3b47"},{"post_id":"clq3jh5v1001ai3er13tqfwrl","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5ve0084i3erec9kd9ek"},{"post_id":"clq3jh5v1001ai3er13tqfwrl","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5ve0085i3erc5zqfrgz"},{"post_id":"clq3jh5v1001ai3er13tqfwrl","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5ve0087i3er3sobfdna"},{"post_id":"clq3jh5v1001bi3eravg9ei7t","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5ve008ai3eran1w2ovv"},{"post_id":"clq3jh5v1001bi3eravg9ei7t","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5ve008bi3er5jlnbhdf"},{"post_id":"clq3jh5v1001bi3eravg9ei7t","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5ve008di3er90zqhkrw"},{"post_id":"clq3jh5v1001ei3er283u9k9n","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vf008gi3erby7i2rug"},{"post_id":"clq3jh5v1001ei3er283u9k9n","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vf008hi3er6a10dfro"},{"post_id":"clq3jh5v1001ei3er283u9k9n","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vf008ji3er3r5bhvia"},{"post_id":"clq3jh5v1001fi3er667q225p","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vf008mi3er3fkc2d4p"},{"post_id":"clq3jh5v1001fi3er667q225p","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vf008ni3erbviohkuh"},{"post_id":"clq3jh5v1001fi3er667q225p","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vf008pi3er5qbeer5f"},{"post_id":"clq3jh5v2001ii3erg39he2m2","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vf008qi3er5ggv59sq"},{"post_id":"clq3jh5v2001mi3eresfz5nxp","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vf008vi3er99ck2jyj"},{"post_id":"clq3jh5v2001mi3eresfz5nxp","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vf008wi3erb1njh5ie"},{"post_id":"clq3jh5v2001mi3eresfz5nxp","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vf008yi3ercpjr6b9b"},{"post_id":"clq3jh5v2001mi3eresfz5nxp","tag_id":"clq3jh5vb005li3er12031pa3","_id":"clq3jh5vf008zi3eraedo1dw4"},{"post_id":"clq3jh5v2001pi3erfchh77jc","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vf0092i3er3cch8h90"},{"post_id":"clq3jh5v2001pi3erfchh77jc","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vf0093i3er3py5f0ll"},{"post_id":"clq3jh5v2001pi3erfchh77jc","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vf0095i3erfd3u0oci"},{"post_id":"clq3jh5v2001si3ere06y0anh","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vg0098i3er5j3rg9bt"},{"post_id":"clq3jh5v2001si3ere06y0anh","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vg0099i3erfes7hs0p"},{"post_id":"clq3jh5v2001si3ere06y0anh","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vg009bi3er367m0o69"},{"post_id":"clq3jh5v3001vi3erc4qf2j23","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vg009ei3er3ocahn9f"},{"post_id":"clq3jh5v3001vi3erc4qf2j23","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vg009fi3er5xkkg1ii"},{"post_id":"clq3jh5v3001vi3erc4qf2j23","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vg009hi3er2jaoe42v"},{"post_id":"clq3jh5v3001yi3er3s8x7vrc","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vg009ji3er07ghg5wo"},{"post_id":"clq3jh5v3001yi3er3s8x7vrc","tag_id":"clq3jh5vb005wi3erh2rn4s2o","_id":"clq3jh5vg009ki3erdaq5dnis"},{"post_id":"clq3jh5v30021i3ercres23fu","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vg009pi3erchzh0ovr"},{"post_id":"clq3jh5v30021i3ercres23fu","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vg009qi3er4783cbob"},{"post_id":"clq3jh5v30021i3ercres23fu","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vg009si3erhytg84wv"},{"post_id":"clq3jh5v30021i3ercres23fu","tag_id":"clq3jh5vb005li3er12031pa3","_id":"clq3jh5vg009ti3er9xsq3ysz"},{"post_id":"clq3jh5v30025i3er6xzu46kl","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vg009xi3ergwbfgw6w"},{"post_id":"clq3jh5v30025i3er6xzu46kl","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vg009yi3erb1wj1pl8"},{"post_id":"clq3jh5v30025i3er6xzu46kl","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vg00a0i3erh4e11zb5"},{"post_id":"clq3jh5v30025i3er6xzu46kl","tag_id":"clq3jh5vb005li3er12031pa3","_id":"clq3jh5vg00a1i3er74flb8yt"},{"post_id":"clq3jh5v40029i3er986259sd","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vh00a4i3ercyfgfkm5"},{"post_id":"clq3jh5v40029i3er986259sd","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vh00a5i3er3rw7fk8t"},{"post_id":"clq3jh5v40029i3er986259sd","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vh00a7i3erckwxf9dr"},{"post_id":"clq3jh5v4002di3er3xur5wy0","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vh00a9i3er8d8kfngn"},{"post_id":"clq3jh5v4002di3er3xur5wy0","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vh00aai3era7iceqgg"},{"post_id":"clq3jh5v4002di3er3xur5wy0","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vh00aci3erd7w422q9"},{"post_id":"clq3jh5v4002fi3er6qixg83b","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vh00afi3er5eou6mpa"},{"post_id":"clq3jh5v4002fi3er6qixg83b","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vh00agi3er2xfc1exm"},{"post_id":"clq3jh5v4002fi3er6qixg83b","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vh00aii3er39jzerbr"},{"post_id":"clq3jh5v4002fi3er6qixg83b","tag_id":"clq3jh5vb005li3er12031pa3","_id":"clq3jh5vh00aji3ergqmt7ljk"},{"post_id":"clq3jh5v4002hi3erb8kp4ya7","tag_id":"clq3jh5v4002ai3ergnjg8ll8","_id":"clq3jh5vh00ali3er8bbp49lk"},{"post_id":"clq3jh5v4002hi3erb8kp4ya7","tag_id":"clq3jh5v4002gi3er108g5f94","_id":"clq3jh5vh00ami3erapx339oc"},{"post_id":"clq3jh5v4002hi3erb8kp4ya7","tag_id":"clq3jh5va0052i3erfs8647pn","_id":"clq3jh5vh00aoi3erfcmtawd4"},{"post_id":"clq3jh5v4002hi3erb8kp4ya7","tag_id":"clq3jh5vb005li3er12031pa3","_id":"clq3jh5vh00api3er8osghji6"},{"post_id":"clq3jh5v5002ji3erb628hybv","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vh00ari3er3s682cgk"},{"post_id":"clq3jh5v5002ni3erb3le22d5","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vh00asi3ereovkaprx"},{"post_id":"clq3jh5v5002pi3er38mhdvy8","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vh00aui3er03812w3u"},{"post_id":"clq3jh5v5002ti3er80nsepzt","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vh00awi3erc5l7hb74"},{"post_id":"clq3jh5v6002vi3er5zek68eq","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vi00ayi3er53hogxco"},{"post_id":"clq3jh5v6002yi3er8lg37gxl","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vi00b0i3er7a8hg2fz"},{"post_id":"clq3jh5v60032i3er6pxt8j3h","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vi00b2i3er0ycxcmd4"},{"post_id":"clq3jh5v70036i3erfb4salgq","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vi00b4i3er170uc3vp"},{"post_id":"clq3jh5v8003ai3er6sn77efv","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vi00b6i3er9q3zbvdo"},{"post_id":"clq3jh5v8003ei3erfam2gek3","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vi00b8i3erg4ry59v7"},{"post_id":"clq3jh5v8003ei3erfam2gek3","tag_id":"clq3jh5ux000ci3er25t74bqf","_id":"clq3jh5vi00b9i3er590ygfbe"},{"post_id":"clq3jh5v8003hi3er55ha3e5w","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vi00bbi3er0nsa06mx"},{"post_id":"clq3jh5v8003ki3er9rty9e6h","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vi00bci3er4pjq2koz"},{"post_id":"clq3jh5v8003ki3er9rty9e6h","tag_id":"clq3jh5ux000ci3er25t74bqf","_id":"clq3jh5vi00bdi3er0nfe2xio"},{"post_id":"clq3jh5vj00bei3er773p8b6s","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vj00bgi3er8dtccdzr"},{"post_id":"clq3jh5vj00bfi3er5gc6bdja","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vk00bii3er751qgqdv"},{"post_id":"clq3jh5vj00bhi3erfmdhblyj","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vk00bli3er1iduarud"},{"post_id":"clq3jh5vj00bhi3erfmdhblyj","tag_id":"clq3jh5ux000ci3er25t74bqf","_id":"clq3jh5vk00boi3er3gfhe077"},{"post_id":"clq3jh5vk00bji3erc5hi1ucd","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vk00bri3er11kn7zs3"},{"post_id":"clq3jh5vk00bmi3er1y76gj4o","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vl00bui3er6i6w4ft3"},{"post_id":"clq3jh5vk00bmi3er1y76gj4o","tag_id":"clq3jh5ux000ci3er25t74bqf","_id":"clq3jh5vl00bxi3erdkq5he9k"},{"post_id":"clq3jh5vk00bpi3er26ps7cta","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vl00c0i3er0m0p9sal"},{"post_id":"clq3jh5vk00bsi3erdtnnh9g5","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vl00c3i3erb1q53xh7"},{"post_id":"clq3jh5vk00bsi3erdtnnh9g5","tag_id":"clq3jh5ux000ci3er25t74bqf","_id":"clq3jh5vl00c5i3er5soa8i70"},{"post_id":"clq3jh5vl00bvi3erdkdc1tch","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vl00c7i3erao34emso"},{"post_id":"clq3jh5vl00byi3er4j2vdw55","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vl00c9i3erd4ateoz0"},{"post_id":"clq3jh5vl00c1i3er3k93f7g8","tag_id":"clq3jh5vh00aki3er9pqngktg","_id":"clq3jh5vl00cbi3erevdlgimx"}],"Tag":[{"name":"zsh","_id":"clq3jh5uv0003i3er9lxshoze"},{"name":"theme","_id":"clq3jh5uw0008i3erepp24lv6"},{"name":"⭐️","_id":"clq3jh5ux000ci3er25t74bqf"},{"name":"git","_id":"clq3jh5uy000gi3er6h7t49lw"},{"name":"jekyll","_id":"clq3jh5uy000mi3er42a8db6y"},{"name":"gitee","_id":"clq3jh5uz000ui3er2r7k396v"},{"name":"docker","_id":"clq3jh5v00010i3erf7e8g5vu"},{"name":"linux","_id":"clq3jh5v10018i3erhbxj44bs"},{"name":"shell","_id":"clq3jh5v1001di3erc12v5jk7"},{"name":"pylint","_id":"clq3jh5v30022i3ercluodzl3"},{"name":"python","_id":"clq3jh5v4002ai3ergnjg8ll8"},{"name":"django","_id":"clq3jh5v4002gi3er108g5f94"},{"name":"vscode","_id":"clq3jh5v5002si3er1cxd2jof"},{"name":"Database","_id":"clq3jh5v70037i3erg8hqfqzu"},{"name":"MySQL","_id":"clq3jh5v8003gi3erdwchdqs0"},{"name":"pip","_id":"clq3jh5v9003si3ercvatcf55"},{"name":"pipenv","_id":"clq3jh5v9003wi3er5v254j9c"},{"name":"mysql","_id":"clq3jh5v90040i3erc5zn2iox"},{"name":"exception","_id":"clq3jh5v90046i3er2hof2vwa"},{"name":"opensource","_id":"clq3jh5va004li3erah107o2i"},{"name":"backend","_id":"clq3jh5va0052i3erfs8647pn"},{"name":"REST","_id":"clq3jh5vb005li3er12031pa3"},{"name":"gem","_id":"clq3jh5vb005qi3er7yad01uz"},{"name":"config","_id":"clq3jh5vb005wi3erh2rn4s2o"},{"name":"design-pattern","_id":"clq3jh5vh00aki3er9pqngktg"}]}}